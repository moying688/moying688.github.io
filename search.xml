<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字节面试三月后复盘</title>
      <link href="/2025/06/15/%E9%9D%A2%E8%AF%95/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/06/15/%E9%9D%A2%E8%AF%95/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>字节飞书 一面<br>1.自我介绍起手<br>2.你觉得你认为你做过的项目中最有挑战性的技术点<br>3.如何解决？收获是什么？<br>4.你这里提到了Etcd，你说说使用过程中学到了什么？<br>5.讲讲Raft算法吧<br>6.做个题吧  判断B是A的子结构（二叉树）<br>7.你觉得你认为目前接触到的最困难的技术点或者技术栈是什么？或者说你认为你最感兴趣的是哪些？<br>8.说了对计网和es最感兴趣（然后面试官就让我讲讲我对于计网的理解）<br>9.讲到了数据链路层和物理层以及网卡之间的缓冲区。然后讲了QUIC。（提问，为什么不用Http3.0？历史遗留问题又是什么？）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯面试三月后复盘</title>
      <link href="/2025/06/15/%E9%9D%A2%E8%AF%95/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E4%B8%89%E6%9C%88%E5%90%8E%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/06/15/%E9%9D%A2%E8%AF%95/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E4%B8%89%E6%9C%88%E5%90%8E%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>本身这场面试时间极短，也完全没有八股</p><p>但由于是笔者第一次面试（刚开始进入暑假实习投递，腾子太快了QAQ</p><p>现在回顾起来，腾讯此时这场面试更加考验笔者的自我学习能力以及是否会自己深挖</p></blockquote><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>1.自我介绍起手，然后丢两个算法题</p><p> (1) O（n）计算最长连续子序列长度<br>  (2)检验二叉树是否成环（快慢指针+先序） md第一个我记得力扣原题做过的，忘记了，后面用的快排+dp，面试官同意nlogn了，二叉树这个就是有点卡壳（悲）<br>2.我看你简历项目都是用了ElasticSearch，那你说说他跟MySQL的使用体验（提了MySQL模糊查询，es的倒排索引，lsm树之类的）<br>3.为什么不能用es替代MySQL（场景+资源消耗）<br>4.目前学了哪些计算机专业课程<br>5.我看你在杭州是吧，然后是3-6月的实习时间阿巴阿巴。<br>6.除了简历上做过的项目，还做过哪些？</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><h3 id="1-算法题"><a href="#1-算法题" class="headerlink" title="1.算法题"></a>1.算法题</h3><h4 id="O（n）计算最长连续子序列长度"><a href="#O（n）计算最长连续子序列长度" class="headerlink" title="O（n）计算最长连续子序列长度"></a>O（n）计算最长连续子序列长度</h4><blockquote><p>经典LeetCode题，当时虽然没有刷到过，但是On肯定了就是哈希表，但是当时由于想用数组做哈希，导致卡壳后换成DP</p></blockquote><h5 id="正常哈希"><a href="#正常哈希" class="headerlink" title="正常哈希"></a>正常哈希</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果有更小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(num + <span class="number">1</span>)) &#123;</span><br><span class="line">                tempLen++;</span><br><span class="line">                num = num + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, tempLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> num - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.remove(left)) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.remove(right)) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, right - left - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>检验二叉树是否成环</li></ol><blockquote><p>?? 当时紧张麻了吧？ 二叉树成环了，还能叫树吗？但是居然没有质疑</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>快慢指针（当时的方法</span><br><span class="line"><span class="number">2.</span>使用一个visited 保存结点状态</span><br></pre></td></tr></table></figure><h3 id="2-ElasticSearch"><a href="#2-ElasticSearch" class="headerlink" title="2. ElasticSearch"></a>2. ElasticSearch</h3><p>我看你简历项目都是用了ElasticSearch，那你说说他跟MySQL的使用体验</p><blockquote><p>现在想来，很明显是想问你，学习以及使用过后，他们的应用场景、优势劣势</p><p>现在复盘的话</p></blockquote><p>首先他们定位就完全不一样，MySQL作为关系型数据库ElasticSearch则是天然支持分布式的一个搜索引擎</p><p>但其实说是搜索引擎，但是如果只是用它的分词搜索功能，便直接引入这个组件，是非常浪费的</p><p>MySQL重要需要思考的是，为什么很简单的web开发，貌似都会使用MySQL或者其他关系型数据库？</p><p>（这点其实可以先从文件存储管理先去思考），以及强大的事务、一致性</p><p>而ES如同官网所列举出来的一样。</p><p><img src="/2025/06/15/%E9%9D%A2%E8%AF%95/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E4%B8%89%E6%9C%88%E5%90%8E%E5%A4%8D%E7%9B%98/image-20250618165717095.png" alt="image-20250618165717095"></p><p>（1）数据存储:  由于ES天然支持分布式，也就是架构设计时，通过多种结点去存储数据</p><ul><li>协调结点（Coordinating Node 负责接收请求、拆分请求、分发到各个结点，最后聚合结果</li><li>存储结点（Data Node 负责存储数据、处理读写请求</li><li>主结点（master Node 复杂管理Cluster状态（建索引、删除、分片分片等）</li><li>预处理结点（Ingest Node 做预处理</li></ul><p>每个结点可以有多个身份。也就是说，通过协调结点，将读写请求分配到对应的存储结点上，ES有DocID以及_id，通过 _id（唯一）定位数据存储在哪一个分片（主分片会有一个Data Node去管理它）</p><p><strong>也就是说，作为存储引擎的话，ES显然是不错的，无需像MySQL那样自己去哈希路由，并且我们可以使用SSD去存储热数据结点，用HHD&#x2F;HDD去存储冷数据结点</strong></p><p>（2）向量数据库（如果系统本身已经引入ES，又考虑落地 AI应用的话，很推荐）</p><p>但是7.x版本速度极慢，不支持HNSW、不支持ANN搜索，内存占用大（dense_vertor无压缩</p><p>8.x引入Knn_vector，</p><p>（3）分析引擎（是ELK，我们有救了）</p><p>ES的索引底层是？ 倒排索引（好了，回去等通知吧）</p><p>ES关键存储有倒排索引（FST+Posting list）、正排索引（_source–&gt;文档）、docValue（列式存储）</p><p>纯数据聚合分析时，docValue速度极快，而加入条件时，通过倒排索引去筛选</p><p>将分析请求通过<strong>协调结点</strong>发布到各个分片上，并发聚合分析然后将结果跟协调结点进行合并</p><p>（4）搜索引擎</p><p>对于复杂条件支持上，ES的must、should、must_not显然更加优秀</p><p>且ES是多结点并发查询，每个should都会先查询出一个文档集合然后去和其他的should求交集</p><p>且倒排索引（FST） 支持模糊查询，查询 apple 时支持可以查询到apply</p><p>（5）地理空间引擎</p><p>这里可以想到经典的外卖场景或者打车</p><ul><li><p><code>geo_shape</code>：支持复杂的几何图形，比如：Polygon（多边形）、MultiPolygon（多个多边形）、Line、Envelope 等等。</p><p>通过图形求交集</p></li><li><p>也可以通过 存储 id形成一种网络栏栅</p></li></ul><h3 id="3-为什么不能用ES去代替MySQL"><a href="#3-为什么不能用ES去代替MySQL" class="headerlink" title="3. 为什么不能用ES去代替MySQL"></a>3. 为什么不能用ES去代替MySQL</h3><blockquote><p>当时回答简直闹麻了，完全就脱离了核心，当时说的是，ES资源占用极大，应用场景（但是这里答得贼不好）</p></blockquote><p>最基本的点： </p><p>对于萌新来说，使用成本更高（学习上，以及构建Mapping时，mapping无法修改删除字段，只能添加字段）</p><p>ES 近实时搜索（由于二阶段提交的缘故，写入的数据无法实时搜索到）</p><p>ES 容错性更低，一致性弱，不支持多表事务（这在很多场景是大忌啊）</p><p>ES的数据模型松散，复杂关系建模很痛苦（比如订单拆分、子表操作），且没有主键&#x2F;外键&#x2F;约束</p><p>高频的小事务处理尤为不划算（<strong>ES 是为“读优化”设计的</strong>，虽然Lucene和LSM树很相似，但是目的大不相同</p><h3 id="456"><a href="#456" class="headerlink" title="456"></a>456</h3><p>这里就基本没什么了，害，前面回答太拉跨了，估计人家也觉得没必要了</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL调优</title>
      <link href="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/"/>
      <url>/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-SQL调优实战"><a href="#MySQL-SQL调优实战" class="headerlink" title="MySQL SQL调优实战"></a>MySQL SQL调优实战</h2><blockquote><p>后续把我的ArchLinux docker证书弄好，再考虑Es，Windows感觉太不方便了还是</p><p>文章暂时也不会很详细针对const、ref、range去进行优化，一般达到range已经完全足够了</p></blockquote><p>表结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">商品表：product</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">id (<span class="type">int</span>, pk)</span><br><span class="line">name (<span class="type">varchar</span>)</span><br><span class="line">category_id (<span class="type">int</span>)</span><br><span class="line">price (<span class="type">decimal</span>)</span><br><span class="line">status (tinyint) <span class="comment">-- 0 下架，1 上架</span></span><br><span class="line">create_time (datetime)</span><br><span class="line"></span><br><span class="line">商品详情表：product_detail</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">id (<span class="type">int</span>, pk)</span><br><span class="line">product_id (<span class="type">int</span>, fk)</span><br><span class="line">description (text)</span><br><span class="line">sales_volume (<span class="type">int</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用户希望在商品页中加载「最近一个月内上架的、销量前20的商品」并按分类聚合。</p><h3 id="初始化表-mock数据"><a href="#初始化表-mock数据" class="headerlink" title="初始化表&amp;mock数据"></a>初始化表&amp;mock数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建商品表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    category_id <span class="type">INT</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    status TINYINT,</span><br><span class="line">    create_time DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建商品详情表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product_detail;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_detail (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    description TEXT,</span><br><span class="line">    sales_volume <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (product_id) <span class="keyword">REFERENCES</span> product(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 存储过程：批量插入数据</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> generate_data <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> generate_data()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> recent_days <span class="type">INT</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;=</span> <span class="number">100000</span> DO</span><br><span class="line">        <span class="comment">-- 随机天数（0-365）</span></span><br><span class="line">        <span class="keyword">SET</span> recent_days <span class="operator">=</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">365</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 插入 product 表</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (</span><br><span class="line">            name, category_id, price, status, create_time</span><br><span class="line">        ) <span class="keyword">VALUES</span> (</span><br><span class="line">            CONCAT(<span class="string">&#x27;Product_&#x27;</span>, i),</span><br><span class="line">            <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">20</span>),</span><br><span class="line">            ROUND(RAND() <span class="operator">*</span> <span class="number">1000</span>, <span class="number">2</span>),</span><br><span class="line">            IF(RAND() <span class="operator">&gt;</span> <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> recent_days <span class="keyword">DAY</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 插入 product_detail 表（用 LAST_INSERT_ID 拿到自增主键）</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_detail (</span><br><span class="line">            product_id, description, sales_volume</span><br><span class="line">        ) <span class="keyword">VALUES</span> (</span><br><span class="line">            LAST_INSERT_ID(),</span><br><span class="line">            CONCAT(<span class="string">&#x27;Description of product &#x27;</span>, i),</span><br><span class="line">            <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">10000</span>)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行生成过程</span></span><br><span class="line"><span class="keyword">CALL</span> generate_data();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615154906401.png" alt="image-20250615154906401"></p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615154916254.png" alt="image-20250615154916254"></p><p>后续稳定到0.07s左右（buffer pool</p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615155102227.png" alt="image-20250615155102227"></p><p>当然了，我们没有添加索引，直接就是全表扫描（type&#x3D;ALL</p><h4 id="高效索引"><a href="#高效索引" class="headerlink" title="高效索引"></a>高效索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> product <span class="keyword">ADD</span> INDEX idx_status_createtime (status, create_time);</span><br><span class="line">这里首先</span><br><span class="line">status 一般是恒等的，因为需要查询某个状态，而create_time则通常是范围查询</span><br><span class="line">由于索引数据结构为B<span class="operator">+</span>树，在建立索引时，status应当放到create_time之前</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立索引后</p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615155647091.png" alt="image-20250615155647091"></p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615155658856.png" alt="image-20250615155658856"></p><p>可以看到rows大幅下降，且type也是显示range，extra 中变为using index</p><h4 id="低效索引"><a href="#低效索引" class="headerlink" title="低效索引"></a>低效索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将status和time位置交换</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">drop</span> index idx_status_createtime;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> product <span class="keyword">ADD</span> INDEX idx_status_createtime ( create_time,status);</span><br></pre></td></tr></table></figure><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615160021249.png" alt="image-20250615160021249"></p><p>可以看到过滤率更低，且rows更高（create_time范围查询，而status&#x3D;1只能在回表时进行过滤</p><ul><li><p>这里没有到达索引覆盖</p></li><li><p>引用了子查询的条件不能下推；</p></li><li><p>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</p></li></ul><h3 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h3><blockquote><p>首先我们通过触发器也是造了10w条数据</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">add</span> index idx_createtime(create_time);</span><br></pre></td></tr></table></figure><p>可以看到，将limit 后的0 改为50000，查询速度却差了一大截</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">我们走索引查询，但是由于 没有索引覆盖，会进行回表查询</span><br><span class="line">但是第二个语句</span><br><span class="line">第一次查询，会查询<span class="number">50000</span><span class="operator">+</span><span class="number">10</span>条的id<span class="operator">+</span>update_time</span><br><span class="line">第二次查询，回表查询<span class="number">50000</span><span class="operator">+</span><span class="number">10</span>条数据行，然后丢弃<span class="number">50000</span>条</span><br><span class="line">第二次查询完完全全是浪费的，完全没必要把<span class="number">50000</span>进行回表</span><br></pre></td></tr></table></figure><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615161807825.png" alt="image-20250615161807825"></p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615161821312.png" alt="image-20250615161821312"></p><h4 id="延迟关联优化"><a href="#延迟关联优化" class="headerlink" title="延迟关联优化"></a>延迟关联优化</h4><p>既然拖慢速度的关键是回表查询时，把无用的50000条数据也拿去筛选了</p><p>那我们不妨提前丢掉（MySQL优化器是无法直接做到的）所以需要我们自己实现逻辑</p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615162417720.png" alt="image-20250615162417720"></p><p>可以看到速度大大滴提高了</p><h4 id="游标分页"><a href="#游标分页" class="headerlink" title="游标分页"></a>游标分页</h4><blockquote><p>需要保证id为自增的，我们记录50000条的数据id，从它后面再数10条即可</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 记住上一页最后一条记录的create_time和id</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product</span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;上一页最后时间&#x27;</span> <span class="keyword">OR</span> </span><br><span class="line">      (create_time <span class="operator">=</span> <span class="string">&#x27;上一页最后时间&#x27;</span> <span class="keyword">AND</span> id <span class="operator">&gt;</span> <span class="string">&#x27;上一页最后ID&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time, id</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><blockquote><p>我们知道，当使用二级索引时，不满足索引覆盖则会进行回表查询</p><p>且当不符合最左匹配时，后面的属性列不会走索引，</p><p>select * from table where a &gt; 1 and b &#x3D; 1（此时b索引是失效的</p></blockquote><p>设计者显然也会想到这点，比如我们要查询的数据包含了全部索引，</p><p>那我还要白白去回表查询大量完整数据行</p><p>然后在server层去条件过滤，那就太浪费了。</p><p>因此有了索引下推： 但我们查询属性包含索引列时，即使后面的索引条件失效，但是当我们通过a &gt; 1查询到数据后，在回表查询前，会在引擎层，先用 b &#x3D;1 进行一次过滤然后再进行回表查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">add</span> index idx_price_status(price,STATUS);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100.0</span>;</span><br><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100.0</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100.0</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615164013127.png" alt="image-20250615164013127"></p><p><img src="/2025/06/15/MySQL/SQL%E8%B0%83%E4%BC%98/image-20250615163949141.png" alt="image-20250615163949141"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCP_ELK</title>
      <link href="/2025/06/11/AI/MCP-ELK/"/>
      <url>/2025/06/11/AI/MCP-ELK/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Snowflake</title>
      <link href="/2025/06/10/%E5%88%86%E5%B8%83%E5%BC%8F/Snowflake/"/>
      <url>/2025/06/10/%E5%88%86%E5%B8%83%E5%BC%8F/Snowflake/</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="ID那些事"><a href="#ID那些事" class="headerlink" title="ID那些事"></a>ID那些事</h2><h3 id="对于Id的要求"><a href="#对于Id的要求" class="headerlink" title="对于Id的要求"></a>对于Id的要求</h3><h4 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h4><ol><li>全局唯一性： 不能出现重复的id，这是最基本的要求</li><li>信息安全： 如果只是单纯的自增行为，要是有人恶意爬取分析就很难受了，经典的友商对自家商单数量分析，爬虫制定好 Url 爽爽爬取</li><li>可读性</li></ol><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ol><li>递增趋势： 由于我们常常使用MySQL这样的关系型数据库进行数据 存储，且常用的InnoDB引擎采用的B+树索引，所以主键选取上尽量采用有序的主键（不然每次insert都是一次大开销</li><li>单调递增： 保证下一个ID一定要大于上一个ID，方便进行排序、版本号等特殊需求</li></ol><h3 id="目前ID的使用方式"><a href="#目前ID的使用方式" class="headerlink" title="目前ID的使用方式"></a>目前ID的使用方式</h3><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><ul><li>简单、满足全局唯一性、信息安全</li></ul><p>但是无序、且没有可读性，并且有另外的信息安全风险（我记得，有一个著名病毒作者就是被分析出MAC地址，然后被逮捕归案</p><h4 id="Redis生成"><a href="#Redis生成" class="headerlink" title="Redis生成"></a>Redis生成</h4><ul><li>满足全局唯一性、单调递增、可读性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过 prefix + yyyyMMdd + sequence 这个格式生成id，其中sequence通过redis的incr命令生成</span><br></pre></td></tr></table></figure><p>不安全</p><h4 id="DB自增"><a href="#DB自增" class="headerlink" title="DB自增"></a>DB自增</h4><ul><li>唯一性、严格递增、可读</li></ul><p>但很不安全啊！</p><h4 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h4><blockquote><p>终于到文章主角了？！</p></blockquote><p>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。</p><p>基础的雪花算法 id结构组成： <strong>1位符号位+ 41位时间位+10位机器位+12位序列号位</strong></p><p>41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">Math<span class="selector-class">.pow</span>(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>L);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/2025/06/10/%E5%88%86%E5%B8%83%E5%BC%8F/Snowflake/image-20250610224939086.png" alt="image-20250610224939086"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">START_STMP</span> <span class="operator">=</span> <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">SEQUENCE_BIT</span> <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MACHINE_BIT</span> <span class="operator">=</span> <span class="number">5</span>;   <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">DATACENTER_BIT</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_DATACENTER_NUM</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATACENTER_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_MACHINE_NUM</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_SEQUENCE</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MACHINE_LEFT</span> <span class="operator">=</span> SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">DATACENTER_LEFT</span> <span class="operator">=</span> SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">TIMESTMP_LEFT</span> <span class="operator">=</span> DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastStmp</span> <span class="operator">=</span> -<span class="number">1L</span>;<span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowFlake</span><span class="params">(<span class="type">long</span> datacenterId, <span class="type">long</span> machineId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;datacenterId can&#x27;t be greater than MAX_DATACENTER_NUM or less than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;machineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="built_in">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currStmp</span> <span class="operator">=</span> getNewstmp();</span><br><span class="line">        <span class="keyword">if</span> (currStmp &lt; lastStmp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currStmp == lastStmp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currStmp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStmp = currStmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNextMill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">mill</span> <span class="operator">=</span> getNewstmp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastStmp) &#123;</span><br><span class="line">            mill = getNewstmp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNewstmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SnowFlake</span> <span class="variable">snowFlake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnowFlake</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">12</span>); i++) &#123;</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="雪花算法的使用"><a href="#雪花算法的使用" class="headerlink" title="雪花算法的使用"></a>雪花算法的使用</h2><blockquote><p>很明显，简单场景下其实可以直接使用或者直接DB就好了</p><p>但是在企业使用下，就会有不少问题需要考虑</p></blockquote><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><ol><li>机器号的唯一性</li><li>时钟回拨导致id重复</li></ol><h3 id="美团leaf"><a href="#美团leaf" class="headerlink" title="美团leaf"></a>美团leaf</h3><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统 - 美团技术团队</a></p><ol><li>DB + 双buffer（对于基础的DB自增的改进</li><li>Leaf-snowflake( 通过zk去协调workid以及存储时间</li></ol><h4 id="workid回收"><a href="#workid回收" class="headerlink" title="workid回收"></a>workid回收</h4><p>现在的应用很多都是容器化部署了，每次主机的ip都会发生变化，如果在容器化中使用zk来协调workerid那么就会存在workerid很快用完的问题。</p><blockquote><p>可以考虑使用workid池（活跃id以及可用id区分出来）</p></blockquote><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><blockquote><p>简单说就是时间被调整回到了之前的时间，由于雪花算法重度依赖机器的当前时间，所以一旦发生时间回拨，将有可能导致生成的 ID 可能与此前已经生成的某个 ID 重复（前提是刚好在同一毫秒生成 ID 时序列号也刚好一致），这就是雪花算法最经常讨论的问题——时间回拨</p></blockquote><p>现象引发</p><ol><li><p>网络时间校准（还有某些冲浪玩家喜欢修改时区</p></li><li><p>人工设置（上述中枪</p></li><li><p>负闰秒</p></li></ol><h4 id="常见解决办法"><a href="#常见解决办法" class="headerlink" title="常见解决办法"></a>常见解决办法</h4><h5 id="直接抛异常"><a href="#直接抛异常" class="headerlink" title="直接抛异常"></a>直接抛异常</h5><p>还是太简单粗暴了</p><h5 id="延迟等待"><a href="#延迟等待" class="headerlink" title="延迟等待"></a>延迟等待</h5><p>将当前线程进行阻塞一定时间，再获取时间进行大小对比，如果还是小了，再考虑抛异常</p><h3 id="设计时钟序列解决时间回拨问题"><a href="#设计时钟序列解决时间回拨问题" class="headerlink" title="设计时钟序列解决时间回拨问题"></a>设计时钟序列解决时间回拨问题</h3><blockquote><p>通过修改原有 位数方案，通过扩展位解决时间回拨</p></blockquote><p><img src="/2025/06/10/%E5%88%86%E5%B8%83%E5%BC%8F/Snowflake/image-20250610230741182.png" alt="image-20250610230741182"></p><p>将基础的64bit雪花算法进行修改</p><p>扩展出3位的时钟序列</p><blockquote><p>当发生时钟回拨时，那么就将时钟序列自增1位</p><p>如果时钟序列满了，通过等待1ms然后置零</p><p>为了避免重启丢失，时钟序列也需要通过DB&#x2F;文件进行存储</p></blockquote><h3 id="雪花算法，负闰秒问题"><a href="#雪花算法，负闰秒问题" class="headerlink" title="雪花算法，负闰秒问题"></a>雪花算法，负闰秒问题</h3><ul><li><strong>闰秒</strong>是偶尔运用于协调世界时（UTC）的调整，经由增加或减少一秒，以消弥精确的时间（使用原子钟测量）和不精确的观测太阳时（称为UT1)，之间的差异</li><li>这种做法已被证明具有破坏性，特别是在二十一世纪，尤其是在依赖精确时间戳或时间关键程序控制的服务中</li><li>而雪花算法严重依赖时间戳，当出现负闰秒也就是时间减少一秒时（时间往前回拨1秒），雪花Id就可能出现重复，而原生的雪花算法出现时间回拨的处理方式是直接抛异常</li><li>2022年11月，在第27届国际计量大会上，科学家和政府代表投票决定到2035年取消闰秒</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ使用/源码享用</title>
      <link href="/2025/06/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/"/>
      <url>/2025/06/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><blockquote><p>当前笔者使用版本为 RocketMQ 5.3.4-SNAPSHOT</p></blockquote><h2 id="保证顺序消费的四把锁"><a href="#保证顺序消费的四把锁" class="headerlink" title="保证顺序消费的四把锁"></a>保证顺序消费的四把锁</h2><ol><li>分布式锁（保证加入全局分区锁时的并发安全–broker中维护，类比redis</li></ol><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg3OTlhMzIzZTAyYzkzMWZjMjJhZTlkMjQyNjZhODlfaTNaZWZvbjNpTUV3ZlhjVmJRRGhkNGwyb2RUSG5Jd1pfVG9rZW46UWl0ZGJMS3Zyb053emN4eFE2eWNnWW1PbnllXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><ol><li>全局分区锁（key为消费者组名（因为多个topic被多个消费者组订阅），维护队列与单个消费者实例的锁）</li></ol><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDIzNWI2M2JjOWQ4ZDU2MTkzZTY0MjdjYTEyNGUyMTBfNWVvM0hFaDNFeGk1b1gzSkdSOEJwV0JVaExNaEJmVnZfVG9rZW46U0owTWJmeDBEb1hkbUN4UmZ2RGNNWnVxbmxiXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIzZWMyNDYyNjIwNGY2Zjk0NzYyZjAyZmZlMTRkZTdfVWJXclByYXZOSVNGWnREbUpJZHlraDd5MHA1MTV3dzdfVG9rZW46RXo3a2JmaTQ2b1pkaGJ4QmNlVGNXbVczbnZnXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjEzNTFmZWM5NjM2MjY1OWJlNmIxNWJlZTAyMjY2OWZfemE4T0JKWWNUUkdwN0prbnIwRjZuRG52V0RrMm1sU1ZfVG9rZW46QmtxTGJSZkdRb2huSWZ4MTJ5S2NMT2RIbkRkXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><ol><li>Synchronized（保证一个消费者实例只有一个线程拉取消息、消费消息、提交消息）</li></ol><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JhYmY1ZjlkZWNmMjZhNDhlYmQxZjQzYWNkMTA2MDJfTkh0OW0yOTJBMVVtemJqVGpEaTNLanFjT3d6dEg0THRfVG9rZW46S0hRUGJIYmw4b3JOOFl4MW9LSWNhQ1dlbmVjXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><p>让单个实例的一个线程进行校验、拉取消息、消费消息、提交消息</p><ol><li>ReentrantLock（给队列加入一个锁，告诉别人我要进行使用，防止rebalance时队列调度到其他消费者组</li></ol><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=YTVmMDI3MzExZjY0ODk0NzVlYzk3NTU4NjIyOTU5MjRfdllLWXZkUXJDMFoyc1MyazVLRjFHNWpFalFPeWJxSFlfVG9rZW46UXVVamI2VmZMb08xdUd4b0ZpVWN3eVVKbkhoXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><p>可以看到processQueue的setDropped方法就是在重平衡的时候进行的</p><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU4NzA5ZmJlY2ZjNzEwYzc0MGRjNTI5OWJkN2JlMGFfQnAzRzF0WVBMazJsRmdtMFRFdVNEb2RWejZHM1hESVBfVG9rZW46Tks5UmJzUkwwb1d1M3N4T3RVd2NGTkh0bldoXzE3NDk1NDY2NzI6MTc0OTU1MDI3Ml9WNA" alt="img"></p><h2 id="关于Kafka与RocketMQ的重平衡"><a href="#关于Kafka与RocketMQ的重平衡" class="headerlink" title="关于Kafka与RocketMQ的重平衡"></a>关于Kafka与RocketMQ的重平衡</h2><blockquote><p>对于顺序队列来说不会参与重平衡分配</p></blockquote><p>RebalanceImpl&amp;updateMessageQueueAssignment()</p><p><img src="/2025/06/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20250610175031735.png" alt="image-20250610175031735"></p><table><thead><tr><th>维度</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td><strong>触发机制</strong></td><td>实时事件触发（消费者加入&#x2F;离开、心跳失败、订阅变化）</td><td>定时轮询触发（默认 20 秒一次）</td></tr><tr><td><strong>协调机制</strong></td><td>中央协调器（GroupCoordinator）统一调度、Leader 选举</td><td><strong>客户端自我协商</strong>，每个消费者独立发起</td></tr><tr><td><strong>是否暂停消费全组</strong></td><td>整个组暂停消费直到分配完成</td><td><strong>局部影响</strong>，其余消费者继续工作</td></tr><tr><td><strong>分配者角色</strong></td><td>Leader 消费者计算新分配方案</td><td>每个客户端各自执行分配策略</td></tr><tr><td><strong>分配粒度</strong></td><td>Partition 粒度</td><td>MessageQueue 粒度</td></tr><tr><td><strong>稳定性策略（新版）</strong></td><td>支持 Cooperative Sticky（渐进式分配）</td><td>默认是平均分配策略，可自定义</td></tr><tr><td><strong>消费者变动频率容忍性</strong></td><td>容忍性差（高频上下线会频繁 Rebalance）</td><td>容忍性强（轮询机制稳定）</td></tr></tbody></table><h3 id="RocketMQ-重平衡—-RebalanceService"><a href="#RocketMQ-重平衡—-RebalanceService" class="headerlink" title="RocketMQ 重平衡—&gt;RebalanceService"></a>RocketMQ 重平衡—&gt;RebalanceService</h3><p><img src="/2025/06/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20250610172210297.png" alt="image-20250610172210297"></p><h4 id="RebalanceImpl-doReblance"><a href="#RebalanceImpl-doReblance" class="headerlink" title="RebalanceImpl&amp;doReblance"></a>RebalanceImpl&amp;doReblance</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">balanced</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前客户端订阅的所有 Topic</span></span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="built_in">this</span>.getSubscriptionInner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!clientRebalance(topic)) &#123;</span><br><span class="line">                    <span class="comment">// 如果客户端不允许自己重平衡（如顺序消费场景）</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getRebalanceResultFromBroker(topic, isOrder);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        balanced = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通消费场景：客户端自行计算并执行 Rebalance</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        balanced = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;rebalance Exception&quot;</span>, e);</span><br><span class="line">                    balanced = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理掉不再订阅的 Topic 对应的 MessageQueue</span></span><br><span class="line">    <span class="built_in">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> balanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><blockquote><p>有一个Topic 有6个queue&#x2F;partition</p><p>消费者实例A，B</p><p>新加入实例C</p></blockquote><h4 id="Kafka行为"><a href="#Kafka行为" class="headerlink" title="Kafka行为"></a>Kafka行为</h4><ul><li>系统出发Rebalance，暂停所有消费者</li><li>由Leader消费者重新分配分区</li><li>所有消费者接收新分配后再恢复消费</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 所有消费者发送 JoinGroup 请求给 GroupCoordinator（Broker）；</span><br><span class="line">2. GroupCoordinator 选中最先成功响应的消费者 → Group Leader；</span><br><span class="line">3. Leader 收集其他消费者的订阅信息；</span><br><span class="line">4. Leader 调用分配策略（RoundRobin、Range、Sticky 等）；</span><br><span class="line">5. Leader 把结果发回 Broker；</span><br><span class="line">6. Broker 将分配结果下发给所有消费者；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="RocketMQ行为"><a href="#RocketMQ行为" class="headerlink" title="RocketMQ行为"></a>RocketMQ行为</h4><ul><li>每个客户端RebalanceService启动&amp;定时轮询</li><li>发现C加入后，队列局部重新分配</li><li>C接手部分队列，其余消费者照常消费</li></ul><blockquote><p>也就是说可能是A和C进入分配（此时A的定时器刚好触发然后发现C实例加入了）B正常消费不受影响</p></blockquote><p> 总结：<strong>RocketMQ 的 Rebalance 存在天然“延迟生效”机制，新加入的消费者不会立刻就能分配到队列</strong></p><h5 id="时序演示"><a href="#时序演示" class="headerlink" title="时序演示"></a>时序演示</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">时间轴:        T0       T+5s        T+20s       T+21s</span><br><span class="line">           ─────────┬────────────┬────────────┬────────────</span><br><span class="line"></span><br><span class="line">NameServer:        | ←—— 更新消费者列表（注册 C） ——→ |</span><br><span class="line"></span><br><span class="line">A:         Q0 Q1 Q2</span><br><span class="line">                         | ← 感知新成员 C（下一轮 Rebalance）       |</span><br><span class="line">                                    | ←—— 释放 Q2 给 C ——→          |</span><br><span class="line"></span><br><span class="line">B:         Q3 Q4 Q5</span><br><span class="line">                         | （不变）                               |</span><br><span class="line"></span><br><span class="line">C:                 （空转）</span><br><span class="line">                         | ← 初次启动，未分到队列                  |</span><br><span class="line">                                    | ←—— 分配 Q2，开始消费 ——→   |</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCP、RAG初体验以及相关思考</title>
      <link href="/2025/06/07/AI/MCP/"/>
      <url>/2025/06/07/AI/MCP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不同于之前直接使用API调用实现聊天功能</p><p>这里更希望思考以及学习AI应用开发相关原理，以及思考应用前景</p></blockquote><h1 id="AI应用开发体验以及相关思考"><a href="#AI应用开发体验以及相关思考" class="headerlink" title="AI应用开发体验以及相关思考"></a>AI应用开发体验以及相关思考</h1><blockquote><p>首先个人也是了解尚浅，网上资料貌似看上去很丰富，但是实际功能实现感觉完全没有使用大模型的意义</p><p>也许大家发布的博客或者视频内容仅仅只是展示以及入门demo</p></blockquote><h2 id="爬虫服务测试"><a href="#爬虫服务测试" class="headerlink" title="爬虫服务测试"></a>爬虫服务测试</h2><blockquote><p>感觉其实没什么太大问题, 但是中间细节过程发生了什么不得而知<br>可能需要通过Java参数中特定一下 UTF-8的字符集</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrawlerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tool(description = &quot;根据关键词爬取图片资源&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CrawlerFunctionResponse&gt; <span class="title function_">queryConfig</span><span class="params">( CrawlerFunctionRequest request)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;抓取信息 &#123;&#125;&quot;</span>, request.getKeyword());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">page</span> <span class="operator">=</span> request.getPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对关键词进行URL编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedKeyword</span> <span class="operator">=</span> URLEncoder.encode(request.getKeyword(), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;https://cn.bing.com/images/search?q=%s&amp;form=HDRSC3&amp;first=%d&quot;</span>,encodedKeyword,page);</span><br><span class="line">        log.info(<span class="string">&quot;请求URL: &#123;&#125;&quot;</span>, url); <span class="comment">// 添加日志查看编码后的URL</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = Jsoup.connect(url).get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">html</span> <span class="operator">=</span> doc.select(<span class="string">&quot;.iuscp.isv.smallheight&quot;</span>);</span><br><span class="line">        List&lt;CrawlerFunctionResponse&gt; pictures=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> html.select(<span class="string">&quot;.iusc&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line"><span class="comment">//            Element e = html.select(&quot;.iusc&quot;).get(0);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> element.attr(<span class="string">&quot;m&quot;</span>);</span><br><span class="line"><span class="comment">//            System.out.println(select);</span></span><br><span class="line">            Map&lt;String, Object&gt; map = JSONUtil.toBean(m, Map.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">murl</span> <span class="operator">=</span> (String) map.get(<span class="string">&quot;murl&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> (String) map.get(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">            CrawlerFunctionResponse picture=<span class="keyword">new</span> <span class="title class_">CrawlerFunctionResponse</span>();</span><br><span class="line">            picture.setUrl(murl);</span><br><span class="line">            picture.setTitle(title);</span><br><span class="line">            pictures.add(picture);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> pictures;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CrawlerService crawlerService=<span class="keyword">new</span> <span class="title class_">CrawlerService</span>();</span><br><span class="line">        CrawlerFunctionRequest request=<span class="keyword">new</span> <span class="title class_">CrawlerFunctionRequest</span>();</span><br><span class="line">        request.setKeyword(<span class="string">&quot;妃咲&quot;</span>);</span><br><span class="line">        request.setPage(<span class="number">1</span>);</span><br><span class="line">        List&lt;CrawlerFunctionResponse&gt; configs = crawlerService.queryConfig(request);</span><br><span class="line">        System.out.println(configs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/06/07/AI/MCP/image-20250607133513274.png" alt="image-20250607133513274"></p><p>首先本地测试没有毛病，但是在<code>deepseek</code>以及<code>claude</code>进行使用时</p><p><img src="/2025/06/07/AI/MCP/image-20250607133623261.png" alt="image-20250607133623261"></p><p>传入参数很明显有问题，</p><blockquote><p>使用更加常见的关键词</p></blockquote><p><img src="/2025/06/07/AI/MCP/image-20250607040712111.png" alt="image-20250607040712111"></p><p>将编码打印出来</p><blockquote><p>很明显发现Claude使用的keyword转化后的编码不一致</p></blockquote><p><img src="/2025/06/07/AI/MCP/image-20250607041619055.png" alt="image-20250607041619055"></p><h4 id="简单天气补测"><a href="#简单天气补测" class="headerlink" title="简单天气补测"></a>简单天气补测</h4><p><img src="/2025/06/07/AI/MCP/image-20250607165733078.png" alt="image-20250607165733078"></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><blockquote><p>主要是Idea用多了，被惯着</p><p>应该是跟以前使用CLion以及trae同理，直接使用Java命令的话可能传入的参数虽然是中文，但是使用的是本机的GBK字符集</p></blockquote><p><img src="/2025/06/07/AI/MCP/image-20250607165910082.png" alt="image-20250607165910082"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="内部运行过程"><a href="#内部运行过程" class="headerlink" title="内部运行过程"></a>内部运行过程</h3><blockquote><p>可以看到，我们从以前的直接通过前端发送问题，通过接口直接将问题传给大模型</p><p>现在加入MCP Server后，过程更加复杂</p><p>tokens使用也极为庞大！更别说还有伪记忆化功能的存在</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户请求——》前端</span><br><span class="line">前端--》后端（AI Agent部分）</span><br><span class="line">AI Agent——》MCP Server（获取工具集</span><br><span class="line">AI Agent--》将用户问题以及工具说明书给大模型</span><br><span class="line">大模型选择调用哪个工具--》AI Agent</span><br><span class="line">AI Agent 调用工具得到结果--》大模型整理</span><br><span class="line">大模型整理返回结果———》 AI Agent</span><br><span class="line">AI Agent返回结果--》前端展示</span><br></pre></td></tr></table></figure><h2 id="关于Tokens消耗"><a href="#关于Tokens消耗" class="headerlink" title="关于Tokens消耗"></a>关于Tokens消耗</h2><blockquote><p>首先我们知道  大模型几乎都是伪记忆</p><p>将我们的历史对话与当前问题进行拼接，然后发送给大模型</p></blockquote><p>但是这里直接调用API会发现，它并没有带有“记忆功能”</p><p>但如果我们每次都进行历史对话拼接，显然是不合理的，tokens指数级增长，且意义不大（对用户来说</p><p><img src="/2025/06/07/AI/MCP/image-20250607180854152.png" alt="image-20250607180854152"></p><h3 id="Thread-功能"><a href="#Thread-功能" class="headerlink" title="Thread 功能"></a>Thread 功能</h3><p>Overview: OpenAI Assistants API 概览</p><p><a href="https://platform.openai.com/docs/assistants/overview">https://platform.openai.com/docs/assistants/overview</a></p><p> 使用 Thread + Run 模式</p><ol><li>创建一个 Thread（一次性操作）</li><li>每次添加新的用户消息，例如：你叫什么？</li><li>调用 <code>run</code>，OpenAI <strong>自动从之前 Thread 的消息中构建上下文</strong></li><li>系统会在后台使用裁剪、摘要、缓存等机制压缩内容</li></ol><p>不再需要每次都发整段历史，<strong>只发新的一句话，OpenAI 来补全上下文</strong>。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好啊！&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好！&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你叫什么？&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不过像是高德地图开发出来的MCP Server去让AI给我们做出旅游攻略，确实降低使用成本的话，可以极大方便我们日常生活去小红书、抖音等软件找资料</p><p>更有Google 发布的 g-mcp-server，有则能够绕过反爬虫机制的并发搜索功能，可以很好解决大模型数据资料时效性的问题，以及在搜索引擎使用较少的人来说，或者自己搜索有可能会染上网站风险，有极大利处</p><p>因此我觉得未来需要思考的便是落地方向以及成本问题。</p><p>当前的机制对于Tokens花销来说，个人开发者难以承受，若是企业接入，强如Claude接入MCP后，免费对话次数寥寥可数，更别说付费的cursor了。</p><p>如果是免费开放给用户使用，得考虑如何盈利，当然这些都是后话。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写动态线程池</title>
      <link href="/2025/05/01/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/%E6%89%8B%E5%86%99%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/05/01/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/%E6%89%8B%E5%86%99%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="手写动态线程池"><a href="#手写动态线程池" class="headerlink" title="手写动态线程池"></a>手写动态线程池</h1><h2 id="引入SPI机制"><a href="#引入SPI机制" class="headerlink" title="引入SPI机制"></a>引入SPI机制</h2><h2 id="添加预警以及参数校验"><a href="#添加预警以及参数校验" class="headerlink" title="添加预警以及参数校验"></a>添加预警以及参数校验</h2>]]></content>
      
      
      <categories>
          
          <category> 轮子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 实现 Raft一致性算法</title>
      <link href="/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/"/>
      <url>/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/</url>
      
        <content type="html"><![CDATA[<h1 id="动手写一个简单-Raft"><a href="#动手写一个简单-Raft" class="headerlink" title="动手写一个简单 Raft"></a>动手写一个简单 Raft</h1><p><strong>项目代码： <a href="https://github.com/moying688/moying-raft">moying688&#x2F;moying-raft: 使用 Go 实现一个简单的 Raft 一致性算法</a></strong></p><p>简介： 这里会使用 Go简单实现一个 Raft 一致性算法，使用Go库的RPC实现</p><p>后续可能考虑加入Etcd作为注册中心以及使用gRPC进行结点间通信（画饼doge.jpg）</p><blockquote><p>不知道为什么，明明编码集是UTF-8</p><p>且终端Active code page: 65001<br>但是打印中文还是乱码</p><p>因此该 项目 所有的打印日志等全用英文撰写，但是中文注释</p></blockquote><p>画饼：后续可能会把 我的 Raft 笔记也写上，然后还有 RPC 和 动态线程池的轮子（还没建文件夹呢）</p><hr><p><strong>Tips： 有时候可能会出现奇奇怪怪的Bug</strong></p><p><strong>但是我可能解决过程中，一步步测试，有时候没来得及粘贴或者忘记记录了</strong></p><p><strong>所以每一步完结后，我会提交代码到 Github中（基本上是测试好的，如果还有bug，可能是后续要优化的点，也可能是确确实实写的时候没有考虑到这个问题，因为我Go语言也刚刚入门，算是边学边写了）</strong></p><hr><h1 id="第一步：搭建初版结构"><a href="#第一步：搭建初版结构" class="headerlink" title="第一步：搭建初版结构"></a>第一步：搭建初版结构</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">raft/</span><br><span class="line">├── <span class="keyword">go</span>.mod</span><br><span class="line">├── <span class="keyword">go</span>.sum</span><br><span class="line">├── cmd/</span><br><span class="line">│   └── server/</span><br><span class="line">│       └── main.<span class="keyword">go</span> 服务入口，启动一个 Raft 节点。</span><br><span class="line">├── internal/</span><br><span class="line">│   └── raft/</span><br><span class="line">│       ├── raft.<span class="keyword">go</span> 定义 Raft 核心结构体、基本状态。</span><br><span class="line">│       ├── rpc.<span class="keyword">go</span> 定义 RPC 接口，例如 RequestVote、AppendEntries。</span><br><span class="line">│       └── config.<span class="keyword">go</span> 配置相关（比如端口、ID之类的简单设置）。</span><br><span class="line">├── scripts/</span><br><span class="line">│   └── Procfile 给 goreman 启动多个节点用。</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写-main-go"><a href="#编写-main-go" class="headerlink" title="编写 main.go"></a>编写 main.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;raft/internal/raft&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">len</span>(os.Args)!=<span class="number">3</span>)&#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Not enough arguments&quot;</span>)</span><br><span class="line">log.Fatalf(<span class="string">&quot;usage: server &lt;id&gt; &lt;port&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析参数</span></span><br><span class="line">id, err := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;invalid id: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">port := os.Args[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">r := raft.NewRaft(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册RPC服务</span></span><br><span class="line">rpc.Register(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:&quot;</span>+port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Server %d listening on port %s\n&quot;</span>, id, port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受连接并处理</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Println(<span class="string">&quot;Error accepting connection:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rpc.ServeConn(conn) <span class="comment">// 服务连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义结点结构以及日志Entry"><a href="#定义结点结构以及日志Entry" class="headerlink" title="定义结点结构以及日志Entry"></a>定义结点结构以及日志Entry</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower State = <span class="literal">iota</span></span><br><span class="line">Candidate</span><br><span class="line">Leader</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span>&#123;</span><br><span class="line">Term <span class="type">int</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span>&#123;</span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁，用于保护共享资源的访问</span></span><br><span class="line">id <span class="type">int</span> <span class="comment">// 节点的唯一标识符</span></span><br><span class="line">state State <span class="comment">// 当前节点的状态</span></span><br><span class="line">currentTerm <span class="type">int</span> <span class="comment">// 当前任期号</span></span><br><span class="line">votedFor <span class="type">int</span> <span class="comment">// 为哪个节点投票</span></span><br><span class="line">log []LogEntry <span class="comment">// 日志条目</span></span><br><span class="line"><span class="comment">// todo 后续添加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(id <span class="type">int</span>)</span></span> *Raft &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Raft&#123;</span><br><span class="line">        id:    id,</span><br><span class="line">        state: Follower,</span><br><span class="line">        votedFor: <span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="投票参数-基础投票机制"><a href="#投票参数-基础投票机制" class="headerlink" title="投票参数 基础投票机制"></a>投票参数 基础投票机制</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  raft </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span>&#123;</span><br><span class="line">Term <span class="type">int</span> <span class="comment">// 候选人的任期号</span></span><br><span class="line">CandidateId <span class="type">int</span> <span class="comment">// 候选人的ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span>&#123;</span><br><span class="line">Term <span class="type">int</span> <span class="comment">// 当前任期号，以便候选人更新自己的任期号</span></span><br><span class="line">VoteGranted <span class="type">bool</span> <span class="comment">// true 表示候选人收到了投票</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *ReqeuestVoteReply)<span class="type">error</span>&#123;</span><br><span class="line">r.mu.Lock() <span class="comment">// 加锁，保护共享资源的访问</span></span><br><span class="line"><span class="keyword">defer</span> r.mu.Unlock() <span class="comment">// 函数结束时解锁，确保资源被正确释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; r.currentTerm&#123; <span class="comment">// 如果候选人的任期号小于当前任期号，拒绝投票</span></span><br><span class="line">reply.Term = r.currentTerm</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 后续补充更多投票逻辑</span></span><br><span class="line"></span><br><span class="line">reply.VoteGranted = <span class="literal">true</span> <span class="comment">// 候选人收到了投票</span></span><br><span class="line">reply.Term = args.Term <span class="comment">// 更新任期号</span></span><br><span class="line">r.votedFor = args.CandidateId <span class="comment">// 记录为哪个节点投票</span></span><br><span class="line">    <span class="comment">// 打印谁给哪个候选人投票</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d voted for candidate %d in term %d\n&quot;</span>, r.id, args.CandidateId, args.Term)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goreman-配置文件"><a href="#goreman-配置文件" class="headerlink" title="goreman 配置文件"></a>goreman 配置文件</h2><blockquote><p>这里先简答使用goreman启动多个结点实例</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server1: <span class="keyword">go</span> run cmd/server/main.<span class="keyword">go</span> <span class="number">1</span> <span class="number">8001</span></span><br><span class="line">server2: <span class="keyword">go</span> run cmd/server/main.<span class="keyword">go</span> <span class="number">2</span> <span class="number">8002</span></span><br><span class="line">server3: <span class="keyword">go</span> run cmd/server/main.<span class="keyword">go</span> <span class="number">3</span> <span class="number">8003</span></span><br><span class="line">server4: <span class="keyword">go</span> run cmd/server/main.<span class="keyword">go</span> <span class="number">4</span> <span class="number">8004</span></span><br><span class="line">server5: <span class="keyword">go</span> run cmd/server/main.<span class="keyword">go</span> <span class="number">5</span> <span class="number">8005</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 终端启动命令</span><br><span class="line">goreman -f scripts/Procfile start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/image-20250426165023919.png" alt="image-20250426165023919"></p><h1 id="初版核心功能编写"><a href="#初版核心功能编写" class="headerlink" title="初版核心功能编写"></a>初版核心功能编写</h1><h2 id="1-结点通信"><a href="#1-结点通信" class="headerlink" title="1.结点通信"></a>1.结点通信</h2><h3 id="修改结构体"><a href="#修改结构体" class="headerlink" title="修改结构体"></a>修改结构体</h3><p>加入peers字段，记录结点信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span>&#123;</span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁，用于保护共享资源的访问</span></span><br><span class="line">id <span class="type">int</span> <span class="comment">// 节点的唯一标识符</span></span><br><span class="line">state State <span class="comment">// 当前节点的状态</span></span><br><span class="line">currentTerm <span class="type">int</span> <span class="comment">// 当前任期号</span></span><br><span class="line">votedFor <span class="type">int</span> <span class="comment">// 为哪个节点投票</span></span><br><span class="line">log []LogEntry <span class="comment">// 日志条目</span></span><br><span class="line"><span class="comment">// todo 后续添加</span></span><br><span class="line"></span><br><span class="line">peers[]<span class="type">string</span> <span class="comment">// 集群中的其他节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时创建新结点也更改一下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(id <span class="type">int</span>, peers []<span class="type">string</span>)</span></span> *Raft &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Raft&#123;</span><br><span class="line">        id:    id,</span><br><span class="line">        state: Follower,</span><br><span class="line">        votedFor: <span class="number">-1</span>,</span><br><span class="line">        peers: peers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-超时选举机制"><a href="#2-超时选举机制" class="headerlink" title="2.超时选举机制"></a>2.超时选举机制</h2><h3 id="选举定时器"><a href="#选举定时器" class="headerlink" title="选举定时器"></a>选举定时器</h3><blockquote><p>添加 超时时间字段以及超时事件 以及初始化</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span>&#123;</span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁，用于保护共享资源的访问</span></span><br><span class="line">id <span class="type">int</span> <span class="comment">// 节点的唯一标识符</span></span><br><span class="line">state State <span class="comment">// 当前节点的状态</span></span><br><span class="line">currentTerm <span class="type">int</span> <span class="comment">// 当前任期号</span></span><br><span class="line">votedFor <span class="type">int</span> <span class="comment">// 为哪个节点投票</span></span><br><span class="line">log []LogEntry <span class="comment">// 日志条目</span></span><br><span class="line"><span class="comment">// todo 后续添加</span></span><br><span class="line"></span><br><span class="line">peers[]<span class="type">string</span> <span class="comment">// 集群中的其他节点</span></span><br><span class="line">electionTimeout time.Duration <span class="comment">// 选举超时时间</span></span><br><span class="line">electionResetEvent <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 选举超时事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(id <span class="type">int</span>,peers[]<span class="type">string</span>)</span></span> *Raft &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Raft&#123;</span><br><span class="line">        id:    id,</span><br><span class="line">        state: Follower,</span><br><span class="line">        votedFor: <span class="number">-1</span>,</span><br><span class="line">peers: peers,</span><br><span class="line">electionTimeout: randomElectionTimeout(), <span class="comment">// 随机 150ms-300ms</span></span><br><span class="line">electionResetEvent: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomElectionTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line">    <span class="keyword">return</span> time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">150</span>)) * time.Millisecond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="time源码番外"><a href="#time源码番外" class="headerlink" title="time源码番外"></a>time源码番外</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Timer type represents a single event.</span></span><br><span class="line"><span class="comment">// When the Timer expires, the current time will be sent on C,</span></span><br><span class="line"><span class="comment">// unless the Timer was created by AfterFunc.</span></span><br><span class="line"><span class="comment">// A Timer must be created with NewTimer or AfterFunc.</span></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">C &lt;-<span class="keyword">chan</span> Time <span class="comment">// 当 Timer 过期时，当前时间将发送到 C 通道</span></span><br><span class="line">r runtimeTimer    <span class="comment">// 运行时定时器</span></span><br><span class="line">&#125;</span><br><span class="line">因此我们使用 通道判断 是否超时</span><br><span class="line">通过<span class="keyword">select</span> 进行阻塞</span><br></pre></td></tr></table></figure><ol><li><strong>启动超时选举检测</strong></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> startElectionTimer() &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">          timeout := r.electionTimeout    <span class="comment">// 随机超时时间</span></span><br><span class="line">          timer := time.NewTimer(timeout) <span class="comment">// 创建一个新的定时器</span></span><br><span class="line">          <span class="keyword">select</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> &lt;-timer.C: <span class="comment">// time 通道 详情</span></span><br><span class="line">             r.startElection() <span class="comment">// 超时 进入选举</span></span><br><span class="line">          <span class="keyword">case</span> &lt;-r.electionResetEvent:</span><br><span class="line">             <span class="comment">// 收到重置事件，停止定时器</span></span><br><span class="line">             timer.Stop()</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">electionResetEvent 是一个控制信号，不是计时器本身，</span><br><span class="line">它是用来通知 Timer“停止重新来一遍”的！</span><br><span class="line"></span><br><span class="line">也就是说，重置 electionResetEvent，并不会直接改变 timer，</span><br><span class="line">而是通过通知，停止当前timer，重新启动一个新的timer。</span><br></pre></td></tr></table></figure><ol start="2"><li>修改创建结点实例</li></ol><blockquote><p>创建新结点直接启动定时器</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(id <span class="type">int</span>, peers []<span class="type">string</span>)</span></span> *Raft &#123;</span><br><span class="line">r := &amp;Raft&#123;</span><br><span class="line">id:                 id,</span><br><span class="line">state:              Follower,</span><br><span class="line">votedFor:           <span class="number">-1</span>,</span><br><span class="line">peers:              peers,</span><br><span class="line">electionTimeout:    randomElectionTimeout(), <span class="comment">// 随机 150ms-300ms</span></span><br><span class="line">electionResetEvent: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">r.startElectionTimer() <span class="comment">// 启动选举定时器</span></span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h3><blockquote><p>先写一个基本的发起选举请求，超过n&#x2F;2票数即可成为 Leader</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// startElection 启动选举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> startElection() &#123;</span><br><span class="line">r.mu.Lock()</span><br><span class="line">r.state = Candidate</span><br><span class="line">r.currentTerm += <span class="number">1</span> <span class="comment">// 增加当前任期号</span></span><br><span class="line">r.votedFor = r.id <span class="comment">// 投票给自己</span></span><br><span class="line">r.mu.Unlock()</span><br><span class="line"></span><br><span class="line">votes := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex <span class="comment">// 保护 votes 变量的并发访问</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 等待所有投票请求完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, peer := <span class="keyword">range</span> r.peers &#123;</span><br><span class="line"><span class="keyword">if</span> i == r.id &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 不给自己投票</span></span><br><span class="line">&#125; </span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加等待组计数器</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">args := &amp;RequestVoteArgs&#123; <span class="comment">// 请求投票参数</span></span><br><span class="line">Term: r.currentTerm,</span><br><span class="line">CandidateId: r.id,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line"><span class="keyword">if</span> Call(peer, <span class="string">&quot;Raft.RequestVote&quot;</span>, args, &amp;reply) &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123; <span class="comment">// 如果投票成功</span></span><br><span class="line">votes++</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;(peer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 等待所有投票请求完成</span></span><br><span class="line"></span><br><span class="line">r.mu.Lock()</span><br><span class="line"><span class="comment">// 如果当前状态是候选人，并且获得了超过半数的投票</span></span><br><span class="line"><span class="keyword">if</span> r.state == Candidate &amp;&amp; votes &gt; <span class="built_in">len</span>(r.peers)/<span class="number">2</span> &#123; </span><br><span class="line">r.state = Leader</span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d becomes Leader for term %d\n&quot;</span>, r.id, r.currentTerm)</span><br><span class="line">&#125;</span><br><span class="line">r.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h3><blockquote><p>在rpc.go 中进行加入</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line">使用标准库中的RPC</span><br></pre></td></tr></table></figure><p>实现一个基本的RPC通信, 暂不处理返回结果以及重试机制</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 发送 RPC 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">(addr <span class="type">string</span>, method <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// 创建一个 TCP 客户端连接</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(client *rpc.Client)</span></span> &#123;</span><br><span class="line">err := client.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理关闭连接时的错误</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(client) <span class="comment">// 确保在函数结束时关闭连接</span></span><br><span class="line"></span><br><span class="line">call := client.Go(method, args, reply, <span class="literal">nil</span>) <span class="comment">// 异步调用 RPC 方法</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-call.Done:</span><br><span class="line">fmt.Println(<span class="string">&quot;RPC call completed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> call.Error == <span class="literal">nil</span> <span class="comment">// 返回调用结果</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):</span><br><span class="line"><span class="comment">// 超时处理</span></span><br><span class="line">fmt.Println(<span class="string">&quot;RPC call timed out&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选举测试"><a href="#选举测试" class="headerlink" title="选举测试"></a>选举测试</h3><p>我们先将结点地址写死, 后续考虑使用配置文件或者注册中心</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">// 随机超时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">3</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;usage: server &lt;id&gt; &lt;port&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id, err := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;invalid id: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">port := os.Args[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">peers := []<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;localhost:8001&quot;</span>,</span><br><span class="line"><span class="string">&quot;localhost:8002&quot;</span>,</span><br><span class="line"><span class="string">&quot;localhost:8003&quot;</span>,</span><br><span class="line"><span class="string">&quot;localhost:8004&quot;</span>,</span><br><span class="line"><span class="string">&quot;localhost:8005&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := raft.NewRaft(id<span class="number">-1</span>, peers) <span class="comment">// 创建 Raft 实例</span></span><br><span class="line"></span><br><span class="line">rpc.Register(r) <span class="comment">// 注册 RPC 服务</span></span><br><span class="line"></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:&quot;</span>+port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;listen error: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Server %d listening on port %s\n&quot;</span>, id, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 接受连接</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;accept error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rpc.ServeConn(conn) <span class="comment">// 处理连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后启动 goreman</p><p>然后可以发现，一直进入选举！我勒个乖乖</p><h4 id="考验Ctrl-C手速？？"><a href="#考验Ctrl-C手速？？" class="headerlink" title="考验Ctrl + C手速？？"></a>考验Ctrl + C手速？？</h4><p><img src="/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/image-20250426174548571.png" alt="image-20250426174548571"></p><p>我勒个逗啊，无限选举下去了吗，哈基影，你这家伙。</p><p>因此我们需要选举Leader后，给Follower们发送信息，让他们重置计时器</p><h2 id="3-初代心跳检测-续费"><a href="#3-初代心跳检测-续费" class="headerlink" title="3.初代心跳检测&amp;&amp;续费"></a>3.初代心跳检测&amp;&amp;续费</h2><h4 id="构建心跳-日志-请求参数以及回复参数"><a href="#构建心跳-日志-请求参数以及回复参数" class="headerlink" title="构建心跳&#x2F;日志 请求参数以及回复参数"></a>构建心跳&#x2F;日志 请求参数以及回复参数</h4><blockquote><p>在rpc.go 中加入</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppendEntriesArgs 心跳/日志同步 参数</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term     <span class="type">int</span> <span class="comment">// 领导者的任期号</span></span><br><span class="line">LeaderId <span class="type">int</span> <span class="comment">// 领导者的ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppendEntriesReply 心跳/日志同步 回复</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="初代心跳-日志发送方法"><a href="#初代心跳-日志发送方法" class="headerlink" title="初代心跳&#x2F;日志发送方法"></a>初代心跳&#x2F;日志发送方法</h4><blockquote><p> 在rpc.go 中加入</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AppendEntries RPC方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) <span class="type">error</span> &#123;</span><br><span class="line">r.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果收到的任期号小于当前任期号，拒绝</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; r.currentTerm &#123;</span><br><span class="line">reply.Term = r.currentTerm</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到心跳后重置选举超时 (老Leader恢复过来后，收到新Leader就得立刻变回Follower)</span></span><br><span class="line">r.currentTerm = args.Term</span><br><span class="line">r.state = Follower <span class="comment">// 更新状态为跟随者</span></span><br><span class="line">r.votedFor = <span class="number">-1</span>    <span class="comment">// 重置投票状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞重置选举超时</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r.electionResetEvent &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">        <span class="comment">// 重置选举超时</span></span><br><span class="line">r.electionTimeout = time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">150</span>)) * time.Millisecond</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.Term = r.currentTerm</span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d received heartbeat from leader %d in term %d\n&quot;</span>, r.id, args.LeaderId, args.Term)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Leader定时发送"><a href="#Leader定时发送" class="headerlink" title="Leader定时发送"></a>Leader定时发送</h4><blockquote><p>先实现定时发送 心跳给 Follower</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// startHeartbeatTimer 启动心跳定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r* Raft)</span></span> startHeartbeatTimer()&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 之前我们写的超时时间是 150ms ~ 300ms ，因此心跳发送的频率应该更高</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">50</span> * time.Millisecond)<span class="comment">// 每 50ms 发送一次心跳</span></span><br><span class="line"><span class="keyword">defer</span> ticker.Stop() <span class="comment">// 确保在函数结束时停止定时器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-ticker.C</span><br><span class="line">r.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> r.state != Leader &#123; <span class="comment">// 如果当前不是领导者，停止发送心跳</span></span><br><span class="line">r.mu.Unlock() </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r.mu.Unlock() <span class="comment">// 释放锁，允许其他操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,peer := <span class="keyword">range</span> r.peers&#123;</span><br><span class="line"><span class="keyword">if</span> i == r.id&#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 不给自己发送心跳</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:    r.currentTerm,</span><br><span class="line">LeaderId: r.id,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line">Call(peer, <span class="string">&quot;Raft.AppendEntries&quot;</span>, args, &amp;reply) <span class="comment">// 发送心跳</span></span><br><span class="line">&#125;(peer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>选举后完成后启动心跳定时器</p></blockquote><p>在我们之前写的 raft.go 中<code>startElection()</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前状态是候选人，并且获得了超过半数的投票</span></span><br><span class="line"><span class="keyword">if</span> r.state == Candidate &amp;&amp; votes &gt; <span class="built_in">len</span>(r.peers)/<span class="number">2</span> &#123;</span><br><span class="line">r.state = Leader</span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d becomes Leader for term %d\n&quot;</span>, r.id, r.currentTerm)</span><br><span class="line"><span class="comment">// 启动心跳定时器 &lt;---- 加入这一行</span></span><br><span class="line">r.startHeartbeatTimer() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结当前基础板中核心问题"><a href="#4-总结当前基础板中核心问题" class="headerlink" title="4.总结当前基础板中核心问题"></a>4.总结当前基础板中核心问题</h2><ol><li>初期会出现 3号结点已经变成Leader了，但是打印中还是有别人进行选举</li><li>3号结点成为Leader后，还是会一直不断选举</li><li>一个结点在一个Term内只能投一票，并且不能随便改变自己的Term</li></ol><p>启动后很明显发现，由于我们在投票逻辑极为简单，只是判断任期大小即可投票</p><p>后续一直为3结点只是因为他先选举出来，后续通过心跳先将其他结点变为了Follower，但是在此之前，已经出现了多个Leader！！！这是完全无法容忍了（甚至不是因为网络分区、宕机等等造成的</p><p>且Leader没有处理他的 超时选举定时器</p><p><img src="/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/image-20250426181425825.png" alt="image-20250426181425825"></p><h4 id="修改点1：-成为Leader后，停止选举定时器"><a href="#修改点1：-成为Leader后，停止选举定时器" class="headerlink" title="修改点1： 成为Leader后，停止选举定时器"></a>修改点1： 成为Leader后，停止选举定时器</h4><p>在Raft结构体中加一个electionTimer字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">electionTimer *time.Timer <span class="comment">// 选举定时器</span></span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">electionTimer:      time.NewTimer(randomElectionTimeout()),</span><br></pre></td></tr></table></figure><p>在原来的<code>startElectionTimer()</code> 里，把原来的new Timer逻辑改为</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startElection 启动选举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> startElectionTimer() &#123;</span><br><span class="line"><span class="comment">// 启动一个新的 goroutine 来处理选举超时</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//timeout := r.electionTimeout    // 随机超时时间</span></span><br><span class="line"><span class="comment">//timer := time.NewTimer(timeout) // 创建一个新的定时器</span></span><br><span class="line">r.electionTimer = time.NewTimer(randomElectionTimeout())</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-r.electionTimer.C: <span class="comment">// time 通道 详情</span></span><br><span class="line">r.startElection() <span class="comment">// 超时 进入选举</span></span><br><span class="line"><span class="keyword">case</span> &lt;-r.electionResetEvent:</span><br><span class="line"><span class="comment">// 收到重置事件，停止定时器</span></span><br><span class="line">r.electionTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在选举函数中更改：加入关闭自己的定时器</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.mu.Lock()</span><br><span class="line"><span class="comment">// 如果当前状态是候选人，并且获得了超过半数的投票</span></span><br><span class="line"><span class="keyword">if</span> r.state == Candidate &amp;&amp; votes &gt; <span class="built_in">len</span>(r.peers)/<span class="number">2</span> &#123;</span><br><span class="line">r.state = Leader</span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d becomes Leader for term %d\n&quot;</span>, r.id, r.currentTerm)</span><br><span class="line"><span class="comment">// 启动心跳定时器</span></span><br><span class="line">r.startHeartbeatTimer()</span><br><span class="line"><span class="comment">// 关闭自己的选举定时器</span></span><br><span class="line">r.electionTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line">r.mu.Unlock()</span><br></pre></td></tr></table></figure><h5 id="修改RequestVote"><a href="#修改RequestVote" class="headerlink" title="修改RequestVote"></a>修改RequestVote</h5><blockquote><p>一个人只能在 一轮Term中投一票，除非有更新一轮的Term</p><p>因此加入判断 args.Term &gt; r.currentTerm 是否是更新一轮选举</p><p>r.votedFor &#x3D;&#x3D; -1 || r.votedFor &#x3D;&#x3D; args.CandidateId 避免多票</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  RequestVote RPC方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) <span class="type">error</span> &#123;</span><br><span class="line">r.mu.Lock()         <span class="comment">// 加锁，保护共享资源的访问</span></span><br><span class="line"><span class="keyword">defer</span> r.mu.Unlock() <span class="comment">// 函数结束时解锁，确保资源被正确释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; r.currentTerm &#123; <span class="comment">// 如果候选人的任期号小于当前任期号，拒绝投票</span></span><br><span class="line">reply.Term = r.currentTerm</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 后续补充更多投票逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; r.currentTerm &#123;</span><br><span class="line">r.currentTerm = args.Term</span><br><span class="line">r.state = Follower <span class="comment">// 更新状态为跟随者</span></span><br><span class="line">r.votedFor = <span class="number">-1</span>    <span class="comment">// 重置投票状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r.votedFor == <span class="number">-1</span> || r.votedFor == args.CandidateId &#123;</span><br><span class="line">r.votedFor = args.CandidateId <span class="comment">// 投票给候选人</span></span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 打印谁给哪个候选人投票</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d voted for candidate %d in term %d\n&quot;</span>, r.id, args.CandidateId, args.Term)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到投票请求，重置选举超时</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r.electionResetEvent &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span> <span class="comment">// 拒绝投票</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Term = r.currentTerm <span class="comment">// 返回当前任期号</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Leader关闭定时器"><a href="#Leader关闭定时器" class="headerlink" title="Leader关闭定时器"></a>Leader关闭定时器</h5><p>Raft 结构体中 加入一个专门的字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">killElectionTimer <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 一个字，杀！</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化中加入</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">killElectionTimer: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>改造 startElectionTimer 循环，收到kill 时退出</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> startElectionTimer() &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            timeout := r.electionTimeout</span><br><span class="line">            timer := time.NewTimer(timeout)</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                r.startElection()</span><br><span class="line">            <span class="keyword">case</span> &lt;-r.electionResetEvent:</span><br><span class="line">                timer.Stop()</span><br><span class="line">            <span class="keyword">case</span> &lt;-r.killElectionTimer:</span><br><span class="line">                timer.Stop()</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// 彻底退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>更改选举函数</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.mu.Lock()</span><br><span class="line"><span class="comment">// 如果当前状态是候选人，并且获得了超过半数的投票</span></span><br><span class="line"><span class="keyword">if</span> r.state == Candidate &amp;&amp; votes &gt; <span class="built_in">len</span>(r.peers)/<span class="number">2</span> &#123;</span><br><span class="line">r.state = Leader</span><br><span class="line">fmt.Printf(<span class="string">&quot;Node %d becomes Leader for term %d\n&quot;</span>, r.id, r.currentTerm)</span><br><span class="line"><span class="comment">// 启动心跳定时器</span></span><br><span class="line">r.startHeartbeatTimer()</span><br><span class="line"><span class="comment">// 关闭自己的选举定时器</span></span><br><span class="line"><span class="built_in">close</span>(r.killElectionTimer)</span><br><span class="line"><span class="comment">//r.electionTimer.Stop()</span></span><br><span class="line">&#125;</span><br><span class="line">r.mu.Unlock()</span><br></pre></td></tr></table></figure><h3 id="修改点2：选举时严格一致性"><a href="#修改点2：选举时严格一致性" class="headerlink" title="修改点2：选举时严格一致性"></a>修改点2：选举时严格一致性</h3><h4 id="调整超时时间"><a href="#调整超时时间" class="headerlink" title="调整超时时间"></a>调整超时时间</h4><blockquote><p>这里调大一点</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomElectionTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line"><span class="keyword">return</span> time.Duration(<span class="number">300</span>+rand.Intn(<span class="number">200</span>)) * time.Millisecond</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送心跳修改"><a href="#发送心跳修改" class="headerlink" title="发送心跳修改"></a>发送心跳修改</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppendEntries RPC方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) <span class="type">error</span> &#123;</span><br><span class="line">    r.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果收到的任期号小于当前任期号，拒绝</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; r.currentTerm &#123;</span><br><span class="line">       reply.Term = r.currentTerm</span><br><span class="line">       reply.Success = <span class="literal">false</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; r.currentTerm &#123;</span><br><span class="line">       r.currentTerm = args.Term</span><br><span class="line">       r.state = Follower <span class="comment">// 更新状态为跟随者</span></span><br><span class="line">       r.votedFor = <span class="number">-1</span>    <span class="comment">// 重置投票状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 收到心跳后重置选举超时 (老Leader恢复过来后，收到新Leader就得立刻变回Follower)</span></span><br><span class="line">    <span class="comment">//r.currentTerm = args.Term</span></span><br><span class="line">    <span class="comment">//r.state = Follower // 更新状态为跟随者</span></span><br><span class="line">    <span class="comment">//r.votedFor = -1    // 重置投票状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞重置选举超时</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r.electionResetEvent &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">       <span class="comment">// 重置选举超时</span></span><br><span class="line">       <span class="comment">//r.electionTimeout = time.Duration(150+rand.Intn(150)) * time.Millisecond</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    reply.Term = r.currentTerm</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Node %d received heartbeat from leader %d in term %d\n&quot;</span>, r.id, args.LeaderId, args.Term)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS D:\nice_tool\raft&gt; goreman -f scripts/Procfile start</span><br><span class="line">23:47:50 server2 | Starting server2 on port 5100</span><br><span class="line">23:47:50 server1 | Starting server1 on port 5000</span><br><span class="line">23:47:50 server4 | Starting server4 on port 5300</span><br><span class="line">23:47:50 server5 | Starting server5 on port 5400</span><br><span class="line">23:47:50 server3 | Starting server3 on port 5200</span><br><span class="line">23:47:52 server1 | Server 1 listening on port 8001</span><br><span class="line">23:47:52 server3 | Server 3 listening on port 8003</span><br><span class="line">23:47:53 server1 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server2 | Server 2 listening on port 8002</span><br><span class="line">23:47:53 server5 | Server 5 listening on port 8005</span><br><span class="line">23:47:53 server4 | Server 4 listening on port 8004</span><br><span class="line">23:47:53 server5 | RPC call completed</span><br><span class="line">23:47:53 server5 | RPC call completed</span><br><span class="line">23:47:53 server5 | RPC call completed</span><br><span class="line">23:47:53 server5 | RPC call completed</span><br><span class="line">23:47:53 server4 | Node 3 voted <span class="keyword">for</span> candidate 4 <span class="keyword">in</span> term 1</span><br><span class="line">23:47:53 server2 | RPC call completed</span><br><span class="line">23:47:53 server2 | RPC call completed</span><br><span class="line">23:47:53 server2 | RPC call completed</span><br><span class="line">23:47:53 server2 | RPC call completed</span><br><span class="line">23:47:53 server4 | Node 3 voted <span class="keyword">for</span> candidate 0 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server5 | Node 4 voted <span class="keyword">for</span> candidate 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server2 | Node 1 voted <span class="keyword">for</span> candidate 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server1 | RPC call completed</span><br><span class="line">23:47:53 server1 | RPC call completed</span><br><span class="line">23:47:53 server1 | RPC call completed</span><br><span class="line">23:47:53 server1 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | Node 2 becomes Leader <span class="keyword">for</span> term 2</span><br><span class="line">23:47:53 server4 | Node 3 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server5 | Node 4 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server1 | Node 0 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server2 | Node 1 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server2 | Node 1 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server4 | Node 3 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server1 | Node 0 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server5 | Node 4 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server2 | Node 1 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server4 | Node 3 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server5 | Node 4 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server1 | Node 0 received heartbeat from leader 2 <span class="keyword">in</span> term 2</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line">23:47:53 server3 | RPC call completed</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>目前我们就是，启动五个 Raft服务，然后各自启动自己的选举计时器</p><p>当超时的时候，Term变为1，然后发起选举，失败后，重置计时器，此时其他的结点超时Term变为1，但是此时他们只能捡漏第一个结点没有拿到的票，</p><p>如果都失败了，再次等待超时进入第二轮直到有新的Leader</p><p>然后发送心跳间隔远远小于超时时间，Leader通知重置Follower的计时器</p></blockquote><p>提交代码吧、可以在写之前先新建一个本地分支，后续再更新到master分支中</p><p><img src="/2025/04/27/%E8%BD%AE%E5%AD%90_%E7%8E%A9%E5%85%B7/README/image-20250427001405192.png" alt="image-20250427001405192"></p><h1 id="第二步：-实现日志复制"><a href="#第二步：-实现日志复制" class="headerlink" title="第二步： 实现日志复制"></a>第二步： 实现日志复制</h1><p>实现日志复制（带有LogEntry 的AppendEntries）</p><p>让Leader</p><ul><li>把收到的Client Command 存入到日志</li><li>然后使用 AppendEntries 把日志同步到Follower</li><li>Follower 正确跟随 Leader日志</li><li>Leader apply日志，Follower apply日志</li></ul><h2 id="初版：最小可以run起来的日志同步"><a href="#初版：最小可以run起来的日志同步" class="headerlink" title="初版：最小可以run起来的日志同步"></a>初版：最小可以run起来的日志同步</h2><p>首先更新我们的 心跳&#x2F;日志 结构体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppendEntriesArgs 心跳/日志同步 参数</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term     <span class="type">int</span> <span class="comment">// 领导者的任期号</span></span><br><span class="line">LeaderId <span class="type">int</span> <span class="comment">// 领导者的ID</span></span><br><span class="line"><span class="comment">// 加入同步日志参数</span></span><br><span class="line">PrevLogIndex <span class="type">int</span>        <span class="comment">// 上一个日志的索引</span></span><br><span class="line">PrevLogTerm  <span class="type">int</span>        <span class="comment">// 上一个日志的任期号</span></span><br><span class="line">Entries      []LogEntry <span class="comment">// 日志条目</span></span><br><span class="line">LeaderCommit <span class="type">int</span>        <span class="comment">// 领导者的已提交日志索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 轮子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch 进阶</title>
      <link href="/2025/03/12/ElasticSearch/"/>
      <url>/2025/03/12/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><p><img src="/2025/03/12/ElasticSearch/image-20250610171713163.png" alt="image-20250610171713163"></p><h1 id="ES使用场景"><a href="#ES使用场景" class="headerlink" title="ES使用场景"></a>ES使用场景</h1><ol><li>全文搜索</li><li>日志检索，配合Kibana可视化</li><li>商品搜索</li><li>实时监控</li><li>个性化推荐，根据用户搜索历史、浏览行为找出相似内容</li><li>地理位置搜索（外卖系统）</li><li>智能提示&#x2F;提示词</li></ol><p>🔵 <strong>MySQL</strong>不能替代<strong>ES</strong>，因为：</p><ul><li>MySQL做全文检索很弱（like %xxx% 查询超级慢）</li><li>MySQL不擅长复杂聚合分析（特别是大数据量）</li><li>MySQL无法做到灵活的多字段模糊搜索、地理位置搜索、同义词处理</li></ul><p>🔵 <strong>ES</strong>不能替代<strong>MySQL</strong>，因为：</p><ul><li>ES写一致性弱，不支持多表事务（比如扣库存和扣余额一起回滚）</li><li>ES不保证强一致性（默认最终一致性，适合搜索，不适合资金类应用）</li><li>ES的数据模型松散，复杂关系建模很痛苦（比如订单拆分、子表操作）</li></ul><h1 id="什么是ElasticSearch？"><a href="#什么是ElasticSearch？" class="headerlink" title="什么是ElasticSearch？"></a>什么是ElasticSearch？</h1><p>简单来说，ES是一个分布式的、基于文档的 搜索引擎+数据库系统</p><ul><li>分布式： 天然支持分布式&#x2F;集群、扩展节点</li><li>文档存储： 数据并不是以行或者列进行存储，而是一份份JSON文档<ul><li>聚合分析（数值型字段）会单独存储到Doc values中，列式存储（加速聚合分析，且无冗余字段，比MySQL快太多了</li></ul></li><li>搜索引擎： 天然支持全文检索、模糊匹配、权重排行</li><li><strong>近实时： 数据写进去后，需要等待几秒才能查询到</strong></li></ul><h2 id="专业术语（import）"><a href="#专业术语（import）" class="headerlink" title="专业术语（import）"></a>专业术语（import）</h2><ol><li>集群： 一堆ES结点组成的整体</li><li>结点：单个ES实例</li><li>索引： 类似于MySQL的数据库表</li><li>文档： 存储的一条数据（JSON） 类似于MySQL的一行数据</li><li>字段（Field）： 文档里面的key ， 类似于MySQL的列字段</li><li>Mapping： 字段结构定义 ， 类似于MySQL的表结构</li><li>分片（shard）：把索引数据切片到不同结点上 （分库分表）</li><li>副本（Replica）：分片的备份</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>ES的索引一旦建好，很多东西无法随意更改哦！</p></blockquote><ul><li>settings中的参数能够动态修改（副本数）但是分片数无法修改</li><li>只能追加新字段，无法修改或者删除字段</li></ul><h3 id="为什么ES无法随便修改字段？"><a href="#为什么ES无法随便修改字段？" class="headerlink" title="为什么ES无法随便修改字段？"></a>为什么ES无法随便修改字段？</h3><ul><li>倒排索引，修改字段&#x3D; 破坏索引结构，代价极大</li><li><h2 id="ES底层时不可变文件（Segment）-类似于LSM树的SSTable-只写不改-旧的数据标记为无效，合并时清除"><a href="#ES底层时不可变文件（Segment）-类似于LSM树的SSTable-只写不改-旧的数据标记为无效，合并时清除" class="headerlink" title="ES底层时不可变文件（Segment）- 类似于LSM树的SSTable- 只写不改- 旧的数据标记为无效，合并时清除"></a>ES底层时不可变文件（Segment）<br>- 类似于LSM树的SSTable<br>- 只写不改<br>- 旧的数据标记为无效，合并时清除</h2></li></ul><h3 id="Reindex"><a href="#Reindex" class="headerlink" title="Reindex"></a>Reindex</h3><ol><li>创建一个新索引（新的mapping）</li><li>将老数据reindex过去</li><li>删除老索引</li></ol><p>ES 中 就有这个API -&gt; reindex</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;old_index&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;new_index&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><ol><li><strong>倒排索引</strong></li></ol><p>极为核心的一点</p><p>不同于正排索引那样： 这个文档包含哪些字段</p><p>倒排索引描述： 这些字段 存储在哪些文档中</p><ol><li>文档存储</li></ol><p>ES中，文档时存储数据的基本单位，每个文档实际上就是一个JSON对象，包含一个唯一的ID</p><p>文档数据存储在 一个 名为  Segment 的数据结构中</p><ol><li>Segment（段）</li></ol><p>ES会把文档写入到磁盘中的Segment中</p><p>每个段是不可变的（存储了倒排索引、文档存储、<strong>元数据</strong>等内容）</p><blockquote><p>和LSM树的SSTable极为相似</p></blockquote><ol><li>倒排表</li></ol><p>倒排表是倒排索引的存储形式，用来快速检索词和文档之间的关系</p><table><thead><tr><th>分词</th><th>文档id</th><th></th></tr></thead><tbody><tr><td>az</td><td>1，2，3</td><td></td></tr><tr><td>阿巴阿巴</td><td>3</td><td></td></tr></tbody></table><ul><li>每个词都会有一个倒排表，用于存储哪些文档包含整个词，以及这个词在文档中的位置（postings</li><li>倒排表会结合Posting List 来存储具体的位置信息</li></ul><ol><li>FST（Finite State Transducer）</li></ol><p>FST是ES中用来优化倒排索引的一种数据结构，用来存储词典（Term Dictionary），提高查找效率</p><ul><li>Term Dictionary 存储所有的<strong>term</strong>（词条）FST通过有限状态机压缩这些词条</li><li>由于字典中的词条数量巨大，通过压缩减少存储空间</li></ul><ol><li>Posting List</li></ol><p>用于存储某个词出现的文档ID以及其他相关信息（词频、位置等）</p><ul><li>结构： Posting List 中每一项都包含了文档ID和该词在文档中的出现位置</li><li>索引： 每个都会有一个对应的Posting List</li></ul><h1 id="CRUD操作过程"><a href="#CRUD操作过程" class="headerlink" title="CRUD操作过程"></a>CRUD操作过程</h1><p>关于近实时问题：<a href="https://blog.csdn.net/hugo_lei/article/details/106519069">https://blog.csdn.net/hugo_lei/article/details/106519069</a></p><h2 id="Elasticsearch搜索引擎的索引构建过程？"><a href="#Elasticsearch搜索引擎的索引构建过程？" class="headerlink" title="Elasticsearch搜索引擎的索引构建过程？"></a>Elasticsearch搜索引擎的索引构建过程？</h2><ol><li>解析文档，通过分词器将文档中的字段进行分词，存储到term dictionary中</li><li>ES会遍历term dictionary，查看这个分词是否已经被记录过。</li><li>为每一个term（分词）创建一个Posting List，并将该文档id以及该词存储进去</li><li>如果已经为该 term 创建了一个PostingList，直接合并该文档id进去</li></ol><h3 id="输入一个单词去查询会发生什么？"><a href="#输入一个单词去查询会发生什么？" class="headerlink" title="输入一个单词去查询会发生什么？"></a>输入一个单词去查询会发生什么？</h3><ol><li>由一个协调节点分析 该索引 是存储在哪个 主分片上的</li><li>确定好后，将该单词进行分词</li><li>从目标分片的Segment中使用FST 进行前缀遍历 定位 分词在倒排索引表中的偏移量</li><li>通过偏移量查询到该 分词所在posting list位置，然后拿到文档id集合(DocID)</li><li>将多个segment的id集合进行合并 </li><li>通过相关算法计算相关性评分然后进行结果排序</li><li>根据from和size进行分页与截断</li><li>聚合分片结果（文档 ID 和评分，生成全局排序列表）获取原始文档</li><li>执行高亮&#x2F;聚合操作 返回 JSON格式搜索结果</li></ol><h2 id="如何通过文档id查询到对应索引下的文档？-id"><a href="#如何通过文档id查询到对应索引下的文档？-id" class="headerlink" title="如何通过文档id查询到对应索引下的文档？(_id)"></a>如何通过文档id查询到对应索引下的文档？(_id)</h2><p><a href="https://www.jianshu.com/p/0ce7d9254a80">https://www.jianshu.com/p/0ce7d9254a80</a></p><blockquote><p>总结： _id-&gt;确定分片-&gt;并行查询segment -&gt;使用最新的DocId读取文档</p></blockquote><ol><li>通过hash 计算_id 是存储在哪个分片下的</li><li>在分片内定位到Segment<ol><li>并行查询所有Segment ，若找到一个或者多个（根据版本号&#x2F;时间戳选取最新的）</li><li>Segment元信息：Segment会记录该Segment存储的 DocID 范围</li></ol></li><li>在Segment内部查找文档<ol><li>通过倒排索引，使用_id 查询得到DocID</li><li>使用DocId<ol><li>若查询非Text 数据，仅需程序Doc Values</li><li>若需要查询JSON文件数据，或文本数据，需要使用正排索引拿到_source</li></ol></li></ol></li></ol><ul><li><code>_id</code>字段的倒排索引缓存： <code>_id</code>字段的倒排索引常驻内存（如FST结构），加速<code>_id</code>到<code>docId</code>的映射。</li><li>正排索引的懒加载： 仅当需要返回<code>_source</code>或存储字段时，才访问正排索引（若只查询<code>_id</code>或聚合字段，可能跳过正排索引）。</li><li>Doc Values列存： 对非<code>text</code>字段，直接通过<code>docId</code>从列存（Doc Values）中读取值，避免解析<code>_source</code>。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">假设查询 GET /orders/_doc/123：</span><br><span class="line">分片路由：</span><br><span class="line"><span class="built_in">hash</span>(123) % 3 → 分片1。</span><br><span class="line">分片内查找Segment：</span><br><span class="line">检查分片1的 DocIDMap，发现 _id=123 在 SegmentA。</span><br><span class="line">若 SegmentA 被缓存，直接跳过磁盘IO。</span><br><span class="line">Segment内读取：</span><br><span class="line">从 SegmentA 的 .doc 文件获取 DocID=5。</span><br><span class="line">从 .dvd（Doc Values）或 _source 中读取 DocID=5 的数据。</span><br><span class="line">返回结果：</span><br><span class="line">组合字段内容，返回文档。</span><br></pre></td></tr></table></figure><h2 id="如何实现范围查询？"><a href="#如何实现范围查询？" class="headerlink" title="如何实现范围查询？"></a>如何实现范围查询？</h2><ol><li>数值&#x2F;日期范围：BKD树</li><li>字符串范围：字典序+倒排索引</li><li>日期范围转化为数值</li></ol><h3 id="写入一个新文档过程？"><a href="#写入一个新文档过程？" class="headerlink" title="写入一个新文档过程？"></a>写入一个新文档过程？</h3><p><a href="https://blog.csdn.net/hugo_lei/article/details/106519069">https://blog.csdn.net/hugo_lei/article/details/106519069</a></p><ol><li>新写入的文档会首先暂存到in-memory-buffer中（不可被搜索到）</li><li>同时写入事务日志（Translog）（实时fsync写入到磁盘中，顺序写</li><li>Refresh：默认每1秒，将内存缓冲区的数据生成新的segment并放入到文件系统缓存（可搜索）</li></ol><blockquote><p>Page Cache中？ yep！</p></blockquote><ol><li>Flush： 定期将文件系统中的段持久化到磁盘中</li></ol><blockquote><p>接下来是困难版</p></blockquote><ol><li>客户端发送写入请求</li><li>协调结点处理请求<ol><li>解析索引名称，确定文档应该写入到哪个主分片</li><li>根据routing 计算目标分片位置（通过_id 进行hash计算）</li><li>转发请求到该分片所在主分片结点</li></ol></li><li>主分片处理写入<ol><li>文档先写入到in-memory-buffer中（不可被搜索、未持久化</li></ol></li><li>写入事务日志（Translog<ol><li>同步写入</li><li>顺序写入磁盘</li></ol></li><li>返回客户端ACK</li><li>Refresh（数据可被搜索</li><li>Flush（30分钟&#x2F;translog写满</li><li>Segment Merge（段合并<ol><li>后台自动执行</li><li>不影响搜索（旧segment在合并完成后才被替换</li></ol></li><li>副本分片同步<ol><li>执行主分片相同操作</li><li><code>wait_for_active_shards</code>：可配置必须有多少分片可用才返回成功</li></ol></li></ol><h3 id="删除一个文档过程"><a href="#删除一个文档过程" class="headerlink" title="删除一个文档过程"></a>删除一个文档过程</h3><ol><li>删除请求到达</li><li>不会物理删除，而是打上一个标记，同时写入到translog中（查询时会过滤</li><li>刷新（flush）和合并（merge）时真正删除</li></ol><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><blockquote><p>本质时删除 + 新增</p></blockquote><ol><li>先查询旧文档打上删除标记</li><li>将新文档内容写入到in-memory-buffer和translog中</li><li>更新之后，文档的_version字段会+1，通过乐观锁保证并发一致性</li><li>后续通过merge清理旧数据</li></ol><h3 id="什么时候进行Segment合并"><a href="#什么时候进行Segment合并" class="headerlink" title="什么时候进行Segment合并"></a>什么时候进行Segment合并</h3><ul><li>后台自动合并</li><li>Flush时触发</li><li>手动触发</li><li>基于segment数量和大小（数量&#x2F;存储大小达到阈值</li></ul><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="FST"><a href="#FST" class="headerlink" title="FST"></a>FST</h3><p><a href="https://juejin.cn/post/7226710109585424440">https://juejin.cn/post/7226710109585424440</a></p><blockquote><p>FST（有限状态机）用于快速检索、前缀匹配、范围查询</p><p>ES中主要用于存储 词典</p></blockquote><p>为什么要使用FST？</p><ul><li>倒排索引中词典十分庞大，需要通过关键字快速定位Posting List</li><li>兼顾 小空间占用 + 快速查询</li></ul><h4 id="FST的结构和组织方式"><a href="#FST的结构和组织方式" class="headerlink" title="FST的结构和组织方式"></a>FST的结构和组织方式</h4><blockquote><p>可以理解为压缩版的有向图（共享前缀和后缀）</p></blockquote><p>核心元素</p><ul><li>节点：  一个状态，代表某个字符读到这里了</li><li>边： 从一个节点到另一个节点的跳转，携带一个字符&#x2F;字符范围</li><li>输出： 走到某个路径时累加的值<ul><li>所有以该前缀开头的词项的公共信息（如内存地址）-》前缀优化共享</li><li>权重（如概率、分数），通过累加得到路径总权重。</li><li>该词在倒排索引中的 文件偏移量（File Pointer）。</li></ul></li></ul><ol><li>前缀共享</li><li>后缀合并</li></ol><h4 id="搜索关键词时，怎么使用FST？"><a href="#搜索关键词时，怎么使用FST？" class="headerlink" title="搜索关键词时，怎么使用FST？"></a>搜索关键词时，怎么使用FST？</h4><p>通过前缀遍历快速找到关键词，然后拿到Posting List然后拿到文档ID</p><p><strong>思考： 前缀遍历？那 apple 构建状态机后， 使用 pl 如何搜索呢?</strong></p><blockquote><p>害，pl 和apple已经是两个单词了，且没有共用一个前缀，所以无法搜到，除非把apple五个字母都进行拆分</p></blockquote><blockquote><p>实在要搞的话，可以建立反向索引或者使用高级搜索，遍历Segment</p></blockquote><h4 id="如何支持模糊搜索？-（这里不同于MySQL的模糊搜索）"><a href="#如何支持模糊搜索？-（这里不同于MySQL的模糊搜索）" class="headerlink" title="如何支持模糊搜索？ （这里不同于MySQL的模糊搜索）"></a>如何支持模糊搜索？ （这里不同于MySQL的模糊搜索）</h4><blockquote><p>比如使用appld 可以搜到apple</p></blockquote><ul><li>开始遍历时，记录当前位置和当前误差次数。</li><li>遇到不同字符时，不是直接失败，而是：<ul><li>如果误差没超上限（比如1次），<strong>尝试走插入&#x2F;删除&#x2F;替换</strong>的可能路径！</li></ul></li><li>找到匹配路径后，返回最接近的词</li></ul><h4 id="FST和Trie、Hash表的区别，为什么不是Trie？为什么不用Hash"><a href="#FST和Trie、Hash表的区别，为什么不是Trie？为什么不用Hash" class="headerlink" title="FST和Trie、Hash表的区别，为什么不是Trie？为什么不用Hash"></a>FST和Trie、Hash表的区别，为什么不是Trie？为什么不用Hash</h4><ol><li>Trie只能共享前缀，内存消耗较大，每个节点存储一个字符串</li><li>通过前缀遍历得到的 词组 + 输出值便能得到 该词在倒排索引表中的偏移量，无需是使用Hash定位（甚至不需要解决hash冲突）<ol><li>查找效率更高，无需注意哈希函数计算以及冲突问题</li><li>Hash不关心顺序</li><li>设计不当时，Hash内存开销更大</li></ol></li></ol><h4 id="FST查询过程，如何快速查询？如何找到一个词的posting-list起始位置"><a href="#FST查询过程，如何快速查询？如何找到一个词的posting-list起始位置" class="headerlink" title="FST查询过程，如何快速查询？如何找到一个词的posting list起始位置"></a>FST查询过程，如何快速查询？如何找到一个词的posting list起始位置</h4><ol><li>通过前缀遍历进行匹配</li><li>若设置了模糊查询可以忍受一定程度的不同（比如app-》ape）</li><li>走完整个词（比如app 走到 p时，发现该边指向节点接受状态（此时累计的输出值就是posting list的起始位置</li></ol><blockquote><p>积累值会变化</p></blockquote><p>小demo体验一下创建过程</p><p><a href="http://examples.mikemccandless.com/fst.py?terms=mop/0%0D%0Adat/1%0D%0Adog/2%0D%0Ademory/3%0D%0Amax/4&cmd=Build+it!">http://examples.mikemccandless.com/fst.py?terms=mop%2F0%0D%0Adat%2F1%0D%0Adog%2F2%0D%0Ademory%2F3%0D%0Amax%2F4&amp;cmd=Build+it%21</a></p><blockquote><p>番外？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> FST结构（有序！）：</span><br><span class="line"></span><br><span class="line"> a --&gt; aa --&gt; apple</span><br><span class="line"> a --&gt; ab --&gt; about</span><br><span class="line"> b --&gt; ba --&gt; base</span><br><span class="line"> b --&gt; bb --&gt; boss</span><br><span class="line"> c --&gt; ca --&gt; car</span><br><span class="line"></span><br><span class="line">比如 range [&quot;ab&quot;, &quot;bb&quot;]:</span><br><span class="line">- 从&quot;ab&quot;找到起点</span><br><span class="line">- 收 about -&gt; base -&gt; boss</span><br><span class="line">- 到了&quot;car&quot;，跳出</span><br></pre></td></tr></table></figure><h4 id="增删改时，FST变化"><a href="#增删改时，FST变化" class="headerlink" title="增删改时，FST变化"></a>增删改时，FST变化</h4><p>新增文档</p><ul><li><strong>每次新增文档时，并不会修改已有 segment 的 FST</strong></li><li>而是生成一个新的 FST（对应新的 segment）</li></ul><p>删除文档时</p><ul><li>Lucene 给对应的 DocID 打上 <strong>delete 标记</strong>（bitmap）</li><li>Posting list &#x2F; FST 本身 <strong>不变</strong></li><li>查询阶段跳过已删除 DocID</li></ul><p>更新文档时</p><ul><li>标记旧文档删除（不会动老 FST）</li><li>插入新文档 -&gt; 写入内存 -&gt; flush 生成新 segment + 新 FST</li></ul><h4 id="merge-FST会做什么？"><a href="#merge-FST会做什么？" class="headerlink" title="merge FST会做什么？"></a>merge FST会做什么？</h4><ul><li>合并多个 segment（包含它们的倒排表 + FST）</li><li>去除被删除文档（只保留有效 docID）</li><li>重建新的倒排索引和一个新的 <strong>合并后的 FST</strong></li></ul><h3 id="Posting-List"><a href="#Posting-List" class="headerlink" title="Posting List"></a>Posting List</h3><blockquote><p>用于记录每个分词 出现在哪些文档的id集合</p></blockquote><h2 id="Segment（Import！）"><a href="#Segment（Import！）" class="headerlink" title="Segment（Import！）"></a>Segment（Import！）</h2><p><a href="https://github.dev/apache/lucene">https://github.dev/apache/lucene</a></p><p><a href="https://lucene.apache.org/core/9_0_0/core/org/apache/lucene/codecs/lucene90/package-summary.html#Segments">https://lucene.apache.org/core/9_0_0/core/org/apache/lucene/codecs/lucene90/package-summary.html#Segments</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Segment</span><br><span class="line">├── .tim (Term Dictionary, FST)</span><br><span class="line">├── .tip (Skip List)</span><br><span class="line">├── .doc (Document BitSet)</span><br><span class="line">├── .pos (Positions)</span><br><span class="line">├── .dv (Doc Values)</span><br><span class="line">├── .fdt / .fdx (Stored Fields, 正排索引)</span><br></pre></td></tr></table></figure><p>核心组成部分</p><ol><li>倒排索引（FST+Posting List）<ol><li>词项字典 （存储所有的 词项 term ，使用 FST 压缩</li><li>倒排列表（记录 词项 对应的 文档ID 以及位置信息（词频、偏移量）</li><li>存储词项位置和负载（用于短语查询和高亮</li></ol></li></ol><blockquote><p>加速全文搜索</p></blockquote><ol><li>Doc Values<ol><li>存储字段的列式数据（numeric、keyword等）</li><li>存储元数据（最大值、最小值、压缩方式</li></ol></li></ol><blockquote><p>加速排序、聚合、脚本计算，按照 列式 存储字段</p></blockquote><ol><li>文档存储( 使用正排索引读取 DocId -&gt; _source<ol><li><blockquote><p>用于存储原始文档内容（_source）用于返回搜索结果</p></blockquote></li><li><p>存储原始JSON文档</p></li><li><p>存储文档的元信息（偏移量、压缩方式</p></li></ol></li><li>文档ID映射 (DocID -&gt; _id)<ol><li><blockquote><p>内部简历DocID 和用户 _id的映射关系</p></blockquote></li><li><p>Segment的元信息，DocID 范围</p></li><li><p>_id 通过倒排索引与 DocID 关联</p></li><li><p>DocID 通过正排索引拿到文档</p></li></ol></li></ol><p><a href="https://github.dev/apache/lucene">https://github.dev/apache/lucene</a>   ———-&gt; codec-&gt; SegmentInfo.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SegmentInfo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 表示不存在（如无norms、无删除文档）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">YES</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 表示存在（如有norms、有删除文档）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String name;      <span class="comment">// 唯一segment名称（如&quot;_0&quot;）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxDoc;            <span class="comment">// segment中的文档总数（含删除文档）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Directory dir;    <span class="comment">// segment所在的存储目录</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> isCompoundFile; <span class="comment">// 是否使用复合文件格式(.cfs)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] id;       <span class="comment">// segment的唯一二进制ID</span></span><br><span class="line"><span class="keyword">private</span> Codec codec;           <span class="comment">// 使用的编解码器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; diagnostics; <span class="comment">// 诊断信息（调试用）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; attributes;  <span class="comment">// 自定义扩展属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sort indexSort;  <span class="comment">// segment的排序规则（非null表示预排序）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BKD树"><a href="#BKD树" class="headerlink" title="BKD树"></a>BKD树</h2><blockquote><p>K-D 树 + B+树混合</p></blockquote><p><img src="https://qcn3hg7hgio7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E0ZTQyOTAzZjZiZjczMzgzNDVmZWIxMjRiYTEwNDRfUU1GeEtRV1F0QlI2MlZIaktBdUFkcEs2U0xDZ0hIeFVfVG9rZW46STFwYWI4RnRJb0F3WE14NXY3bmNhZjlGbk9lXzE3NDk1NDY4NjI6MTc0OTU1MDQ2Ml9WNA" alt="img"></p><ul><li>适用场景：数值过滤、地理围栏、时间区间分析等</li><li>优势：<ul><li>高效磁盘存储：数据按块（Block）组织，减少随机 I&#x2F;O。</li><li>查询优化：剪枝策略快速跳过不匹配的数据块。</li><li>压缩存储：对数值类型（如整数、浮点数）采用增量编码压缩。</li></ul></li></ul><h2 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h2><p><a href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p><p><a href="https://zhuanlan.zhihu.com/p/415799237">https://zhuanlan.zhihu.com/p/415799237</a></p><h3 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h3><p>存储在内存中，用于保存最近更新的数据</p><p>通常使用红黑树&#x2F;跳表数据结构实现，按照Key有序地组织这些数据</p><p>写入的时候通常会追加一份WAL（Write Ahead log）预写日志，保证宕机恢复</p><blockquote><p>当memtable达到一定大小时，会flush到磁盘中</p></blockquote><h3 id="Immutable-memtable"><a href="#Immutable-memtable" class="headerlink" title="Immutable memtable"></a>Immutable memtable</h3><p>memtable到sstable的一个中间状态</p><ul><li>当memtable满了之后，不会直接删除，会变为一个只读的immutable memetable</li><li>同时创建一个新的memtable用来接收写请求</li><li>这个immutable memtable会通过后台线程刷盘，变为sstable</li></ul><p>为什么这么设计？</p><ol><li>写操作不中断</li><li>异步刷盘</li></ol><h3 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h3><ul><li>当Immutable memeTable刷盘到磁盘中，形成一个SSTable文件</li><li>由于是顺序写到磁盘，写性能极高</li><li>SSTable是不可变的，只能增加或者合并产生新的SSTable</li></ul><p>主要包含内容</p><ol><li>Key&#x2F;value数据（有序</li><li>稀疏索引（快速定位</li><li>布隆过滤器（快速判断key是否存在</li><li>元数据（校验数据，时间戳等–》因为可能存在重复key，更新时间最新的才是有效key</li></ol><h3 id="Compact策略"><a href="#Compact策略" class="headerlink" title="Compact策略"></a>Compact策略</h3><ul><li>Size-tiered 策略</li></ul><p><img src="/2025/03/12/ElasticSearch/image-20250610171731711.png" alt="image-20250610171731711"></p><ul><li>Leveled 策略</li></ul><p><img src="/2025/03/12/ElasticSearch/image-20250610171736656.png" alt="image-20250610171736656"></p><p>关键点：</p><ol><li>读放大</li><li>写放大</li><li>空间放大</li></ol><p>Level 0： 刚flush出来的小sstable文件，不要求有序，且key之间范围可以重叠</p><p>Leve 1 及以上： 每一层文件的key范围不重叠，数据量更大</p><h3 id="增删查改操作"><a href="#增删查改操作" class="headerlink" title="增删查改操作"></a>增删查改操作</h3><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><p>由于LSM树初衷就是应对写操作极为频繁的场景</p><p>插入操作只需要无脑写入memtable就行了</p><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>采用逻辑删除</p><p>写一条墓碑标记到 WAL 和 memtable中</p><blockquote><p>真正删除该数据是在compaction时完成</p></blockquote><p>也就是说物理数据在memtable中还是磁盘中，还是不存在，无需关系</p><p>compaction过程会进行删除</p><h5 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h5><ol><li>先查memtable（因为是最新的操作）</li><li>再查immutable memtable</li><li>还没有找到则按照level 0 - n依次查找</li></ol><ul><li>查询时要处理<strong>墓碑标记</strong>（如果找到墓碑，就算有旧数据，也算被删除）</li><li>随着level越高，文件越少、范围越大（减少查找代价）</li></ul><h5 id="更新操作-1"><a href="#更新操作-1" class="headerlink" title="更新操作"></a>更新操作</h5><ol><li>写入WAL</li><li>写入memtable<ol><li>待修改数据在memtable中，直接覆盖</li><li>带修改数据在磁盘中 直接写在memtable中，后续合并时新数据覆盖旧</li><li>该数据不存在，update操作变为insert</li></ol></li></ol><blockquote><p>其实update和insert操作在这里貌似就是相同的</p></blockquote><h3 id="有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？"><a href="#有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？" class="headerlink" title="有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？"></a>有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？</h3><blockquote><p>SSTable合并时删除带有墓碑标记的数据</p></blockquote><h4 id="为什么不能马上删除？"><a href="#为什么不能马上删除？" class="headerlink" title="为什么不能马上删除？"></a>为什么不能马上删除？</h4><p>由于LSM树的机制，不同层可能包含相同的key</p><p>直接删除可能会漏删老版本，或者删除代价极大</p><h4 id="解决删除不及时的办法"><a href="#解决删除不及时的办法" class="headerlink" title="解决删除不及时的办法"></a>解决删除不及时的办法</h4><ul><li>定期强制压缩</li><li>设置墓碑最大存活时间<ul><li>创建一个新SSTable，然后进行拷贝</li></ul></li></ul><h1 id="ElasticSearch（Lucene）-与LSM的异同"><a href="#ElasticSearch（Lucene）-与LSM的异同" class="headerlink" title="ElasticSearch（Lucene） 与LSM的异同"></a>ElasticSearch（Lucene） 与LSM的异同</h1><table><thead><tr><th></th><th>LSM树</th><th>Lucene（ES）</th></tr></thead><tbody><tr><td>写入</td><td>先写WAL文件再写入MemTable</td><td>先写Translog，再写入in-memroy-buffer</td></tr><tr><td>刷盘</td><td>MemTable满了刷入immutable 然后刷入sstable</td><td>in-mm-buffer满了（或1秒后）刷入Page Cache然后刷入磁盘</td></tr><tr><td>查询</td><td>先mt，再imt，再sst（读放大严重）</td><td>先内存中的segment、再磁盘中的segment 加入Caching优化机制，优先读最新段</td></tr><tr><td>删除</td><td>墓碑、懒回收、合并清除</td><td>墓碑，懒回收，合并清除</td></tr><tr><td>合并</td><td>Compaction</td><td>Segment Merge</td></tr><tr><td>数据</td><td>LSMKey&#x2F;value数据（有序稀疏索引（快速定位布隆过滤器（快速判断key是否存在元数据（校验数据，时间戳等–》因为可能存在重复key，更新时间最新的才是有效key</td><td>倒排索引（FST + Posting List)文档存储（JSON） <strong>元数据</strong></td></tr><tr><td>查询优化</td><td>布隆过滤器、二分查找</td><td>FST词典、跳表、缓存</td></tr><tr><td>数据不可修改</td><td>是</td><td>是</td></tr><tr><td>空间回收</td><td>合并时清理墓碑、去重</td><td>合并时清理已删除文档</td></tr><tr><td>关注点</td><td>写多读少（SSTable有序）</td><td>写少读多</td></tr></tbody></table><h2 id="核心相似点"><a href="#核心相似点" class="headerlink" title="核心相似点"></a>核心相似点</h2><ol><li>追加写入</li></ol><ul><li>两者都是先将数据写入到内存中，然后刷盘不可变的文件中</li><li>通过顺序写入减少随机IO</li></ul><ol><li>分层合并</li></ol><ul><li>LSM树通过后台合并，将多个SSTable合并为更大更有序的SSTable，更新文件，删除冗余数据（重复key）</li><li>Lucene通过后台合并，将多个小segment合并为一个大Segment，优化查询性能，并回收空间</li></ul><ol><li>不可变性</li></ol><ul><li>SSTable和Segment写入磁盘后无法更改，删除&#x2F;更新操作通过追加 + 合并进行实现</li><li>简化并发控制，避免锁竞争</li></ul><h2 id="关键差异"><a href="#关键差异" class="headerlink" title="关键差异"></a>关键差异</h2><ol><li>设计目标</li><li>数据结构</li><li>合并策略</li><li>删除处理</li></ol><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h1 id="从集群来看ES"><a href="#从集群来看ES" class="headerlink" title="从集群来看ES"></a>从集群来看ES</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Cluster&#x3D; 一群Node + 一个Master Node（协调）+ 数据分散存储</p><h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><ul><li>Mater Node：复杂管理Cluster状态（建索引、删除、分片分片等）</li><li>Data Node： 负责存储数据、处理读写请求</li><li>Coordinating Node： 负责接收请求、拆分请求、分发到各个结点，最后聚合结果</li><li>Ingest Node： 做预处理</li></ul><blockquote><p>一个结点可以有多个身份</p></blockquote><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><p>Index相当于数据库中的表，逻辑上的数据集合</p><ul><li>每个Index物理上会被分成多个 Shard（分片，存储到不同结点上</li><li>索引创建时就需要指定主分片数+副本分片数</li></ul><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><ul><li><strong>主分片（Primary Shard）</strong>：真正存储数据的分片。</li><li><strong>副本分片（Replica Shard）</strong>：主分片的拷贝，用于容灾、高可用，同时也能分担查询负载。</li><li>每个分片其实内部就是一个 <strong>Lucene 引擎实例</strong>（独立维护倒排索引、Segment、Document等）。</li></ul><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Node</td><td>运行中的 Elasticsearch 实例，托管若干个 Shard</td></tr><tr><td>Shard</td><td>由 Node 托管，实际保存数据和索引（底层用 Lucene 实现）</td></tr><tr><td>一个 Node</td><td>可以承载 多个 Shard（包括主分片和副本分片）</td></tr><tr><td>一个 Shard</td><td>只能存在于 一个 Node 上（同一个 Shard 不会横跨多个 Node）</td></tr></tbody></table><h1 id="🔥-举个例子"><a href="#🔥-举个例子" class="headerlink" title="🔥 举个例子"></a>🔥 举个例子</h1><p>假设：</p><ul><li>我创建了一个 <code>products</code> 索引</li><li>设置为 <strong>3个主分片</strong>，每个主分片 <strong>1个副本</strong></li></ul><p>那就是一共：</p><ul><li>3 个 Primary Shard（主）</li><li>3 个 Replica Shard（副本）</li><li>总计 6 个 Shard</li></ul><p>如果你的集群有 3 个 Node，那么可能的分配：</p><table><thead><tr><th>Node</th><th>托管的分片</th></tr></thead><tbody><tr><td>Node 1</td><td>Primary 1, Replica 2</td></tr><tr><td>Node 2</td><td>Primary 2, Replica 3</td></tr><tr><td>Node 3</td><td>Primary 3, Replica 1</td></tr></tbody></table><blockquote><p>⚡ 注意：Elasticsearch 调度器会尽量让 <strong>主副本和副副本不在同一台机器上</strong>，以提高容错性！</p></blockquote><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p><a href="https://tech.meituan.com/2022/11/17/elasicsearch-optimization-practice-based-on-run-length-encoding.html">https://tech.meituan.com/2022/11/17/elasicsearch-optimization-practice-based-on-run-length-encoding.html</a></p><h3 id="用-geo-shape-类型（而不是-geo-point）"><a href="#用-geo-shape-类型（而不是-geo-point）" class="headerlink" title=". 用 geo_shape 类型（而不是 geo_point）"></a>. 用 <code>geo_shape</code> 类型（而不是 <code>geo_point</code>）</h3><ul><li><code>geo_point</code>：经纬度，单个点（只能做简单的附近搜索）</li><li><code>geo_shape</code>：支持复杂的几何图形，比如：Polygon（多边形）、MultiPolygon（多个多边形）、Line、Envelope 等等。</li></ul><p><strong>示例：建索引 Mapping：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /stores</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;delivery_area&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;geo_shape&quot;</span> &#125;  // 这里是 geo_shape</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>存储门店配送范围（多边形Polygon）</li></ol><p>每家店上传一个或多个 Polygon：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /stores/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;王记烧烤&quot;</span>,</span><br><span class="line">  <span class="string">&quot;delivery_area&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coordinates&quot;</span>: [</span><br><span class="line">      [</span><br><span class="line">        [121.4737, 31.2304],</span><br><span class="line">        [121.4750, 31.2300],</span><br><span class="line">        [121.4760, 31.2310],</span><br><span class="line">        [121.4740, 31.2320],</span><br><span class="line">        [121.4737, 31.2304]  // 注意闭合：起点和终点一样</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>coordinates</code> 是经纬度数组（WGS84坐标系）。</li><li>每个 Polygon 一定要首尾闭合。</li></ul><ol><li>检索用户位置是否在配送区内</li></ol><p><strong>使用</strong> <strong><code>geo_shape</code></strong> <strong>的</strong> <strong><code>intersects</code></strong> <strong>查询</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /stores/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;geo_shape&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;delivery_area&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;relation&quot;</span>: <span class="string">&quot;intersects&quot;</span>,  // 交集</span><br><span class="line">            <span class="string">&quot;shape&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;point&quot;</span>,</span><br><span class="line">              <span class="string">&quot;coordinates&quot;</span>: [121.4745, 31.2315]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>意思是：找到所有 <strong>配送区域覆盖这个点的门店</strong>。</li><li>当然也可以用 <code>within</code>、<code>contains</code> 等其他空间关系。</li></ul><h1 id="HNSW"><a href="#HNSW" class="headerlink" title="HNSW"></a>HNSW</h1><blockquote><p>todo 这一节更多是会写到RAG&amp;MCP应用文章中，后续放一个跳转链接</p></blockquote><h1 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h1><h1 id="外卖系统怎么用ES聚合附近商家的评分？"><a href="#外卖系统怎么用ES聚合附近商家的评分？" class="headerlink" title="外卖系统怎么用ES聚合附近商家的评分？"></a>外卖系统怎么用ES聚合附近商家的评分？</h1><p>比如，用户打开饿了么，美团，想找附近评价高的商家。</p><ol><li>商家文档结构（在ES里）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;shop_id&quot;</span>: 12345,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;川湘小馆&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 31.2304, <span class="string">&quot;lon&quot;</span>: 121.4737 &#125;,  // 经纬度</span><br><span class="line">  <span class="string">&quot;rating&quot;</span>: 4.8,       // 评分</span><br><span class="line">  <span class="string">&quot;monthly_sales&quot;</span>: 230, // 月销售量</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [<span class="string">&quot;川菜&quot;</span>, <span class="string">&quot;小吃&quot;</span>, <span class="string">&quot;快餐&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用户搜索流程</li></ol><ul><li>根据用户位置（比如上海市中心）用 geo_distance 查询，查出 3km 内的商家。</li><li>然后用 <strong>聚合（Aggregation）</strong>：<ul><li>按评分（<code>rating</code>）做 <strong>平均值</strong>、<strong>排序</strong>，挑评分最高的商家。</li><li>按销量（<code>monthly_sales</code>）做 <strong>销量榜单</strong>。</li></ul></li></ul><h3 id="具体的-ES-查询"><a href="#具体的-ES-查询" class="headerlink" title="具体的 ES 查询"></a>具体的 ES 查询</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;3km&quot;</span>,</span><br><span class="line">          <span class="string">&quot;location&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 31.2304, <span class="string">&quot;lon&quot;</span>: 121.4737 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;rating&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;monthly_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="🛒-电商系统怎么用ES算实时销售榜？"><a href="#🛒-电商系统怎么用ES算实时销售榜？" class="headerlink" title="🛒 电商系统怎么用ES算实时销售榜？"></a>🛒 电商系统怎么用ES算实时销售榜？</h1><p>比如淘宝、京东首页上，「实时热销榜」就是这么搞的！</p><ol><li>商品文档结构（在ES里）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sku_id&quot;</span>: <span class="string">&quot;sku_98765&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Apple iPhone 15 Pro&quot;</span>,</span><br><span class="line">  <span class="string">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: 7999,</span><br><span class="line">  <span class="string">&quot;sales_count&quot;</span>: 5023,  // 累积销量</span><br><span class="line">  <span class="string">&quot;last_30min_sales&quot;</span>: 120  // 近30分钟销量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询实时热销榜流程</li></ol><ul><li>用字段 <code>last_30min_sales</code> 按照销量做 <strong>降序排序</strong>。</li><li>只取 Top 100 热销商品。</li><li>如果按品类分类（比如”手机”、”家电”），再做个 <strong>terms aggregation</strong> 按 category 分组！</li></ul><h3 id="具体的-ES-查询-1"><a href="#具体的-ES-查询-1" class="headerlink" title="具体的 ES 查询"></a>具体的 ES 查询</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;last_30min_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>按分类出榜单</strong>，再加一个聚合：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;by_category&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;field&quot;</span>: <span class="string">&quot;category.keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;top_sales&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;top_hits&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">            &#123; <span class="string">&quot;last_30min_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;size&quot;</span>: 5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 <strong>效果</strong>：比如“手机”品类下热销前5名，“家电”下热销前5名。</p><h2 id="对比Redis的Zset有什么优势？"><a href="#对比Redis的Zset有什么优势？" class="headerlink" title="对比Redis的Zset有什么优势？"></a>对比Redis的Zset有什么优势？</h2><ol><li><strong>支持复杂筛选</strong>：比如「上海地区，手机品类，价格5000以内，近一周销量榜」。</li><li><strong>支持复杂聚合分析</strong>：比如「按品牌分组统计销量」「统计每天销量走势」。</li><li><strong>支持冷热数据分层</strong>：老数据转冷，不影响新数据查询。</li><li><strong>适合超大规模数据</strong>：TB级，PB级也能撑住。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：回溯算法</title>
      <link href="/2025/01/25/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2025/01/25/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote><p>本质还是暴力搜索，但是可以利用剪枝进行优化</p></blockquote><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.cn/problems/combinations/">77. Combinations</a></h2><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">Explanation: There are 4 choose 2 = 6 total combinations.</span><br><span class="line">Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, k = 1</span><br><span class="line">Output: [[1]]</span><br><span class="line">Explanation: There is 1 choose 1 = 1 total combination.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="正常回溯"><a href="#正常回溯" class="headerlink" title="正常回溯"></a>正常回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       backtracing(n,k,<span class="number">1</span>,resultList,queue);</span><br><span class="line">      <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,Deque&lt;Integer&gt; queue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()==k)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(queue));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur;i&lt;=n;i++)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            backtracing(n,k,i+<span class="number">1</span>,resultList,queue);</span><br><span class="line">            queue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       backtracing(n,k,<span class="number">1</span>,resultList,queue);</span><br><span class="line">      <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,Deque&lt;Integer&gt; queue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()==k)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(queue));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur;i&lt;=(n-(k-queue.size())+<span class="number">1</span>);i++)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            backtracing(n,k,i+<span class="number">1</span>,resultList,queue);</span><br><span class="line">            queue.removeLast();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. Combination Sum III</a></h2><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p><ul><li>Only numbers <code>1</code> through <code>9</code> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6],[1,3,5],[2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 4, n = 1</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations.</span><br><span class="line">Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><h3 id="正常递归"><a href="#正常递归" class="headerlink" title="正常递归"></a>正常递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        backtracing(k,n,<span class="number">1</span>,resultList,list);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k&amp;&amp;getSum(list)==n) &#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracing(k,n,i+<span class="number">1</span>,resultList,list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getSum</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            sum += list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        backtracing(<span class="number">0</span>,k,n,<span class="number">1</span>,resultList,list);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>cur;i&lt;=<span class="number">9</span>-(k-list.size())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracing(sum,k,n,i+<span class="number">1</span>,resultList,list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] letterMap = &#123; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, </span><br><span class="line">    <span class="string">&quot;def&quot;</span>, </span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, </span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, </span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, </span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, </span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, &#125;;</span><br><span class="line">        List&lt;String&gt; resultList =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracing(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(String digits,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==digits.length())&#123;</span><br><span class="line">            resultList.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">digit</span> <span class="operator">=</span> letterMap[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;digit.length();i++)&#123;</span><br><span class="line">            temp.append(digit.charAt(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;回溯前:&quot;</span>+temp.toString());</span><br><span class="line">            backtracing(digits,index + <span class="number">1</span>);</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;回溯后:&quot;</span>+temp.toString());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a></h2><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the </p><p>frequency</p><p> of at least one of the chosen numbers is different.</p><p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.</span><br><span class="line">7 is a candidate, and 7 = 7.</span><br><span class="line">These are the only two combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8</span><br><span class="line">Output: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2], target = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li><li><code>1 &lt;= target &lt;= 40</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[]candidates,<span class="type">int</span> sum,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;sum)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempList.add(candidates[i]);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            backtracking(candidates,sum,i);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：二叉树</title>
      <link href="/2024/12/28/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/12/28/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>[TOC]</p><h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree</a></h2><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p><blockquote><p>Yes !  I can</p></blockquote><h3 id="recursively"><a href="#recursively" class="headerlink" title="recursively"></a>recursively</h3><blockquote><p>比较是否对称可以细化为，比较根节点的左右孩子，以及比较左孩子的左孩子跟右孩子的右孩子和左孩子的右孩子跟右孩子的左孩子</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">return</span> compareTree(root.left,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareTree</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left.val!=right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compareTree(left.left,right.right);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compareTree(left.right,right.left);</span><br><span class="line">            <span class="keyword">return</span> outside&amp;&amp;inside;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteratively"><a href="#iteratively" class="headerlink" title="iteratively"></a>iteratively</h3><blockquote><p>使用迭代法。队列以及栈都可以使用，我们只需要成对进行push以及pop然后比较即可</p></blockquote><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           queue.offer(root.left);</span><br><span class="line">           queue.offer(root.right);</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>&amp;&amp;rightNode==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>||rightNode==<span class="literal">null</span>||leftNode.val!=rightNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               queue.offer(leftNode.left);</span><br><span class="line">               queue.offer(rightNode.right);</span><br><span class="line">               queue.offer(leftNode.right);</span><br><span class="line">               queue.offer(rightNode.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           stack.push(root.left);</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>&amp;&amp;rightNode==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>||rightNode==<span class="literal">null</span>||leftNode.val!=rightNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               stack.push(leftNode.left);</span><br><span class="line">               stack.push(rightNode.right);</span><br><span class="line">               stack.push(leftNode.right);</span><br><span class="line">               stack.push(rightNode.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deeply</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               TreeNode curr= queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;<span class="comment">//剪掉一个根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            depth++;<span class="comment">//走完一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><p>Given a n-ary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The total number of nodes is in the range <code>[0, 104]</code>.</li><li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li></ul><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">                max = Math.max(max,maxDepth(child));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">                depth++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span>queue.size();</span><br><span class="line">                <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">for</span> (Node child : poll.children) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(child!=<span class="literal">null</span>)&#123;</span><br><span class="line">                            queue.offer(child);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><p>已解答</p><p>简单</p><p>相关标签</p><p>相关企业</p><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 105]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">   * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">   *     int val;</span></span><br><span class="line"><span class="comment">   *     TreeNode left;</span></span><br><span class="line"><span class="comment">   *     TreeNode right;</span></span><br><span class="line"><span class="comment">   *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">   *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">   *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">   *         this.val = val;</span></span><br><span class="line"><span class="comment">   *         this.left = left;</span></span><br><span class="line"><span class="comment">   *         this.right = right;</span></span><br><span class="line"><span class="comment">   *     &#125;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          LinkedList&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          queue.offer(root);</span><br><span class="line">          <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">              min++;</span><br><span class="line">              <span class="type">int</span> size=queue.size();</span><br><span class="line">              <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                  <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                      queue.offer(p.left);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                      queue.offer(p.right);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(p.right==<span class="literal">null</span>&amp;&amp;p.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                      <span class="keyword">return</span> min;</span><br><span class="line">                  &#125;</span><br><span class="line">                  size--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> min;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h3><blockquote><p>只有左右孩子都为空时才算深度</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.min(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p><p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p><p>Design an algorithm that runs in less than <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 5 * 104]</code>.</li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>The tree is guaranteed to be <strong>complete</strong>.</li></ul><h3 id="SimpleTree-way"><a href="#SimpleTree-way" class="headerlink" title="SimpleTree way"></a>SimpleTree way</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ant</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                ant++;</span><br><span class="line">                <span class="keyword">if</span>(poll.left!=<span class="literal">null</span>) queue.offer(poll.left);</span><br><span class="line">                <span class="keyword">if</span>(poll.right!=<span class="literal">null</span>) queue.offer(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompleteTree-way"><a href="#CompleteTree-way" class="headerlink" title="CompleteTree way"></a>CompleteTree way</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">       <span class="keyword">while</span>(leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        leftDepth++;</span><br><span class="line">        leftNode = leftNode.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        rightDepth++;</span><br><span class="line">        rightNode = rightNode.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftDepth==rightDepth)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftDepth)-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><p>Given a binary tree, determine if it is </p><p><strong>height-balanced</strong></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="recursively-1"><a href="#recursively-1" class="headerlink" title="recursively"></a>recursively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root,<span class="number">0</span>)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftDepth==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightDepth==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftDepth-rightDepth)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midleDepth</span> <span class="operator">=</span> Math.max(leftDepth,rightDepth)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> midleDepth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           List&lt;Integer&gt; pathList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           List&lt;String&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">           getPathToChild(root,pathList,resultList);</span><br><span class="line">           <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPathToChild</span><span class="params">(TreeNode root,List&lt;Integer&gt; pathList,List&lt;String&gt; resultList)</span>&#123;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pathList.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                 temp.append(pathList.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                temp.append(pathList.get(pathList.size()-<span class="number">1</span>));</span><br><span class="line">                resultList.add(temp.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">                getPathToChild(root.left,pathList,resultList);</span><br><span class="line">                pathList.remove(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                getPathToChild(root.right,pathList,resultList);</span><br><span class="line">                pathList.remove(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p><p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="recursively-2"><a href="#recursively-2" class="headerlink" title="recursively"></a>recursively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.left==<span class="literal">null</span>&amp;&amp;root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            left =  root.left.val;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left + right;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteratively-1"><a href="#iteratively-1" class="headerlink" title="iteratively"></a>iteratively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>&amp;&amp;top.left.left==<span class="literal">null</span>&amp;&amp;top.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                sum += top.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.right!=<span class="literal">null</span>) stack.push(top.right);</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>) stack.push(top.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="Queue-BFS"><a href="#Queue-BFS" class="headerlink" title="Queue (BFS)"></a>Queue (BFS)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.getFirst();</span><br><span class="line">            left = leftNode.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">                size--;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteravely"><a href="#iteravely" class="headerlink" title="iteravely"></a>iteravely</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iteravely(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iteravely</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth&gt;maxDepth)&#123;</span><br><span class="line">                result =root.val;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            iteravely(root.left,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            iteravely(root.right,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.cn/problems/path-sum/">112. Path Sum</a></h2><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are two root-to-leaf paths in the tree:</span><br><span class="line">(1 --&gt; 2): The sum is 3.</span><br><span class="line">(1 --&gt; 3): The sum is 4.</span><br><span class="line">There is no root-to-leaf path with sum = 5.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [], targetSum = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since the tree is empty, there are no root-to-leaf paths.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; sumStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        sumStack.push(root.val);</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sumStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum&amp;&amp;top.right==<span class="literal">null</span>&amp;&amp;top.left==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(top.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">                sumStack.push(sum+top.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">                sumStack.push(sum+top.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.cn/problems/path-sum-ii/"><strong>113. Path Sum II</strong></a></h2><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br><span class="line">Explanation: There are two paths whose sum equals targetSum:</span><br><span class="line">5 + 4 + 11 + 2 = 22</span><br><span class="line">5 + 8 + 4 + 5 = 22</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2], targetSum = 0</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h3 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; pathList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">            resultList.clear();</span><br><span class="line">            pathList.clear();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            traversal(root,targetSum - root.val);</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> ant)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;ant==<span class="number">0</span>)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(pathList)); <span class="comment">// !!</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pathList.add(root.left.val);</span><br><span class="line">                ant -= root.left.val;</span><br><span class="line">                traversal(root.left, ant);</span><br><span class="line">                ant += root.left.val;</span><br><span class="line">                pathList.remove(pathList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pathList.add(root.right.val);</span><br><span class="line">                ant -= root.right.val;</span><br><span class="line">                traversal(root.right, ant);</span><br><span class="line">                ant += root.right.val;</span><br><span class="line">                pathList.remove(pathList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-好好品"><a href="#2-好好品" class="headerlink" title="(2) 好好品"></a>(2) 好好品</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList ;</span><br><span class="line">        List&lt;Integer&gt; pathList ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">            resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pathList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">            traversal(root,targetSum);</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> ant)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            ant -= root.val;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;ant==<span class="number">0</span>)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(pathList));</span><br><span class="line">            &#125;</span><br><span class="line">            traversal(root.left, ant);</span><br><span class="line">            traversal(root.right, ant);</span><br><span class="line">            pathList.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：栈和队列</title>
      <link href="/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><blockquote><p>一开始小登自己认为，栈和队列不就是特殊一点的数组嘛，就是闭合了一端的数组。还不能通过下标索引进行检索（这个时候完全没想到，栈和队列里面的元素存储并不是连续的内存）</p></blockquote><h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyStack</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the top of the stack.</li><li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li><li><code>int top()</code> Returns the element on the top of the stack.</li><li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li><li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // return 2</span><br><span class="line">myStack.pop(); // return 2</span><br><span class="line">myStack.empty(); // return False</span><br></pre></td></tr></table></figure><h3 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_225</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; secQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            queue.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                secQueue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">top</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">while</span>(!secQueue.isEmpty())&#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> secQueue.poll();</span><br><span class="line">                queue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                secQueue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">peek</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">while</span>(!secQueue.isEmpty())&#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> secQueue.poll();</span><br><span class="line">                queue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(peek);</span><br><span class="line">            <span class="keyword">return</span> peek;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(myStack.top());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一个队列实现栈-使用逻辑长度"><a href="#一个队列实现栈-使用逻辑长度" class="headerlink" title="一个队列实现栈(使用逻辑长度)"></a>一个队列实现栈(使用逻辑长度)</h3><blockquote><p>其实完全不需要 使用额外一个队列进行备份。</p><p>完全可以弹出后再加入到队尾就行</p><p>使用<strong>size</strong>实现逻辑长度为1时弹出的就是栈顶</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           queue.offer(x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">           <span class="keyword">while</span>(size!=<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               queue.offer(poll);</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="keyword">return</span> pop;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span>  <span class="built_in">this</span>.pop();</span><br><span class="line">       queue.offer(top);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. Valid Parentheses</a></h2><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s &#x3D; “()”</p><p><strong>Output:</strong> true</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> s &#x3D; “()[]{}”</p><p><strong>Output:</strong> true</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s &#x3D; “(]”</p><p><strong>Output:</strong> false</p><p><strong>Example 4:</strong></p><p><strong>Input:</strong> s &#x3D; “([])”</p><p><strong>Output:</strong> true</p><h3 id="显而易见版"><a href="#显而易见版" class="headerlink" title="显而易见版"></a>显而易见版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">            LinkedList&lt;Character&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;&#123;&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    list.add(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Character</span> <span class="variable">top</span> <span class="operator">=</span> list.getLast();</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>显而易见版明显看着很多，代码感觉也很冗余。尤其是是要判断右括号的添加</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">            LinkedList&lt;Character&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list.isEmpty()||list.pop()!=c)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><p>You are given a string <code>s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</p><p>We repeatedly make <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p><p>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abbaca&quot;</span><br><span class="line">Output: &quot;ca&quot;</span><br><span class="line">Explanation: </span><br><span class="line">For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;azxxzy&quot;</span><br><span class="line">Output: &quot;ay&quot;</span><br></pre></td></tr></table></figure><h3 id="难受版（列表转字符串）"><a href="#难受版（列表转字符串）" class="headerlink" title="难受版（列表转字符串）"></a>难受版（列表转字符串）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           LinkedList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(list.getLast()==c)&#123;</span><br><span class="line">                       list.removeLast();</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       list.addLast(c);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   list.addLast(c);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span> (Character character : list) &#123;</span><br><span class="line">               sb.append(character);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用StringBuilder作为栈"><a href="#使用StringBuilder作为栈" class="headerlink" title="使用StringBuilder作为栈"></a>使用StringBuilder作为栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!sb.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(sb.charAt(sb.length()-<span class="number">1</span>)==c)&#123;</span><br><span class="line">                       sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       sb.append(c);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   sb.append(c);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p><p><strong>Note</strong> that:</p><ul><li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li><li>Each operand may be an integer or another expression.</li><li>The division between two integers always <strong>truncates toward zero</strong>.</li><li>There will not be any division by zero.</li><li>The input represents a valid arithmetic expression in a reverse polish notation.</li><li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">             <span class="keyword">if</span> (token.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(stack.pop() + stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(-stack.pop() + stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(stack.pop() * stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(num2 / num1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(Integer.parseInt(token));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return <em>the max sliding window</em>.</p><blockquote><p>首先滑动窗口就完全可以看作是一种队列。我们这个题要做到的就是，每次移动的时候都要弹出元素、放入元素、报告最大元素。</p><p>那我们可以维护一个队列用于存储最大值以及候选值。当很小的值弹出时这个队列不需要进行操作，只有当最大元素弹出或加入较大的元素时需要维护（通过比较放入到最大值&#x2F;候选值）</p></blockquote><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       LinkedList&lt;Integer&gt; queue =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> nums;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">               push(nums[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           list.add(getFront());</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; len; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(getFront()==nums[i-k])&#123;</span><br><span class="line">                   pop();;</span><br><span class="line">               &#125;</span><br><span class="line">               push(nums[i]);</span><br><span class="line">               list.add(getFront());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">           queue.removeFirst();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;queue.getLast()&lt;x)&#123;</span><br><span class="line">               queue.removeLast();</span><br><span class="line">           &#125;</span><br><span class="line">           queue.add(x);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><p><strong>Follow up:</strong> Your algorithm’s time complexity must be better than <code>O(n log n)</code>, where n is the array’s size.</p><h3 id="使用哈希表"><a href="#使用哈希表" class="headerlink" title="使用哈希表"></a>使用哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">           HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">              map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> map.entrySet().stream().sorted((m1, m2) -&gt; m2.getValue() - m1.getValue())</span><br><span class="line">                   .limit(k).mapToInt(Map.Entry::getKey).toArray();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用小顶堆"><a href="#使用小顶堆" class="headerlink" title="使用小顶堆"></a>使用小顶堆</h3><blockquote><p>优化点就是，我们不需要将全部元素都进行排序，只需要维护一个k大小的堆就行了。</p><p>使用小顶堆是因为我们每次淘汰的都是频率最小的元素。</p></blockquote><p><strong>有兴趣的可以了解一下堆的加入和去除元素（虽然一般数据结构课肯定会讲解的）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">          HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">             map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 使用小顶堆 (频率比较大小)</span></span><br><span class="line">          PriorityQueue&lt;<span class="type">int</span>[]&gt; queue =<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((prior1,prior2)-&gt;prior1[<span class="number">1</span>]-prior2[<span class="number">1</span>]); </span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">              <span class="keyword">if</span>(queue.size()&lt;k)&#123;</span><br><span class="line">                  queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(queue.peek()[<span class="number">1</span>]&lt;entry.getValue())&#123;</span><br><span class="line">                      queue.poll();</span><br><span class="line">                      queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">              result[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.cn/problems/simplify-path/">71. Simplify Path</a></h2><p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p><p>The <em>rules</em> of a Unix-style file system are as follows:</p><ul><li>A single period <code>&#39;.&#39;</code> represents the current directory.</li><li>A double period <code>&#39;..&#39;</code> represents the previous&#x2F;parent directory.</li><li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li><li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file</strong> <strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li></ul><p>The simplified canonical path should follow these <em>rules</em>:</p><ul><li>The path must start with a single slash <code>&#39;/&#39;</code>.</li><li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li><li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li><li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li></ul><p>Return the <strong>simplified canonical path</strong>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">          String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">          <span class="comment">// 去除空字符串 和 空格得到新的数组</span></span><br><span class="line">          String[] newSplit = Arrays.stream(split).map(String::trim).filter(s -&gt; !s.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !s.equals(<span class="string">&quot; &quot;</span>)).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">          LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (String s : newSplit) &#123;</span><br><span class="line">              <span class="keyword">if</span>(s.equals(<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                  <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                      stack.removeLast();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s.equals(<span class="string">&quot;.&quot;</span>))&#123;</span><br><span class="line">                  stack.add(s);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (String s : stack) &#123;</span><br><span class="line">              sb.append(<span class="string">&quot;/&quot;</span>).append(s);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">&quot;/&quot;</span>:sb.toString();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2024/12/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. Assign Cookies</a></h2><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2,3], s = [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2], s = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> len1=g.length;</span><br><span class="line">        <span class="type">int</span> len2=s.length;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i]&lt;=s[j]++)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.cn/problems/candy/">135. Candy</a></h2><p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ratings = [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ratings = [1,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.</span><br><span class="line">The third child gets 1 candy because it satisfies the above two conditions.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[]candies = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        Arrays.fill(candies,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                candies[i] = candies[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i-<span class="number">1</span>]&gt;ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(candies[i-<span class="number">1</span>]&lt;=candies[i])&#123;</span><br><span class="line">                candies[i-<span class="number">1</span>] = candies[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candies.length; i++) &#123;</span><br><span class="line">            sum+=candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. Non-overlapping Intervals</a></h2><p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p><p><strong>Note</strong> that intervals which only touch at a point are <strong>non-overlapping</strong>. For example, <code>[1, 2]</code> and <code>[2, 3]</code> are non-overlapping.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You don&#x27;t need to remove any of the intervals since they&#x27;re already non-overlapping.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end&gt;intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                end=Math.min(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="605-Can-Place-Flowers-Defensive-Programming"><a href="#605-Can-Place-Flowers-Defensive-Programming" class="headerlink" title="605. Can Place Flowers(Defensive Programming)"></a><a href="https://leetcode.cn/problems/can-place-flowers/">605. Can Place Flowers(Defensive Programming)</a></h2><p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <strong>adjacent</strong> plots.</p><p>Given an integer array <code>flowerbed</code> containing <code>0</code>‘s and <code>1</code>‘s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>new flowers can be planted in the</em> <code>flowerbed</code> <em>without violating the no-adjacent-flowers rule and</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="first-idea"><a href="#first-idea" class="headerlink" title="first idea"></a>first idea</h3><blockquote><p>Firstly, if we want to be Greedy, it is great way that planting the </p><p>flower when left and right is zero.</p><p>Off course, we can find a problem when we  coding it, we must notice the start and end of array.</p><p>Clearly, we can use a way named Defensive Programming</p><p>we can expand original array two capacity to get a new array </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> flowerbed.length;</span><br><span class="line">        <span class="type">int</span>[] newPlots = <span class="keyword">new</span> <span class="title class_">int</span>[length+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> newPlots.length;</span><br><span class="line">        newPlots[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        newPlots[len-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(flowerbed,<span class="number">0</span>,newPlots,<span class="number">1</span>,length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newPlots[i]!=<span class="number">1</span>&amp;&amp;newPlots[i-<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;newPlots[i+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                newPlots[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="second-idea"><a href="#second-idea" class="headerlink" title="second idea"></a>second idea</h3><blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [<span class="number">452.</span> Minimum Number of Arrows to Burst Balloons](https:<span class="comment">//leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a <span class="number">2D</span> integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You <span class="keyword">do</span> not know the exact y-coordinates of the balloons.</span><br><span class="line"></span><br><span class="line">Arrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` <span class="keyword">if</span> `xstart &lt;= x &lt;= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</span><br><span class="line"></span><br><span class="line">Given the array `points`, <span class="keyword">return</span> *the **minimum** number of arrows that must be shot to burst all balloons*.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**Example <span class="number">1</span>:**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Input: points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br>Output: 2<br>Explanation: The balloons can be burst by 2 arrows:</p><ul><li>Shoot an arrow at x &#x3D; 6, bursting the balloons [2,8] and [1,6].</li><li>Shoot an arrow at x &#x3D; 11, bursting the balloons [10,16] and [7,12].<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**Example 2:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>Input: points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br>Output: 4<br>Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**Example 3:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>Input: points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br>Output: 2<br>Explanation: The balloons can be burst by 2 arrows:</li><li>Shoot an arrow at x &#x3D; 2, bursting the balloons [1,2] and [2,3].</li><li>Shoot an arrow at x &#x3D; 4, bursting the balloons [3,4] and [4,5].</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### WTF</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinArrowShots(int[][] points) &#123;</span><br><span class="line">        int length = points.length;</span><br><span class="line">        if(length==0||length==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));</span><br><span class="line">        int end = points[0][1];</span><br><span class="line">        for (int i = 1; i &lt; points.length; i++) &#123;</span><br><span class="line">            if(points[i][0]&gt;end)&#123;</span><br><span class="line">                ans ++;</span><br><span class="line">                end = points[i][1];</span><br><span class="line">            &#125;else if(points[i][0]&lt;end)&#123;</span><br><span class="line">                end = Math.min(end,points[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a><a href="https://leetcode.cn/problems/partition-labels/">763. Partition Labels</a></h2><p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p><p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p><p>Return <em>a list of integers representing the size of these parts</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;eccbbbbdec&quot;</span><br><span class="line">Output: [10]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> []arrays  = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            arrays[c-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一直走，谁最后落点最大就走到哪</span></span><br><span class="line">            end = Math.max(end,arrays[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(end==i)&#123;</span><br><span class="line">                result.add(end-start+<span class="number">1</span>);</span><br><span class="line">                start = end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Total profit is 4 + 3 = 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                max += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h2><p>You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [hi, ki]</code> represents the <code>ith</code> person of height <code>hi</code> with <strong>exactly</strong> <code>ki</code> other people in front who have a height greater than or equal to <code>hi</code>.</p><p>Reconstruct and return <em>the queue that is represented by the input array</em> <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [hj, kj]</code> is the attributes of the <code>jth</code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">Explanation:</span><br><span class="line">Person 0 has height 5 with no other people taller or the same height in front.</span><br><span class="line">Person 1 has height 7 with no other people taller or the same height in front.</span><br><span class="line">Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.</span><br><span class="line">Person 3 has height 6 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.</span><br><span class="line">Person 5 has height 7 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span></span><br><span class="line">        <span class="comment">// 按照第一个元素降序排序得到(同时保证相同时，第二个元素升序)  [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span></span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;b[<span class="number">0</span>] != a[<span class="number">0</span>] ? b[<span class="number">0</span>]-a[<span class="number">0</span>] : a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 现在每个元素前面都是大于等于自己的元素</span></span><br><span class="line">        <span class="comment">// 7.0</span></span><br><span class="line">        <span class="comment">// 7,0 7,1</span></span><br><span class="line">        <span class="comment">// 7,0 6,1 7,1</span></span><br><span class="line">        <span class="comment">// 5,0 7,0 6,1 7,1</span></span><br><span class="line">        <span class="comment">// 5,0 7,0 5,2 6,1 7,1</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="665-Non-decreasing-Array"><a href="#665-Non-decreasing-Array" class="headerlink" title="665. Non-decreasing Array"></a><a href="https://leetcode.cn/problems/non-decreasing-array/">665. Non-decreasing Array</a></h2><p>Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most one element</strong>.</p><p>We define an array is non-decreasing if <code>nums[i] &lt;= nums[i + 1]</code> holds for every <code>i</code> (<strong>0-based</strong>) such that (<code>0 &lt;= i &lt;= n - 2</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,2,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,2,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You cannot get a non-decreasing array by modifying at most one element.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPossibility</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// flag 表示还能否进行交换</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> nums[<span class="number">0</span>] &lt;= nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="comment">//                    [3,4,2,3]</span></span><br><span class="line">                    <span class="comment">// 1 4 2</span></span><br><span class="line">                    <span class="comment">// 要么变大 i+1 要么 变小i</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&lt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        nums[i] = nums[i+<span class="number">1</span>]; <span class="comment">// 变小</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums[i+<span class="number">1</span>] = nums[i]; <span class="comment">// 变大</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ learn</title>
      <link href="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
      <url>/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ相关介绍"><a href="#RabbitMQ相关介绍" class="headerlink" title="RabbitMQ相关介绍"></a>RabbitMQ相关介绍</h1><p>最好的学习文档： <a href="https://www.rabbitmq.com/tutorials/tutorial-one-java">RabbitMQ 教程 - “Hello World！” |RabbitMQ 函数 — RabbitMQ tutorial - “Hello World!” | RabbitMQ</a></p><h2 id="什么是消息队列-为什么使用？"><a href="#什么是消息队列-为什么使用？" class="headerlink" title="什么是消息队列 &amp; 为什么使用？"></a>什么是消息队列 &amp; 为什么使用？</h2><blockquote><p>Message Queue</p></blockquote><p>顾名思义，存储消息的队列。</p><p>先来说说一个场景，以前送外卖的话或者送快递之类的，都是点到点，也就是快递小哥会直接送到你家，要是敲门发现不在，给你打个电话，此时你好像不得不回去？</p><p>其实先不说菜鸟驿站或者外卖柜。你们家家门口那块地就勉强算得上消息队列了，只不过不能保证安全，<del>其他人也可以消费</del>（bushi）</p><p>快递小哥只需要把快递放到你家门口，然后通过软件或者发短信，提醒你，就可以去干自己的事情了。而且你也不用马上去处理这个快递而打断当下做的事情。</p><blockquote><p><strong>什么是消息队列</strong><br>MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p></blockquote><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p><h3 id="各种知名消息队列优劣"><a href="#各种知名消息队列优劣" class="headerlink" title="各种知名消息队列优劣"></a>各种知名消息队列优劣</h3><h3 id="RabbitMQ-工作原理"><a href="#RabbitMQ-工作原理" class="headerlink" title="RabbitMQ 工作原理"></a>RabbitMQ 工作原理</h3><p> <img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121122826180.png" alt="image-20241121122826180"></p><ul><li>Broker: 消息队列服务进程</li><li>Exchange: 交换机，通过管道接受生产者信息，再通过一定规则将信息转发给某个队列（过滤消息）</li><li>Queue：消息队列，存储信息的队列，消息到达队列则会转发给指定的消费者</li><li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送</li><li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li></ul><h1 id="RabbitMQ-快速入门"><a href="#RabbitMQ-快速入门" class="headerlink" title="RabbitMQ 快速入门"></a>RabbitMQ 快速入门</h1><h2 id="六种消息模型"><a href="#六种消息模型" class="headerlink" title="六种消息模型"></a>六种消息模型</h2><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>简单队列： 简单的点对点服务</p><p><img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121123402772.png" alt="image-20241121123402772"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数1：队列名称   参数2：是否持久化  参数3：是否独占  参数4：是否自动删除  参数5：其他参数 比如 TTL 等</span></span><br><span class="line"><span class="comment">             * 创建队列</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> channel != <span class="literal">null</span>;</span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建会话通道，生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 实现消费方法</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 当接收到消息后此方法将被调用</span></span><br><span class="line">            <span class="comment">// 参数1：消费者标签 参数2：消息队列信息 参数3：消息属性 参数4：消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟异常</span></span><br><span class="line">    <span class="comment">//                int i = 1/0;</span></span><br><span class="line">                <span class="comment">// 交换机</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> envelope.getExchange();</span><br><span class="line">                <span class="comment">// 消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">// body 消息内容</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + msg + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动ack</span></span><br><span class="line">                <span class="comment">// 参数1：消息id，参数2：是否批量确认</span></span><br><span class="line"><span class="comment">//                multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数为是否自动确认，true表示自动确认 callback为回调函数</span></span><br><span class="line"><span class="comment">//        channel.basicConsume(QUEUE_NAME, true, consumer);</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><p>工作队列：一对多，分工合作消费</p><blockquote><p>The main idea behind Work Queues (aka: <em>Task Queues</em>) is to avoid doing a resource-intensive task immediately and having to wait for it to complete. Instead we schedule the task to be done later. We encapsulate a <em>task</em> as a message and send it to a queue. A worker process running in the background will pop the tasks and eventually execute the job. When you run many workers the tasks will be shared between them.</p></blockquote><p><img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121124223926.png" alt="image-20241121124223926"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkSend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span>  <span class="operator">=</span> <span class="string">&quot;task....&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            Thread.sleep(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkRecv1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception  &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 只接收一条未确认的消息</span></span><br><span class="line">      <span class="comment">//  channel.basicQos(1);</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, com.rabbitmq.client.Envelope envelope, com.rabbitmq.client.AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [Consumer 1] Received &#x27;&quot;</span> + msg + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line"><span class="comment">//        channel.basicConsume(QUEUE_NAME, true, consumer);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121125620346.png" alt="image-20241121125620346"></p><p><img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121125628037.png" alt="image-20241121125628037"></p><p>默认情况下这里会是C1和C2均摊消息进行消费，比如P发送50条，C1和C2各处理25条，但显然不太行（没有考虑C1和C2之间的设备性能差距等等）</p><p>所以可以通过设置</p><p><img src="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121124455468.png" alt="image-20241121124455468"></p><p>让消费者处理完一条消息之后再去接收消息进行消费而不是囤积</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><blockquote><p> Note about queue size</p><p>If all the workers are busy, your queue can fill up. You will want to keep an eye on that, and maybe add more workers, or have some other strategy.</p></blockquote><h4 id="ACK-机制"><a href="#ACK-机制" class="headerlink" title="ACK 机制"></a>ACK 机制</h4><p>消息一旦被消费者接收，队列中的消息就被删除了。RabbitMQ是通过何种机制呢？</p><p>如果有了解TCP的话，应该就会恍然大悟（并且本身Producer，Broker，Consumer也是通过TCP连接的）</p><p>当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p><ul><li>自动ACK：消息一旦被接收，消费者自动发送ACK</li><li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li></ul><p>这里需要考虑场景去判断选择哪种更好</p><ul><li>如果是牵扯到钱之类的，肯定是得手动消费，得等到相关业务完成之后再去发送ACK，不然中途要是崩了，数据库方面进行回滚，但是你自动Ack后这条消息就没了啊。</li><li>如果是不太重要的消息，无脑自动吧（额，阅历不够，不清楚那些算不重要）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">       channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动进行ACK</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                *  void basicAck(long deliveryTag, boolean multiple) throws IOException;</span></span><br><span class="line"><span class="comment">                *  deliveryTag:用来标识消息的id</span></span><br><span class="line"><span class="comment">                *  multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里的multiple 不就跟TCP 的S-ACK很像嘛，我觉得底层应该就是这个</p></blockquote><h2 id="Publish-SubScirbe"><a href="#Publish-SubScirbe" class="headerlink" title="Publish&#x2F;SubScirbe"></a>Publish&#x2F;SubScirbe</h2><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h3 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h3><blockquote><p>routingkey ,routing pattern</p></blockquote><p>Fanout: 广播，</p><p>Direct： 定向，</p><p>Topic： 通配符，</p><p>Header： （<a href="https://blog.csdn.net/zhu_tianwei/article/details/40923131%EF%BC%89">https://blog.csdn.net/zhu_tianwei/article/details/40923131）</a></p><h2 id="整合Springboot"><a href="#整合Springboot" class="headerlink" title="整合Springboot"></a>整合Springboot</h2><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>避免消息堆积？</p><p>1） 采用workqueue，多个消费者监听同一队列。</p><p>2）接收到消息以后，而是通过线程池，异步消费。</p><p>如何避免消息丢失？</p><p>1） 消费者的ACK机制。可以防止消费者丢失消息。</p><p>但是，如果在消费者消费之前，MQ就宕机了，消息就没了？</p><p>2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：哈希表</title>
      <link href="/2024/07/18/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/07/18/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录-哈希表篇"><a href="#代码随想录-哈希表篇" class="headerlink" title="代码随想录-哈希表篇"></a>代码随想录-哈希表篇</h1><p>在大学或者其他时候学习数据结构课程时。不难发现，算法发展都是由于对时间或者空间有较高的需求，从而一步步优化。在查询优化时，到二分法(  log(N)  )时，开始出现了瓶颈， 如何降到O(1)或者退而求其次追求O(2),O(3)呢？</p><p>在顺序查找和二分查找时，我们都是索引+关键字存储,那能不能直接使用关键字充当索引，那不就能直接O（1）了吗？</p><p>哈希表就是怎么个思想（个人这样想的）</p><p>要深入学习的话，可以考虑由这些方面入手：空间开辟大小、哈希函数（存储）、解决哈希冲突、底层原理等。</p><p>嘛，这里主要是入门一下，通过做题感受一下</p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><blockquote><p>这个题目给出的都是小写字母，所以在用go写的方法里面就更简单一些。额也因为Java写的不太好</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">           HashMap&lt;Character,Integer&gt;map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">               Character temp=s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(temp))&#123;</span><br><span class="line">                   map.put(temp,<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   map.put(temp, map.get(temp)+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++) &#123;</span><br><span class="line">               Character temp=t.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(temp))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   map.put(temp, map.get(temp)-<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    arrays :=[<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,val :=<span class="keyword">range</span> s &#123;</span><br><span class="line">        arrays[val-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,val :=<span class="keyword">range</span> t &#123;</span><br><span class="line">        arrays[val-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrays==[<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their</em> </p><p><em>intersection</em></p><p> Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">         <span class="keyword">if</span>(nums1.length==<span class="number">0</span>||nums1==<span class="literal">null</span>||nums2==<span class="literal">null</span>||nums2.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">        HashSet&lt;Integer&gt;set1=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt;set2=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">             set1.add(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">             <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                 set2.add(i);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> set2.stream().mapToInt(x-&gt;x).toArray();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums1) == <span class="number">0</span> || nums1 == <span class="literal">nil</span> || <span class="built_in">len</span>(nums2) == <span class="number">0</span> || nums2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line"><span class="keyword">if</span> _,ok := set[v];!ok&#123;</span><br><span class="line">set[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; ok &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, v)</span><br><span class="line"><span class="built_in">delete</span>(set, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.cn/problems/happy-number/">202. Happy Number</a></h2><p>Write an algorithm to determine if a number <code>n</code> is happy.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> n!=<span class="number">1</span> &amp;&amp; !set[n] &#123;</span><br><span class="line">        n,set[n] =getSum(n),<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n != <span class="number">0</span> &#123;</span><br><span class="line">sum+=(n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">n=n/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,4], target = 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,3], target = 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> preIndex, ok := set[target-val]; ok &#123;</span><br><span class="line">                <span class="comment">// 第一轮主要是去重，防止覆盖</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;preIndex, index&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 数组值为map的key，下标为map的值</span></span><br><span class="line">set[val] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 4Sum II</a></h2><p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>, nums3 []<span class="type">int</span>, nums4 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">hashmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">n := <span class="built_in">len</span>(nums1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="comment">// key放和，val放出现次数</span></span><br><span class="line">hashmap[nums1[i]+nums2[j]]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">count += hashmap[<span class="number">0</span>-(nums3[i]+nums4[j])]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.cn/problems/ransom-note/">383. Ransom Note</a></h2><p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> <em>if</em> <code>ransomNote</code> <em>can be constructed by using the letters from</em> <code>magazine</code> <em>and</em> <code>false</code> <em>otherwise</em>.</p><p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="type">string</span>, magazine <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">strMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">strMap[<span class="type">int</span>(magazine[i])]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line"><span class="keyword">if</span> strMap[<span class="type">int</span>(ransomNote[i])]==<span class="number">0</span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        strMap[<span class="type">int</span>(ransomNote[i])]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：链表</title>
      <link href="/2024/06/29/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/06/29/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="代码随想录—链表"><a href="#代码随想录—链表" class="headerlink" title="代码随想录—链表"></a>代码随想录—链表</h1><p>嗨嗨，越是到了期末周，越是想开摆。复习什么的，60分万岁吧。有些东西真不感兴趣了。</p><hr><p>这次是来到了链表篇（毕竟链表和数组在数据结构中很是重要）</p><p>这里我基本都是使用的迭代法（递归法得慢慢修炼修炼再考虑了）</p><p><strong>（从大一c语言学习的时候，就觉得大多数情况下都能约定好使用的是虚拟头结点就好了）</strong></p><p>所以推荐使用链表时都使用一个虚拟头结点（力扣人好像喜欢叫哑结点）</p><p>偶尔的话可以使用哨兵结点，用于减少判断条件或者越界</p><p>先大概概括一下基本题型吧</p><ul><li>链表的建立以及增删查改<ul><li>虚拟头结点的使用，temp临时指针等</li><li>边界条件判断（什么时候使用current !&#x3D;null 什么时候使用current.Next !&#x3D;null)</li><li>拓展： 双向链表，循环链表（记得试试约瑟夫环这个经典问题）</li></ul></li><li>反转链表<ul><li>原地反转（注意使用指针保存下一个结点）</li><li>新建头结点然后使用头插</li></ul></li><li>删除链表倒数第N个结点<ul><li>直接暴力，第一次先算链表长度，第二次遍历删除该结点</li><li>使用前后指针，先让快指针走N步，然后慢指针开始出发。</li></ul></li><li>判断是否有环<ul><li>让你判断是否有环<ul><li>快慢指针</li><li>哈希表</li></ul></li><li>寻找环的入口<ul><li>快慢指针</li><li>哈希表</li></ul></li></ul></li></ul><h2 id="链表基础-创建以及增删查改"><a href="#链表基础-创建以及增删查改" class="headerlink" title="链表基础(创建以及增删查改)"></a>链表基础(创建以及增删查改)</h2><p>力扣相关题目（也可以看看数据结构相关书籍，那边基础功能更多更全）</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">设计链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line">            <span class="built_in">this</span>.val =val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head =<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size|| index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode current=head;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=index)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">       addAtIndex(<span class="number">0</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">       addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         index = Math.max(<span class="number">0</span>, index);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        size++;</span><br><span class="line">        ListNode newNode=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        ListNode current=head;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">           i++;</span><br><span class="line">            current=current.next;</span><br><span class="line">       &#125;</span><br><span class="line">       newNode.next=current.next;</span><br><span class="line">       current.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size|| index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode current= head;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            current=current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next=current.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="type">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">head *ListNode</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line"><span class="keyword">return</span> MyLinkedList&#123;&amp;ListNode&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= l.size&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">current := l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=index;i++&#123;</span><br><span class="line">current = current.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> current.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtHead(val <span class="type">int</span>)&#123;</span><br><span class="line">l.AddAtIndex(<span class="number">0</span>,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtTail(val <span class="type">int</span>)&#123;</span><br><span class="line">l.AddAtIndex(l.size,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtIndex(index, val <span class="type">int</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> index &gt; l.size&#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">index =max(index,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//if index &lt; 0 &#123;</span></span><br><span class="line"><span class="comment">//index = 0</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">current :=l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;index;i++&#123;</span><br><span class="line">current = current.Next</span><br><span class="line">&#125;</span><br><span class="line">l.size++</span><br><span class="line"> toAdd := &amp;ListNode&#123;val, current.Next&#125;</span><br><span class="line"><span class="comment">//toAdd.Next=current.Next</span></span><br><span class="line">current.Next=toAdd</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> index &gt;=l.size || index &lt;<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">current :=l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;index;i++&#123;</span><br><span class="line">current=current.Next</span><br><span class="line">&#125;</span><br><span class="line">l.size--</span><br><span class="line">current.Next=current.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &gt; a &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表的反转"><a href="#链表的反转" class="headerlink" title="链表的反转"></a>链表的反转</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last=reverseList(head.next);</span><br><span class="line">        head.next.next=head;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span>head.next;</span><br><span class="line"></span><br><span class="line">   head.next=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   ListNode q;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">       q=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">       q.val=p.val;</span><br><span class="line"></span><br><span class="line">       q.next=head;</span><br><span class="line"></span><br><span class="line">       head=q;</span><br><span class="line"></span><br><span class="line">       p=p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> current !=<span class="literal">nil</span> &#123;</span><br><span class="line">        temp := current.Next</span><br><span class="line">        current.Next=pre</span><br><span class="line">        pre=current</span><br><span class="line">        current = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表倒数第N个结点"><a href="#删除链表倒数第N个结点" class="headerlink" title="删除链表倒数第N个结点"></a>删除链表倒数第N个结点</h2><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> * <span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> *     Val <span class="type">int</span></span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    demmyHead := &amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line">    fast,slow := demmyHead,demmyHead</span><br><span class="line">    f :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> f &lt; n &#123;</span><br><span class="line">        f++</span><br><span class="line">        fast=fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next!=<span class="literal">nil</span> &#123;</span><br><span class="line">        fast=fast.Next</span><br><span class="line">        slow=slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next=slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> demmyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表有环判断环入口问题"><a href="#链表有环判断环入口问题" class="headerlink" title="链表有环判断环入口问题"></a>链表有环判断环入口问题</h2><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    fast,slow := head ,head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next!=<span class="literal">nil</span> &amp;&amp; fast.Next.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            fast = head </span><br><span class="line">            <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">                    fast = fast.Next</span><br><span class="line">                    slow = slow.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span>  head;</span><br><span class="line">        Set&lt;ListNode&gt;hashSet =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(current))&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(current);</span><br><span class="line">            &#125;</span><br><span class="line">            current=current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    hashMap := <span class="keyword">map</span>[*ListNode]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    current := head </span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok :=hashMap[current]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap[current]=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="141-链表中环的检测"><a href="#141-链表中环的检测" class="headerlink" title="141.链表中环的检测"></a>141.链表中环的检测</h3><h3 id="21-两个有序链表的合并"><a href="#21-两个有序链表的合并" class="headerlink" title="21.两个有序链表的合并"></a>21.两个有序链表的合并</h3><h3 id="18-删除链表"><a href="#18-删除链表" class="headerlink" title="18.删除链表"></a>18.删除链表</h3><h3 id="876-求链表的中间结点"><a href="#876-求链表的中间结点" class="headerlink" title="876.求链表的中间结点"></a>876.求链表的中间结点</h3>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> java </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：数组篇</title>
      <link href="/2024/06/24/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
      <url>/2024/06/24/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数组篇总结"><a href="#数组篇总结" class="headerlink" title="数组篇总结"></a>数组篇总结</h1><p>首先跟着代码随想录刷了一刷，大概接触到题型有二分法、移除元素&#x2F;排序、滑动窗口、模拟行为</p><ul><li><p>二分法</p><ul><li>确定好左右边界，以及mid的变化就好</li></ul></li><li><p>移除元素</p><ul><li>for循环暴力！</li><li>快慢指针： 快指针去探索找寻符合条件的宝藏，然后交给慢指针</li><li>使用堆栈或者队列</li></ul></li><li><p>排序</p><ul><li>首尾双指针</li></ul></li><li><p>滑动窗口</p><ul><li>双层for循环暴力！ 其实这种也是滑动窗口，只是完全是无脑滑动（以边界条件为条件）</li><li>双指针滑动，两个for循环（上面是n*n，这个是2n），且移动条件为场景需求条件（使用hashmap进行维护）</li></ul></li><li><p>模拟行为</p><ul><li>害。。听天由命，画图吧。</li></ul></li></ul><p>可能这里更多的是用go去实现吧，因为go语言我也是刚学，然后语法都不太稳固那种，更别说使用什么api了，所以感觉就是算法和go都拿。有思路但是go很卡壳的话就先用Java写一下然后查go的语法然后用go写</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;本题目有着月份的跨越，所以java版本思路和go差别还是有的。Java是二分找到一次后左右依次扩张（顺序遍历），而go版本是继续使用二分去左右扩张</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>&amp;&amp;nums[left]==nums[right]&amp;&amp;nums[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="type">int</span> l=mid;</span><br><span class="line">                <span class="type">int</span> r=mid;</span><br><span class="line">                <span class="keyword">while</span>(l&gt;=left&amp;&amp;nums[l]==target)&#123;</span><br><span class="line">                    l--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(r&lt;=right&amp;&amp;nums[r]==target)&#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++l,--r&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid]) &#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">     left := searchLeft(nums,target)</span><br><span class="line">     <span class="keyword">if</span> left==<span class="built_in">len</span>(nums)||nums[left]!=target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    right := searchRight(nums,target)</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left,right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchLeft</span><span class="params">(nums[]<span class="type">int</span>,target <span class="type">int</span>)</span></span><span class="type">int</span> &#123;</span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right&#123;</span><br><span class="line">        mid:=(left+right)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target&#123;</span><br><span class="line">            right=mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target &#123;</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRight</span><span class="params">(nums[]<span class="type">int</span>,target <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">     left,right:=<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right&#123;</span><br><span class="line">        mid:=(left+right)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target&#123;</span><br><span class="line">            left=mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    slow:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast:=<span class="number">0</span>;fast&lt;<span class="built_in">len</span>(nums);fast++&#123;</span><br><span class="line">        <span class="comment">// 由fast开路</span></span><br><span class="line">        <span class="keyword">if</span> nums[fast]!=<span class="number">0</span> &#123;</span><br><span class="line">            nums[slow],nums[fast] = nums[fast],nums[slow]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h3><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;ac&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a#c&quot;, t = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 200</code></li><li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> indexS=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> indexT=t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> skipS=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> skipT=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(indexS&gt;=<span class="number">0</span>||indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(indexS&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(indexS)==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipS++;</span><br><span class="line">                    indexS--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                    indexS--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(t.charAt(indexT)==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipT++;</span><br><span class="line">                    indexT--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipT&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    indexT--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(indexS&gt;=<span class="number">0</span>&amp;&amp;indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(indexS)!=t.charAt(indexT))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(indexS&gt;=<span class="number">0</span>||indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indexS--;</span><br><span class="line">            indexT--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backspaceCompare</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    skipS,skipT := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    i,j := <span class="built_in">len</span>(s)<span class="number">-1</span>,<span class="built_in">len</span>(t)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i&gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">&#x27;#&#x27;</span>&#123;</span><br><span class="line">                skipS++</span><br><span class="line">                i--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> skipS&gt;<span class="number">0</span>&#123;</span><br><span class="line">                skipS--</span><br><span class="line">                i--</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j&gt;= <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> t[j]==<span class="string">&#x27;#&#x27;</span>&#123;</span><br><span class="line">                skipT++</span><br><span class="line">                j--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> skipT &gt; <span class="number">0</span>&#123;</span><br><span class="line">                skipT--</span><br><span class="line">                j--</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(temp)<span class="number">-1</span></span><br><span class="line">i := right</span><br><span class="line"><span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line"><span class="keyword">if</span> -nums[left] &gt; nums[right] &#123;</span><br><span class="line">temp[i] = nums[left] * nums[left]</span><br><span class="line">            left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[i] = nums[right] * nums[right]</span><br><span class="line">            right--</span><br><span class="line">&#125;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n :=<span class="built_in">len</span>(nums)</span><br><span class="line">length := n+<span class="number">1</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; right &lt; n; right++ &#123;</span><br><span class="line">sum += nums[right]</span><br><span class="line"><span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">sum -= nums[left]</span><br><span class="line"><span class="keyword">if</span> length &gt; right-left + <span class="number">1</span> &#123;</span><br><span class="line">                length = right-left +<span class="number">1</span></span><br><span class="line">            &#125; </span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; n&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">left := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right, value := <span class="keyword">range</span> fruits &#123;</span><br><span class="line">cnt[value]++</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cnt) &gt; <span class="number">2</span> &#123;</span><br><span class="line">d := fruits[left]</span><br><span class="line">left++</span><br><span class="line">cnt[d]--</span><br><span class="line"><span class="keyword">if</span> cnt[d] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(cnt, d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, right-left+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="坑爹的模拟行为"><a href="#坑爹的模拟行为" class="headerlink" title="坑爹的模拟行为"></a>坑爹的模拟行为</h2><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][]matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bottom=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>,pow =n*n;</span><br><span class="line">        <span class="keyword">while</span>(ans&lt;=pow)&#123;</span><br><span class="line">            <span class="comment">// 顶</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++) matrix[top][i]=ans++;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++) matrix[i][right]=ans++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 底</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)matrix[bottom][i]=ans++;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--) matrix[i][left]=ans++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">loop := <span class="number">1</span>   </span><br><span class="line">offset := <span class="number">1</span> </span><br><span class="line">startX, startY := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">ans := <span class="number">1</span> </span><br><span class="line">arrays := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> arrays &#123;</span><br><span class="line">arrays[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> loop &lt;= n/<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 顶部</span></span><br><span class="line"><span class="keyword">for</span> ; startY &lt; n-offset; startY++ &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边</span></span><br><span class="line"><span class="keyword">for</span> ; startX &lt; n-offset; startX++ &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底部</span></span><br><span class="line"><span class="keyword">for</span> ; startY &gt;= offset; startY-- &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">for</span> ; startX &gt;= offset; startX-- &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">startX++</span><br><span class="line">startY++</span><br><span class="line">loop++</span><br><span class="line">offset++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrays</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">lenX := <span class="built_in">len</span>(matrix)</span><br><span class="line"><span class="keyword">if</span> lenX == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">lenY := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> lenY == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top, right, bottom, left := <span class="number">0</span>, lenY<span class="number">-1</span>, lenX<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">total := lenX * lenY</span><br><span class="line">arrays := <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ans &lt; total &#123;</span><br><span class="line"><span class="comment">// 顶</span></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right &amp;&amp; ans &lt; total; i++ &#123;</span><br><span class="line">arrays[ans] = matrix[top][i]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">top++</span><br><span class="line"><span class="comment">// 右</span></span><br><span class="line"><span class="keyword">for</span> i := top; i &lt;= bottom &amp;&amp; ans &lt; total; i++ &#123;</span><br><span class="line">arrays[ans] = matrix[i][right]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line"><span class="comment">// 底</span></span><br><span class="line"><span class="keyword">for</span> i := right; i &gt;= left &amp;&amp; ans &lt; total; i-- &#123;</span><br><span class="line">arrays[ans] = matrix[bottom][i]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">bottom--</span><br><span class="line"><span class="keyword">for</span> i := bottom; i &gt;= top &amp;&amp; ans &lt; total; i-- &#123;</span><br><span class="line">arrays[ans] = matrix[i][left]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrays</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arrays := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">5</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;</span><br><span class="line">order := spiralOrder(arrays)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="built_in">print</span>(order[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> java </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
