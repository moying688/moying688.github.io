<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库事务隔离等级</title>
      <link href="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7/"/>
      <url>/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>持续更新以及完善中…………………</p><h1 id="数据库事务隔离"><a href="#数据库事务隔离" class="headerlink" title="数据库事务隔离"></a>数据库事务隔离</h1><p>首先，为什么要有事务隔离呢？</p><p>在单线程下，没什么大碍，但是我们想要提高效率，采用多线程并发时，便会出现一些问题。</p><p><strong>下面的问题一定要当作一个事务来看待！！！！</strong>不要觉得连续两次查询就是一次事务了，这里的两次查询是处于同一个事务，你可以当作两次查询一次是写在函数开头，一次是写在了函数末尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">()</span>&#123;</span><br><span class="line">    selectBySql();</span><br><span class="line">    </span><br><span class="line">    .....干了其他事情，或者没干。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    selectBySql();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>脏写</li></ul><p>A有100块，现在给自己又转了20（就变成120了），现在B给A转了20块（变成了140），但是A转给自己20的事务因为某些原因出错导致回滚，又变成了100块。导致B不管先一步提交（120）还是后一步提交（140），都不是120块。</p><ul><li>脏读</li></ul><p>A转给自己20块，B读取了A资产发现有120块，但是A又因为某些问题导致回滚，B再去读A的资产发现变成了100块</p><ul><li>不可重复读</li></ul><p><img src="E:\play\Butterfly\source_posts\数据库\数据库四种隔离等级.assets\image-20240609160520923.png" alt="image-20240609160520923"></p><ul><li>幻读</li></ul><p>A查询比自己财产更多的用户，发现只有C用户。</p><p>这个时候B和D用户开了账户，并转了很多钱进去。</p><p>A再次查询比自己财产更多的用户，发现出现了C，B，D用户（这是上次读取时未出现过的啊）</p><h2 id="read-uncommit（读未提交）"><a href="#read-uncommit（读未提交）" class="headerlink" title="read uncommit（读未提交）"></a>read uncommit（读未提交）</h2><p>Oracle默认隔离规则。（效率高）</p><p>读数据不需要锁，写数据需要锁。</p><p>解决了脏写问题（写操作互斥）</p><p>但是出现脏读问题。</p><h2 id="read-commit（读已提交）"><a href="#read-commit（读已提交）" class="headerlink" title="read commit（读已提交）"></a>read commit（读已提交）</h2><p>MySQL默认隔离规则（效率较高）。</p><p>只有更新事务成功提交,才能查询到本次更新.</p><p>A转账给自己20(初始100块),必须提交成功,其他人查询A的资产时才能看到120块.</p><p>解决脏读问题.</p><h1 id="插播一条（MVCC）"><a href="#插播一条（MVCC）" class="headerlink" title="插播一条（MVCC）"></a>插播一条（MVCC）</h1><p>MVCC</p><blockquote><p>mutil version concurrent control</p></blockquote><p>多版本并发控制，同一时刻同一条记录在系统中可以存在多个版本</p><p>只有当写数据事务提交时，才能读到最新的数据。</p><p>通过Read View （一致性视图）。</p><p>害，东西太多太多了，本人现在的理解就是。</p><p>初始阶段，A的资产记录是version1.0。  A执行更新的事务（更新到version2.0），然后B去读A的资产，只要是A执行更新事务没有提交，只能读到version1.0的数据。当A回滚时不会出现问题，当A提交后数据库中A资产数据更新到version2.0，但B需要提交本次查询事务，在下一次查询的时候才能看到version2.0的数据…</p><h2 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a><strong>REPEATABLE READ</strong>（可重复读）</h2><p>在整个事务过程中该事务看到的记录，自始至终都是一样的。</p><p>A转账给自己20(初始100块),必须提交成功</p><p>其他人查询A的资产时的事务也提交后,随后的查询事务才能读取到120块.</p><h2 id="serializable-（串行）"><a href="#serializable-（串行）" class="headerlink" title="serializable （串行）"></a><strong>serializable （串行）</strong></h2><p>解决所有问题。但是效率最低，无并发，读和写都需要上锁。</p><h1 id="画饼"><a href="#画饼" class="headerlink" title="画饼"></a>画饼</h1><hr><p>看到舍友们在复习数据库期末考试, 然后想到上学期学的时候对于事务以及并发这里学校并未怎么讲到.</p><p>然后学后端现在也开始进入到处理分布式,并发这些问题了.</p><p>先给自己挖一个数据库学习的坑吧.</p>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API开放平台</title>
      <link href="/2024/06/04/API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
      <url>/2024/06/04/API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="API开放平台"><a href="#API开放平台" class="headerlink" title="API开放平台"></a>API开放平台</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>做一个提供API接口调用的平台，用户可以注册登录，开通接口调用权限。用户可以使用接口，并且每次调用会进行统计。管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据</p><p>背景：</p><ol><li>前端开发需要用到后台接口</li><li>使用现成的接口（<a href="https://api.btstu.cn/%EF%BC%89">https://api.btstu.cn/）</a></li></ol><p><img src="E:\play\Butterfly\source_posts\API开放平台.assets\image-20240604181727464.png" alt="image-20240604181727464"></p><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>做一个API接口平台</p><ol><li>防止攻击（安全性）</li><li>不能随便调用（限制、开通）</li><li>计费</li><li>统计调用次数</li><li>流量保护</li><li>API接入</li></ol><p> 1、SDK的外语全称是Software Development Kit，中文为：软件开发工具包，一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合；</p><p>　　2、可以将其理解为，由第三方服务商提供的实现软件产品某项功能的工具包，里面一般以集合kpi和文档、范例、工具的形式出现，也就是由很多类型文件的集合；</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>Ant Design Pro</p><p>React </p><p>Ant Design Procomoponents </p><p>Umi</p><p>Umi Request (Axios封装)</p><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>Java Spring Boot</p><p>Spring Boot Starter(SDK开发)</p><p>？？？（网关、限流、日志实现）</p><h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><ul><li>项目介绍、设计、技术选型</li><li>基础项目搭建</li><li>接口管理</li><li>用户查看接口</li></ul><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><ul><li>接口调用</li><li>接口文档展示、接口在线调用</li><li>保证调用的安全性（API签名认证）</li><li>客户端SDK的开发</li></ul><h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><ul><li>统计用户调用次数</li><li>限流、计费、日志、开通</li></ul><h4 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h4><ul><li>提供可视化平台，用图表的方式展示所有接口的调用情况，便于调整</li><li>自己实现：预警</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>1、管理员可以对接口信息进行增删查改</p><p>2、用户可以访问前台，查看接口信息</p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h4><p>id</p><p>userId 创建人id</p><p>name 接口名称</p><p>description 描述</p><p>url 请求地址</p><p>method 请求类型</p><p>requestHeader 请求头</p><p>responseHeader 响应头</p><p>status 接口状态 0-关闭 1-开启</p><ul><li><p>isDelete</p></li><li><p>creatTime</p></li><li><p>updateTime</p></li></ul><p>使用其他类似的Controller进行快速开发（copy）</p><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><p>前端：ant design pro脚手架</p><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><p>增删查改、登录（以及校验）</p><p>前端接口调用：oneapi插件自动生成</p><p>openapi规范</p><h2 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h2><p>模拟接口项目myapi-interface</p><p>提供三个模拟接口</p><ol><li>GET接口</li><li>POST接口（url传参）</li><li>POST接口（restful）</li></ol><h3 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h3><p>几种HTTP调用方式：</p><ol><li>HttpClient</li><li>RestTemplate</li><li>第三方库（OKHttp，Hutool）</li></ol><p><a href="https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil">https://hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil</a></p><h3 id="API-签名认证"><a href="#API-签名认证" class="headerlink" title="API 签名认证"></a>API 签名认证</h3><p>本质：</p><ol><li>签发签名</li><li>使用签名（校验）</li></ol><p>为什么需要？</p><ol><li>保证安全性，不能随便一个人调用</li></ol><h4 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h4><p>通过http request header 头传递参数</p><p><strong>参数1：accessKey： 调用标识 （复杂无序无规律）</strong></p><p><strong>参数2：secretKey：  密钥</strong> （不放到请求头中）</p><p>（类比用户名和密码，区别：ak，sk是无状态的）</p><p>千万不能把密钥直接在服务器之间传递，也可能会被拦截</p><p><strong>参数3：用户参数</strong></p><p><strong>参数4：sign</strong> </p><p>加密方式：对称加密、非对称加密、md5签名（不可逆）</p><p>用户参数： abc  +  密钥 &#x3D;&gt; 签名生成算法(MD5,Hmac) &#x3D; &gt; 不可解密的值</p><p>abc +  abcdefg &#x3D;》 osidjfoasipdf</p><p>那服务端怎么知道签名是否正确？</p><p><strong>服务端用一模一样的参数和算法去生成签名，只要和用户传的一致，就表示一致。</strong></p><h5 id="怎么防重放？"><a href="#怎么防重放？" class="headerlink" title="怎么防重放？"></a>怎么防重放？</h5><p><strong>参数5：加nonce 随机数，只能用一次</strong></p><p>​     但服务端要保存用过的随机数</p><p><strong>参数6：加一个timestamp 时间戳。校验时间戳是否过期。</strong></p><p>API 签名认证是一个很灵活的设计，具体要有哪些参数、参数名如何一定要根据场景来。（比如userId、appId、version）</p><p>难道每次开发者调用接口都要自己写签名算法？</p><h3 id="开发一个简单易用的SDK"><a href="#开发一个简单易用的SDK" class="headerlink" title="开发一个简单易用的SDK"></a>开发一个简单易用的SDK</h3><p>理想情况：开发者只需要关心调用哪些接口，传递哪些参数，就跟调用自己写的代码一样。</p><p>开发starter的好处：</p><ol><li>开发者引入后，可以直接在application.yml中写配置。自动创建客户端</li></ol><p>自动生成代码提示</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span> 3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; TODO 之后可以把打好的包上传到maven仓库</p><h2 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h2><ol><li>开发接口发布&#x2F;下线的功能（管理员）</li><li>前端去浏览接口、查看接口文档、申请签名（注册）</li><li>在线调试（用户）</li><li>统计用户调用接口次数</li><li>优化系统-API网关</li></ol><h3 id="开发接口发布-下线功能（管理员）"><a href="#开发接口发布-下线功能（管理员）" class="headerlink" title="开发接口发布&#x2F;下线功能（管理员）"></a>开发接口发布&#x2F;下线功能（管理员）</h3><p>后台接口：</p><p>发布接口：</p><ol><li>校验接口是否存在</li><li>判断接口是否可用</li><li>修改接口数据库中状态字段为1</li></ol><p>下线接口：</p><ol><li>校验接口是否存在</li><li>修改接口数据库中状态字段为0</li></ol><p>扩展：用户可以申请更换签名</p><p>在线调用</p><p>请求参数的类型（直接用JSON类型）</p><p>流程：</p><ol><li>前端将用户输入的请求参数和要测试的接口id发给平台后端1</li><li>在调用前可以做一些校验</li><li>平台后端去调用模拟接口</li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ol><li>判断该接口是否可以调用时，由固定方法名改为请求地址</li><li>用户测试接口也是这样优化</li><li>模拟接口改为从数据库校验 ak ，sk</li></ol><h2 id="第四阶段-1"><a href="#第四阶段-1" class="headerlink" title="第四阶段"></a>第四阶段</h2><ol><li>开发接口调用次数的统计</li><li>优化整个系统的架构（API 网关）<ol><li>网关是什么？</li><li>网关作用？</li><li>网关的应用场景以及实现</li><li>结合业务去应用网关</li></ol></li></ol><h3 id="接口调用次数统计"><a href="#接口调用次数统计" class="headerlink" title="接口调用次数统计"></a>接口调用次数统计</h3><p>需求：</p><ol><li>用户每次调用接口成功，次数 + 1</li><li>给用户分配或用户自主申请接口调用次数</li></ol><p>业务流程：</p><ol><li>用户调用接口（之前已完成）</li><li>修改数据库，调用次数+1</li></ol><p>设计库表</p><p>哪个用户？哪个接口？</p><p>用户 &lt;&#x3D;&gt; 接口(N &#x3D; N)</p><h4 id="用户调用接口关系表："><a href="#用户调用接口关系表：" class="headerlink" title="用户调用接口关系表："></a>用户调用接口关系表：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table if not exists API_db.`user_interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` bigint not null auto_increment comment &#x27;主键&#x27; primary key,</span><br><span class="line">    `userId` bigint not null comment &#x27;调用用户id&#x27;,</span><br><span class="line">    `interfaceInfoId` bigint not null comment &#x27;接口id&#x27;,</span><br><span class="line">    `totalNum` int default 0 not null comment &#x27;总调用次数&#x27;,</span><br><span class="line">    `leftNum` int default 0 not null comment &#x27;剩余调用次数&#x27;,</span><br><span class="line">`status` int default 0 not null comment &#x27;0-正常 1-禁用&#x27;,</span><br><span class="line">    `createTime` datetime default CURRENT_TIMESTAMP not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#x27;更新时间&#x27;,</span><br><span class="line">    `isDelete` tinyint default 0 not null comment &#x27;是否删除(0-未删, 1-已删)&#x27;</span><br><span class="line">) comment &#x27;用户调用接口关系表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开发增删查改功能给管理员</p><p>用户调用接口后次数加1</p><p>问题：</p><p>如果每个接口的方法都写调用次数+1，是不是比较麻烦?</p><p>致命问题：接口开发者需要自己去统计</p><ol><li>AOP</li><li>写一个通用方法，用到就调用</li><li>servlet 拦截器</li></ol><p>AOP，独立于接口，在每个接口调用后统计次数+1</p><p>缺点：只存在于单个项目中，如果每个团队都开发自己的模拟接口，都需要调用AOP所在的项目</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>什么是网关？理解为门卫老大爷，需要<strong>统一</strong>经过审查才能进门。</p><p>网关优点：统一去进行一些操作、处理一些问题</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>路由</li><li>负载均衡</li><li>鉴权</li><li>跨域</li><li>缓存</li><li>流量染色</li><li>访问控制</li><li>统一业务处理</li><li>发布控制</li><li>接口保护<ol><li>限制请求</li><li>消息脱敏</li><li>降级（熔断）</li><li>限流： 学习令牌桶算法，学习redisRateLimiter</li><li>超时时间</li></ol></li><li>统一日志</li><li>统一文档</li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>起到转发的作用，比如有接口a，接口b。网关会记录这些信息，根据用户访问的地址和参数，</p><p>转发请求到对应的接口（服务器&#x2F;集群）</p><p>&#x2F;a &#x3D;&gt; interface a</p><p>&#x2F;b &#x3D;&gt; interface b</p><p>&#x2F;c &#x3D;&gt; interface c</p><p>断言路由 predicate</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在路由的基础上</p><p>&#x2F;c&#x3D;&gt; 服务a&#x2F;集群a</p><h3 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h3><p>判断用户是否有权限进行操作。无论访问什么接口，我都去统一去判断权限，不用重复写。</p><h3 id="统一跨域"><a href="#统一跨域" class="headerlink" title="统一跨域"></a>统一跨域</h3><p>网关统一处理跨一，不用在每个项目里单独处理</p><p><a href="https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/cors-configuration.html">CORS Configuration :: Spring Cloud Gateway</a></p><h3 id="统一业务处理"><a href="#统一业务处理" class="headerlink" title="统一业务处理"></a>统一业务处理</h3><p>AOP plus版？</p><p>把一些项目中都要做的通用1逻辑放到上层（网关）。统一处理，例如本次的统计调用次数</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>黑白名单，比如限制DDOS IP</p><h3 id="发布控制"><a href="#发布控制" class="headerlink" title="发布控制"></a>发布控制</h3><p>灰度发布，比如上线新接口，先给新接口分配20%的流量，然后慢慢调正比例</p><p>version1.0  version2.0 等2.0版本稳定后，逐渐给更多用户使用，然后逐渐覆盖迭代掉1.0</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weighthigh.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weightlow.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="流量染色"><a href="#流量染色" class="headerlink" title="流量染色"></a>流量染色</h3><p>给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头。链路追踪</p><p>例如：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/addrequestheader-factory.html">AddRequestHeader GatewayFilter Factory :: Spring Cloud Gateway</a></p><p>全局染色：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/default-filters.html">Default Filters :: Spring Cloud Gateway</a></p><h3 id="统一接口保护"><a href="#统一接口保护" class="headerlink" title="统一接口保护"></a>统一接口保护</h3><ol><li>限制请求</li><li>消息脱敏</li><li>降级（熔断）</li><li>限流</li><li>超时时间</li></ol><h3 id="统一日志"><a href="#统一日志" class="headerlink" title="统一日志"></a>统一日志</h3><p>统一的请求、响应信息记录</p><h3 id="统一文档"><a href="#统一文档" class="headerlink" title="统一文档"></a>统一文档</h3><p>将下游项目的文档进行聚合，方便管理查看</p><h2 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h2><ol><li>业务网关（微服务网关）：作用是将请求转发到不同的业务&#x2F;项目&#x2F;接口&#x2F;服务</li><li>全局网关（接入层网关）：作用是负载均衡、请求日志等，不和业务逻辑绑定</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>Nginx (全局网关)\ Kong网关(API网关)</li><li>SpringCloud GateWay( 取代了Zuul ) 性能高, 可以用Java代码写逻辑</li></ol><p><a href="https://zhuanlan.zhihu.com/p/500587132">https://zhuanlan.zhihu.com/p/500587132</a></p><h2 id="Spring-Cloud-GateWay"><a href="#Spring-Cloud-GateWay" class="headerlink" title="Spring Cloud GateWay"></a>Spring Cloud GateWay</h2><p><a href="https://spring.io/projects/spring-cloud-gateway/">Spring Cloud Gateway</a>（demo）</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">Spring Cloud Gateway</a>（详细）</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>路由（根据说明条件，转发请求到哪里）</p><p>断言（一组规则或者条件，用来确定如何转发规则）</p><p>过滤器：对一系列请求或者响应进行处理，比如添加请求、请求参数</p><p><img src="https://docs.spring.io/spring-cloud-gateway/reference/_images/spring_cloud_gateway_diagram.png" alt="image"></p><p>官方文档：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/reference/">Spring Cloud Gateway :: Spring Cloud Gateway</a></p><h3 id="两种配置方式"><a href="#两种配置方式" class="headerlink" title="两种配置方式"></a>两种配置方式</h3><ol><li>配置式（方便、规范）<ol><li>简化版</li><li>全称</li></ol></li><li>编程式（灵活、相对麻烦）</li></ol><p><img src="E:\play\Butterfly\source_posts\API开放平台.assets\image-20240608184013176.png" alt="image-20240608184013176"></p><p>可以保护后台接口url</p><p><strong>建议开启日志</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">cloud:</span> </span><br><span class="line">          <span class="attr">gateway:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure><h4 id="断言有很多规则"><a href="#断言有很多规则" class="headerlink" title="断言有很多规则"></a>断言有很多规则</h4><ol><li>After</li><li>Before</li><li>…..</li></ol><p><img src="E:\play\Butterfly\source_posts\API开放平台.assets\image-20240608184151217.png" alt="image-20240608184151217"></p><p>推荐自己先好好看看官方文档，知道大概有哪些东西。</p><p>顺便记得把simple  demo看看</p><p><a href="https://github.com/spring-cloud/spring-cloud-gateway">spring-cloud&#x2F;spring-cloud-gateway: An API Gateway built on Spring Framework and Spring Boot providing routing and more. (github.com)</a></p><h2 id="第五阶段："><a href="#第五阶段：" class="headerlink" title="第五阶段："></a>第五阶段：</h2><ol><li>实现统一的用户鉴权。把API网关应用到项目中</li><li>完善功能</li></ol><h4 id="要用到的特性"><a href="#要用到的特性" class="headerlink" title="要用到的特性"></a>要用到的特性</h4><ol><li>路由 （转发请求到模拟接口项目）</li><li><del>负载均衡</del></li><li>鉴权 （accessKey，secretKey）</li><li>跨域  （看情况）</li><li>流量染色 （记录请求是否为网关来的）</li><li>访问控制 (黑白名单) </li><li>统一业务处理 （每次请求接口后次数＋1）</li><li><del>发布控制</del> </li><li>接口保护<ol><li>限制请求</li><li>消息脱敏</li><li>降级（熔断）</li><li>限流： 学习令牌桶算法、学习漏桶算法。学习redisRateLimiter</li><li>超时时间</li></ol></li><li>统一日志 （记录每次的请求和响应日志）</li><li>统一文档</li></ol><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><ol><li><p>用户发送请求到API网关</p></li><li><p>请求日志</p></li><li><p>（黑白名单）</p></li><li><p>用户鉴权，判断Ak，Sk是否合法</p></li><li><p>请求的模拟接口是否存在？</p></li><li><p>请求转发、调用模拟接口</p></li><li><p>响应日志</p></li><li><p>调用成功，调用次数加1</p></li><li><p>调用失败，返回一个规范的错误码</p></li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-请求转发"><a href="#1-请求转发" class="headerlink" title="1.请求转发"></a>1.请求转发</h3><p>使用前缀匹配断言：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">path_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有路径为：&#x2F;api&#x2F;<strong>的请求进行转发。转发到  http :&#x2F;&#x2F;localhost:8123&#x2F;api&#x2F;</strong></p><p>比如请求：</p><p>http :&#x2F;&#x2F;localhost:8090&#x2F;api&#x2F;name&#x2F;get?name&#x3D;moying</p><p>转发到</p><p>http :&#x2F;&#x2F;localhost:8123&#x2F;api&#x2F;name&#x2F;get?name&#x3D;moying</p><h3 id="2-全局过滤器"><a href="#2-全局过滤器" class="headerlink" title="2.全局过滤器"></a>2.全局过滤器</h3><p>类似于AOP？建议看看流程图</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GlobalFilter <span class="title function_">customFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomGlobalFilter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;custom global filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//数字越小越优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为网关项目没有引入Mybatis等操作数据库的类库，如果操作较为复杂，可以由backend增删查改项目提供接口，我们直接调用。就不用重复写逻辑了</p><ul><li>HTTP请求（用HTTPClient、RestTemplate、Feign、OpenFeign）</li><li>RPC（Dubbo）</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>预期是等模拟接口调用完成，才记录响应日志、统计调用次数</p><p>但是现实是chain.filter方法立刻返回了，直到filter过滤器return后才调用了模拟接口。</p><p>原因是：chain.filter是个异步操作？（看上面的流程图）</p><p>解决方案：利用二response装饰者，增强原有对象response的能力</p><h2 id="第六阶段"><a href="#第六阶段" class="headerlink" title="第六阶段"></a>第六阶段</h2><p><strong>计划</strong></p><ol><li>补充完整网关的业务逻辑（怎么去操作数据库、怎么复用之前的方法？RPC）</li><li>完善系统、开发一个监控统计功能</li></ol><h3 id="网关业务逻辑"><a href="#网关业务逻辑" class="headerlink" title="网关业务逻辑"></a>网关业务逻辑</h3><p>问题：网关项目比较纯净、没有操作数据库的包、并且还要调用我们之前写过的代码，维护麻烦</p><p>理想：直接请求到其他项目的方法</p><p>怎么调用其他项目的方法</p><ol><li>复制代码和依赖、环境</li><li>HTTP请求（提供一个接口供其他项目调用）</li><li>RPC</li><li>把公共的代码打个jar包，其他项目去引用（客户端SDK）</li></ol><p>HTTP请求怎么调用</p><ol><li>提供方开发一个接口（地址、请求方法、参数、返回值）</li><li>调用方使用HTTP client之类的代码包去发送HTTP请求</li></ol><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>作用：像调用本地方法一样调用远程方法</strong></p><p>对开发者来说更透明，减少了很多的沟通成本</p><p>RPC向远程服务器发送请求时，<strong>未必要使用HTTP协议</strong>。比如还可以用TCP&#x2F;IP。性能更高（内部服务更适用）</p><p><a href="https://blog.csdn.net/NF_ALONG/article/details/139506951">https://blog.csdn.net/NF_ALONG/article/details/139506951</a></p><h3 id="Dubbo框架-（RPC实现）"><a href="#Dubbo框架-（RPC实现）" class="headerlink" title="Dubbo框架 （RPC实现）"></a>Dubbo框架 （RPC实现）</h3><p>GRPC、TRPC</p><p>官方文档:</p><p><a href="https://dubbo-next.staged.apache.org/zh-cn/overview/mannual/java-sdk/">https://dubbo-next.staged.apache.org/zh-cn/overview/mannual/java-sdk/</a></p><p>两种方式：</p><ol><li>Springboot代码（注解——编程式）： 写Java接口，服务提供者和消费者都去引用这个接口</li><li>IDL（接口调用语言）：创建一个公共的接口文件，服务提供者和消费者都去读取这个文件，主要是支持不同语言去使用</li></ol><h3 id="整合运用-Dubbo-Nacos"><a href="#整合运用-Dubbo-Nacos" class="headerlink" title="整合运用(Dubbo Nacos)"></a>整合运用(Dubbo Nacos)</h3><ol><li>backend作为服务提供者<ol><li>实际情况是从数据库中查询secretKey</li><li>调用成功，调用次数加1</li><li>从数据库从查询模拟接口是否存在，以及请求方法是否匹配(还可以校验请求参数</li></ol></li><li>gateway项目作为服务调用者，调用这三个方法</li></ol><p>注意：</p><ol><li>服务接口类必须要在同一个包下，建议是抽象出一个公共项目（放接口、实体类等）</li><li>设置注解（比如启动类的EnableDubbo、接口实现类和Bean引用的注解）</li><li>添加配置</li><li>消费者和提供者尽量引入同样版本的配置和依赖</li></ol><p>整合nacos：</p><p><a href="https://dubbo-next.staged.apache.org/zh-cn/overview/reference/integrations/nacos/">https://dubbo-next.staged.apache.org/zh-cn/overview/reference/integrations/nacos/</a></p><p>moying-backend （7592）提供基础服务、用户登录、查询接口、上线接口、下线接口等。</p><p>myapi-client-sdk（指向8090） 提供接口服务，后续添加固定接口服务时在此扩展。</p><p>common公共模块，提供实体类，以及用户、调用接口校验的接口类。</p><p>myapi-gateway （8090，指向8123）网关。通过断言去转换请求地址，用户鉴权。</p><p>myapi-interface（8123） 接口实现？</p><p>大概流程，登录基础等操作在backend模块完成，此模块还提供inner服务接口（校验功能— &gt;提供给网关）。</p><p>前端请求backend地址的服务。</p><p>使用invoke方法调用接口时，通过使用自制的sdk包装的请求。将请求地址转为gateway模块。</p><p>gateway模块接受到接口调用请求的时候，经过一系列处理和校验（通过tcp请求用户校验、接口校验、用户接口校验功能）后</p><p>通过断言转路由，将请求地址转给interface，在interface模块中写实际的接口功能。</p><p>最后返回结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2024/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2024/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="工厂模式-持续更新"><a href="#工厂模式-持续更新" class="headerlink" title="工厂模式(持续更新)"></a>工厂模式(持续更新)</h1><p>我们这里以手机销售作为应用场景，后续设计模式也尽量贴近生活（使用学校例子(●’◡’●)）</p><p>(感觉这里有点设计问题，写到后面感觉人麻了，自己理解不深以及应用场景想的不太好)</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="初代设计"><a href="#初代设计" class="headerlink" title="初代设计"></a>初代设计</h3><p>首先设计一个手机商店</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> factoryMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">sellPhone</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        Phone phone;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;xiaomi&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">xiaomiPhone</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;oppo&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">oppoPhone</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;huawei&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">huaweiPhone</span>();</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有该手机&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        phone.prepare();</span><br><span class="line">        phone.okSell();</span><br><span class="line">        phone.pack();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后设计一个手机抽象类，让不同品牌的手机继承该类(<strong>后续会讨论为什么要在手机这里设置这些方法而不是在商店里面</strong>，明明商店才是卖手机的啊）（当然了，个人想法，只是想法罢了）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;准备%s手机的盒子、充电线等\n&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">okSell</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成付款&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pack</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s被你打包带走\n&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后具体的品牌的手机继承该类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xiaomiPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">xiaomiPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=<span class="string">&quot;小米&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">oppoPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">oppoPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=<span class="string">&quot;OPPO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">huaweiPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">huaweiPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=<span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写完之后不难发现，要是有新品牌手机出现或者说现有品牌手机不再供应，本该是增删对应品牌的手机就行，但是手机店的销售函数也要进行更改，显然是不合理的。</p><h3 id="简单工厂使用"><a href="#简单工厂使用" class="headerlink" title="简单工厂使用"></a>简单工厂使用</h3><p>设计一个工厂，跟生活一样，手机有生产的工厂，而不是交给手机店判断种类以及生产，它职责只是负责拿到货然后售卖。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;xiaomi&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">xiaomiPhone</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;oppo&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">oppoPhone</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;huawei&quot;</span> -&gt; phone = <span class="keyword">new</span> <span class="title class_">huaweiPhone</span>();</span><br><span class="line">            <span class="keyword">default</span> -&gt; </span><br><span class="line">                System.out.println(<span class="string">&quot;没有该手机&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相应的手机店</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">sellPhone</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneFactory</span>().createPhone(type);</span><br><span class="line">        phone.talkPrice();</span><br><span class="line">        phone.okSell();</span><br><span class="line">        phone.pack();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">或者提前与某家工厂合作</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhoneFactory phoneFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneStore</span><span class="params">(PhoneFactory phoneFactory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.phoneFactory=phoneFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">sellPhone</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneFactory</span>().createPhone(type);</span><br><span class="line">        phone.talkPrice();</span><br><span class="line">        phone.okSell();</span><br><span class="line">        phone.pack();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话，能够将职责进行转移。比较手机的创建过程与手机店无关。（单一责任原则）</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>使用简单工厂确实将创建手机的过程转移到了工厂，让商店只负责卖手机就行，但是还是有问题，当我们添加新品牌手机时，还是会改动手机工厂中的case语句，还是违背了封闭-开放原则（不改动，支持扩展）</p><p>因此将采用工厂方法模式。</p><p><strong>定义：</strong>定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。</p><p><img src="https://img.api.aa1.cn/2024/05/21/e64aa9d4e4f4e.png" alt="image"></p><p>首先设计一个手机工厂的接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后其他手机实现这个接口(基本一致，只展示xiaomi工厂)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">xiaomiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话，加入新的或者删除不同品牌的手机就不会去改动case判断语句了。</p><p>通过手机店去选择卖什么手机然后进行相应的实例化即可。但是代价就是加入新的品牌时，不仅要添加一个实体类，还要写对应的实体从创建工厂。相当于一次性要写两个类了。并且判断转移成了，商店得知道是哪个工厂创建的这个手机。</p><p>手机店的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">sellPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        PhoneFactory phoneFactory=<span class="keyword">new</span> <span class="title class_">HuaweiFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> phoneFactory.createPhone();</span><br><span class="line">        phone.prepare();</span><br><span class="line">        phone.okSell();</span><br><span class="line">        phone.pack();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>定义：</strong>提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。</p><p>我们刚刚的手机店生意很好，所以打算搞连锁店，在北上广深都搞分店然后突击海外市场（doge）</p><p><strong>这里也可以采用具体的手机品牌，然后就有了国内手机工厂的接口和国外手机工厂的接口</strong>，再去创建具体的品牌，但是这里只是讲解模式并不涉及太复杂的场景。</p><p><img src="https://img.api.aa1.cn/2024/05/21/4aac8aacd2650.png" alt="image"></p><p>所以首先定义一个商店的工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Ipad <span class="title function_">createIpad</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后商店进行实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CNFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CNPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Ipad <span class="title function_">createIpad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CNIpad</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是平板和手机的接口,让具体的手机进行实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Ipad</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">okSell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CNIpad</span> <span class="keyword">implements</span> <span class="title class_">Ipad</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">okSell</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后当我们使用国内或者国外的产品时，只需要更改实例化对象即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Factory factory=new CNFactory();   将CNFactory换成ForeignFactory即可</span></span><br><span class="line"><span class="comment">//        Ipad ipad = factory.createIpad();</span></span><br><span class="line"><span class="comment">//        ipad.pack();</span></span><br><span class="line"></span><br><span class="line">        Factory factory=<span class="keyword">new</span> <span class="title class_">ForeignFactory</span>();</span><br><span class="line">        <span class="type">Ipad</span> <span class="variable">ipad</span> <span class="operator">=</span> factory.createIpad();</span><br><span class="line">        ipad.pack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们会发现，当我们添加一个电脑产品时，必须加入PC接口，CN-PC类，ForeignPC类，那是相当麻烦的。</p><p>并且这里的客户端必须得知道国内工厂和国外工厂的创建实例方法。</p><h3 id="使用反射优化抽象工厂-待更新"><a href="#使用反射优化抽象工厂-待更新" class="headerlink" title="使用反射优化抽象工厂(待更新)"></a>使用反射优化抽象工厂(待更新)</h3><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在码代码过程中，也会发现，其实我们平时要是对多态使用较多的话，其实已经是在使用工厂模式了，只是没有将它抽象成一个词汇而已。并且选择模式时需要根据实际情况去选择相性较好的模式，不然会出现设计过度反倒更加复杂的情况，导致得不偿失。</p><p>不要有把新锤子就看什么都是钉子（但是还是得慢慢捶过才知道哪些该捶啊）还是得不断挨打才能成长。</p><p>在简单的场景使用简单工厂甚至于使用面向过程编程会更加简单快捷，所以希望能够慢慢磨练成长吧，从不知道设计模式，到知道并且使用，到使用但是没有刻意去想的境界。</p><p>所以啦，不要刻意去记下什么场景用什么模式，而是清楚这个模式能够解决什么问题，这样还能多个模式相结合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式，Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq</title>
      <link href="/2024/05/05/Java%E5%9F%BA%E7%A1%80/rabbitmq/"/>
      <url>/2024/05/05/Java%E5%9F%BA%E7%A1%80/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq:"></a><strong>rabbitmq:</strong></h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.</p><p>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h3 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># latest RabbitMQ 3.13</span></span><br><span class="line">docker run --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.13-management</span><br></pre></td></tr></table></figure><p>默认账号密码为:  guest</p><p><img src="https://img2.imgtp.com/2024/05/05/ClwUt2SI.png" alt="image-20240505184432095"></p><p>RabbitMQ对应的架构如图：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q0ZjBiZmRkZDg0OTc4MDFkZGY0YjY5ODdiN2MxN2NfWmp4M2ZhRk5tUk5OZVdqdGNReURXT1h2ZElZMkFtYWlfVG9rZW46SEg2ZmJZbEdzb3lTZzF4MzRVQmN6cWpablNiXzE3MTQ5MDU5ODY6MTcxNDkwOTU4Nl9WNA" alt="img"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>— 有点类似于数据库中的database，不同项目之间相互隔离</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240505184936439.png" alt="image-20240505184936439"></p><p><img src="https://img2.imgtp.com/2024/05/05/hUWqD1bQ.png" alt="image-999932"></p><p>尝试发送消息，但是没有队列接收，需要我们自己绑定交换机和队列的关系。</p><p>emmm这里感觉自己摸索一下就欧克了。。</p><h2 id="Java客户端-–-Spring-AMQP"><a href="#Java客户端-–-Spring-AMQP" class="headerlink" title="Java客户端 – Spring AMQP"></a>Java客户端 – Spring AMQP</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 新东西 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习</title>
      <link href="/2024/05/01/ElasticSearch/"/>
      <url>/2024/05/01/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h4 id="ElasticSearch的作用"><a href="#ElasticSearch的作用" class="headerlink" title="ElasticSearch的作用"></a>ElasticSearch的作用</h4><ul><li><p><code>ElasticSearch</code>是一款非常强大的开源搜素引擎，具备非常强大的功能，可以帮助我们从海量数据中快速找到需要的内容</p></li><li><p>例如在电商平台搜索商品，搜索<code>4090显卡</code>会以红色标识<br><a href="https://s1.ax1x.com/2022/12/24/zvVHPA.png"><img src="https://s1.ax1x.com/2022/12/24/zvVHPA.png" alt="zvVHPA.png"></a></p></li><li><p>在搜索引擎搜索答案，搜索到的内容同样会以红色标识，也可以实现搜索时的自动补全功能<br><a href="https://s1.ax1x.com/2022/12/24/zvVLxP.png"><img src="https://s1.ax1x.com/2022/12/24/zvVLxP.png" alt="zvVLxP.png"></a></p></li></ul><h4 id="ELK技术栈"><a href="#ELK技术栈" class="headerlink" title="ELK技术栈"></a>ELK技术栈</h4><ul><li><code>ElasticSearch</code>结合<code>kibana</code>、<code>Logstash</code>、<code>Beats</code>，也就是<code>elastic stack</code>(ELK)。被广泛应用在日志数据分析、实时监控等领域<br><a href="https://s1.ax1x.com/2022/12/24/zvZoLT.png"><img src="https://s1.ax1x.com/2022/12/24/zvZoLT.png" alt="img"></a></li><li>而<code>ElasticSearch</code>是<code>elastic stack</code>的核心，负责存储、搜索、分析数据<br><a href="https://s1.ax1x.com/2022/12/24/zvZfWn.png"><img src="https://s1.ax1x.com/2022/12/24/zvZfWn.png" alt="img"></a></li></ul><h4 id="ElasticSearch和Lucene"><a href="#ElasticSearch和Lucene" class="headerlink" title="ElasticSearch和Lucene"></a>ElasticSearch和Lucene</h4><ul><li>ElasticSearch底层是基于Lucene来实现的</li><li>Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发，官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a></li><li>Lucene的优势<ul><li>易扩展</li><li>高性能（基于倒排索引）</li></ul></li><li>Lucene的缺点<ul><li>只限于Java语言开发</li><li>学习曲线陡峭</li><li>不支持水平扩展</li></ul></li><li>ElasticSearch的发展史<ul><li>2004年，Shay Banon基于Lucene开发了Compass</li><li>2010年，Shay Banon重写了Compass，取名为ElasticSearch，官网地址：<a href="https://www.elastic.co/cnl/">https://www.elastic.co/cnl/</a></li></ul></li><li>相比于Lucene，ElasticSearch具备以下优势<ul><li>支持分布式，可水平扩展</li><li>提供Restful接口，可以被任意语言调用</li></ul></li></ul><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul><li>倒排索引的概念是基于MySQL这样的正向索引而言的</li></ul><h4 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h4><ul><li>为了搞明白什么是倒排索引，我们先来看看什么是正向索引，例如给下表中的id创建索引</li></ul><table><thead><tr><th align="center">id</th><th align="center">title</th><th align="center">price</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">小米手机</td><td align="center">3499</td></tr><tr><td align="center">2</td><td align="center">华为手机</td><td align="center">4999</td></tr><tr><td align="center">3</td><td align="center">华为小米充电器</td><td align="center">49</td></tr><tr><td align="center">4</td><td align="center">小米手环</td><td align="center">49</td></tr></tbody></table><ul><li>如果是基于id查询，那么直接走索引，查询速度非常快。</li><li>但是实际应用里，用户并不知道每一个商品的id，他们只知道title(商品名称)，所以对于用户的查询方式，是基于title(商品名称)做模糊查询，只能是逐行扫描数据</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL</span><br><span class="line">select id, title, price from tb_goods where title like %手机%</span><br></pre></td></tr></table></figure><ul><li>具体流程如下<ol><li>用户搜索数据，搜索框输入手机，那么条件就是title符合<code>%手机%</code></li><li>逐行获取数据</li><li>判断数据中的title是否符合用户搜索条件</li><li>如果符合，则放入结果集，不符合则丢弃</li></ol></li><li>逐行扫描，也就是全表扫描，随着数据量的增加，其查询效率也会越来越低。当数据量达到百万时，这将是一场灾难</li></ul><h4 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h4><ul><li>倒排索引中有两个非常重要的概念<ol><li>文档(Document)：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条(Term)：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我最喜欢的FPS游戏是Apex，就可以分为我、我最喜欢、FPS游戏、最喜欢的FPS、Apex这样的几个词条</li></ol></li><li>创建倒排索引是对正向索引的一种特殊处理，流程如下<ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul></li></ul><h4 id="正向和倒排"><a href="#正向和倒排" class="headerlink" title="正向和倒排"></a>正向和倒排</h4><ul><li><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><code>正向索引</code>是最传统的，根据id索引的方式。但是根据词条查询是，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<code>根据文档查找词条的过程</code></li><li>而<code>倒排索引</code>则相反，是先找到用户要搜索的词条，然后根据词条得到包含词条的文档id，然后根据文档id获取文档，是<code>根据词条查找文档的过程</code></li></ul></li><li><p>那么二者的优缺点各是什么呢？</p><ul><li><pre><code>正向索引<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 优点：可以给多个字段创建索引，根据索引字段搜索、排序速度非常快</span><br><span class="line">  - 缺点：根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  倒排索引</span><br></pre></td></tr></table></figure>- 优点：根据词条搜索、模糊搜索时，速度非常快- 缺点：只能给词条创建索引，而不是字段，无法根据字段做排序</code></pre></li></ul></li></ul><h1 id="Elasticsearch核心概念"><a href="#Elasticsearch核心概念" class="headerlink" title="Elasticsearch核心概念"></a>Elasticsearch核心概念</h1><p><img src="C:\Users\末影\Desktop\课件\images\image-20220905171430202.png" alt="image-20220905171430202"></p><p><strong>注意：Elasticsearch约定一个索引只能有一个类型type，并且类型名固定为(_doc)</strong></p><h4 id="MySQL与ElasticSearch"><a href="#MySQL与ElasticSearch" class="headerlink" title="MySQL与ElasticSearch"></a>MySQL与ElasticSearch</h4><ul><li>我们统一的把MySQL和ElasticSearch的概念做一下对比</li></ul><table><thead><tr><th align="center"><strong>MySQL</strong></th><th align="center"><strong>Elasticsearch</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Table</td><td align="center">Index</td><td align="center">索引(index)，就是文档的集合，类似数据库的表(Table)</td></tr><tr><td align="center">Row</td><td align="center">Document</td><td align="center">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="center">Column</td><td align="center">Field</td><td align="center">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="center">Schema</td><td align="center">Mapping</td><td align="center">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="center">SQL</td><td align="center">DSL</td><td align="center">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li><p>二者各有自己擅长之处</p><ul><li><code>MySQL</code>：产长事务类型操作，可以保证数据的安全和一致性</li><li><code>ElasticSearch</code>：擅长海量数据的搜索、分析、计算</li></ul></li><li><p>因此在企业中，往往是这二者结合使用</p><ul><li><p>对安全性要求较高的写操作，使用MySQL实现</p></li><li><p>对查询性能个较高的搜索需求，使用ElasticSearch实现</p></li><li><p>二者再基于某种方式，实现数据的同步，保证一致性</p><p>(<a href="https://s1.ax1x.com/2022/12/24/zvQRBt.png">https://s1.ax1x.com/2022/12/24/zvQRBt.png</a>)</p></li></ul></li></ul><h4 id="MySQL与ElasticSearch-1"><a href="#MySQL与ElasticSearch-1" class="headerlink" title="MySQL与ElasticSearch"></a>MySQL与ElasticSearch</h4><ul><li>我们统一的把MySQL和ElasticSearch的概念做一下对比</li></ul><table><thead><tr><th align="center"><strong>MySQL</strong></th><th align="center"><strong>Elasticsearch</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Table</td><td align="center">Index</td><td align="center">索引(index)，就是文档的集合，类似数据库的表(Table)</td></tr><tr><td align="center">Row</td><td align="center">Document</td><td align="center">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="center">Column</td><td align="center">Field</td><td align="center">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="center">Schema</td><td align="center">Mapping</td><td align="center">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="center">SQL</td><td align="center">DSL</td><td align="center">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li>二者各有自己擅长之处<ul><li><code>MySQL</code>：产长事务类型操作，可以保证数据的安全和一致性</li><li><code>ElasticSearch</code>：擅长海量数据的搜索、分析、计算</li></ul></li><li>因此在企业中，往往是这二者结合使用<ul><li>对安全性要求较高的写操作，使用MySQL实现</li><li>对查询性能个较高的搜索需求，使用ElasticSearch实现</li><li>二者再基于某种方式，实现数据的同步，保证一致性<br><a href="https://s1.ax1x.com/2022/12/24/zvQRBt.png">  </a></li></ul></li></ul><h3 id="Docker部署单点ES"><a href="#Docker部署单点ES" class="headerlink" title="Docker部署单点ES"></a>Docker部署单点ES</h3><ul><li>因为我们还需要部署Kibana（可视化）容器，因此需要让他们处于同一个网络，为了方便使用名字查询，所以不使用默认的匿名网络。（使用compose部署可以一键互联，不需要这个步骤，但是将来有可能不需要kbiana，只需要es，所以先这里手动部署单点es）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.17.9 </span><br><span class="line">//注意版本，此后安装kibana以及ik分词器等都需要版本一致</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name es \</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    --network es-net \</span><br><span class="line">    -p 9200:9200 \</span><br><span class="line">elasticsearch:7.17.9</span><br></pre></td></tr></table></figure><ul><li>命令解释：<ul><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：配置JVM的堆内存大小，默认是1G，但是最好不要低于512M</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：单点部署</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：数据卷挂载，绑定es的数据目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：数据卷挂载，绑定es的插件目录</li><li><code>-privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code>：让ES加入到这个网络当中</li><li><code>-p 9200</code>：暴露的HTTP协议端口，供我们用户访问的</li></ul></li></ul><p>启动成功后打开<code>192.168.87.132:9200</code>（这里是我的虚拟机ip）</p><h3 id="部署kibana"><a href="#部署kibana" class="headerlink" title="部署kibana"></a>部署kibana</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.17.9</span><br></pre></td></tr></table></figure><p>运行docker命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--net work=es-net \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">kibana:7.17.9</span><br></pre></td></tr></table></figure><ul><li>命令解释<ul><li><code>--network=es-net</code>：让kibana加入<code>es-net</code>这个网络，与ES在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200</code>：设置ES的地址，因为kibana和ES在同一个网络，因此可以直接用容器名访问ES</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul></li></ul><p>成功启动后，打开浏览器访问：<code>192.168.87.132:5601</code>，即可以看到结果</p><h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在线下载安装</span></span><br><span class="line">./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.17.9/elasticsearch-analysis-ik-7.17.9.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>IK分词器包含两种模式<ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul></li></ul><p>随着互联网的发展，<code>造词运动</code>也愈发频繁。出现了许多新词汇，但是在原有的词汇表中并不存在，例如<code>白给</code>、<code>白嫖</code>等<br>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能</p><ol><li>打开IK分词器的config目录</li><li>找到IKAnalyzer.cfg.xml文件，并添加如下内容</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IKAnalyzer.cfg.xml同级目录下新建ext.dic和stopword.dic，并编辑内容</p><h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><ul><li>索引库就类似于数据库表，mapping映射就类似表的结构</li><li>我们要向es中存储数据，必须先创建<code>库</code>和<code>表</code></li></ul><h3 id="mapping映射属性"><a href="#mapping映射属性" class="headerlink" title="mapping映射属性"></a>mapping映射属性</h3><ul><li><p>mapping是对索引库中文档的约束，常见的mapping属性包括</p><ul><li><pre><code>type<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ：字段数据类型，常见的简单类型有</span><br><span class="line"></span><br><span class="line">    1. 字符串：text(可分词文本)、keyword(精确值，例如：品牌、国家、ip地址；因为这些词，分词之后毫无意义)</span><br><span class="line">    2. 数值：long、integer、short、byte、double、float</span><br><span class="line">    3. 布尔：boolean</span><br><span class="line">    4. 日期：date</span><br><span class="line">    5. 对象：object</span><br><span class="line"></span><br><span class="line">  - `index`：是否创建索引，默认为true，默认情况下会对所有字段创建倒排索引，即每个字段都可以被搜索。但是某些字段是不存在搜索的意义的，例如邮箱，图片(存储的只是图片url)，搜索邮箱或图片url的片段，没有任何意义。因此我们在创建字段映射时，一定要判断一下这个字段是否参与搜索，如果不参与搜索，则将其设置为false</span><br><span class="line"></span><br><span class="line">  - `analyzer`：使用哪种分词器</span><br><span class="line"></span><br><span class="line">  - `properties`：该字段的子字段</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;age&quot;: 32,</span><br><span class="line">    &quot;weight&quot;: 48,</span><br><span class="line">    &quot;isMarried&quot;: false,</span><br><span class="line">    &quot;info&quot;: &quot;次元游击兵--恶灵&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;wraith@Apex.net&quot;,</span><br><span class="line">    &quot;score&quot;: [99.1, 99.5, 98.9],</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;雷尼&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;布莱希&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h4 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h4><ul><li>基本语法<ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/&#123;索引库名&#125;</code>，可以自定义</li><li>请求参数：<code>mapping映射</code></li></ul></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;子字段2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test001</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h4><ul><li>基本语法<ul><li>请求方式：<code>GET</code></li><li>请求路径：<code>/&#123;索引库名&#125;</code></li><li>请求参数：<code>无</code></li></ul></li><li>格式：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">GET /test001</span><br></pre></td></tr></table></figure><h4 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h4><ul><li>基本语法<ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/&#123;索引库名&#125;/_mapping</code></li><li>请求参数：<code>mapping映射</code></li></ul></li><li>格式：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>倒排索引结构虽然不复杂，但是一旦数据结构改变(比如改变了分词器)，就需要重新创建倒排索引，这简直是灾难。因此索引库<code>一旦创建，就无法修改mapping</code></li><li>虽然无法修改mapping中已有的字段，但是却允许添加新字段到mapping中，因为不会对倒排索引产生影响</li></ul><h4 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h4><ul><li>基本语法：<ul><li>请求方式：<code>DELETE</code></li><li>请求路径：<code>/&#123;索引库名&#125;</code></li><li>请求参数：无</li></ul></li><li>格式</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">DELETE /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><ul><li>语法</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>文档id<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">POST /test001/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;次元游记兵--恶灵&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wraith@Apex.net&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;雷尼&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;布莱希&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><ul><li>根据rest风格，新增是post，查询应该是get，而且一般查询都需要条件，这里我们把文档id带上</li><li>语法</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">GET /test001/_doc/1</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ul><li>删除使用DELETE请求，同样，需要根据id进行删除</li><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">DELETE /&#123;索引库名&#125;/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><ul><li>示例：根据id删除数据, 若删除的文档不存在, 则result为not found</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">DELETE /test001/_doc/1</span><br></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a><strong>修改文档</strong></h3><ul><li>修改有两种方式<ol><li><strong>全量</strong>修改：直接覆盖原来的文档</li><li><strong>增量</strong>修改：修改文档中的部分字段</li></ol></li></ul><h4 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h4><ul><li>全量修改是覆盖原来的文档，其本质是<ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul></li></ul><p><strong>注意：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>文档id<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="增量修改"><a href="#增量修改" class="headerlink" title="增量修改"></a>增量修改</h4><ul><li>增量修改只修改指定id匹配文档中的部分字段</li><li>语法</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JSON</span><br><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/<span class="punctuation">&#123;</span>文档id<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">         ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>文档的操作有哪些？</p><ol><li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;{id}</li><li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;{id}</li><li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;{id}</li><li>修改文档</li></ol><ul><li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;{id}</li><li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;{id}</li></ul></li></ul><h2 id="Springdata-JAVA"><a href="#Springdata-JAVA" class="headerlink" title="Springdata -&gt;JAVA"></a>Springdata -&gt;JAVA</h2><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置ES</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#application.properties</span></span><br><span class="line"><span class="string">spring.elasticsearch.rest.uris=http://localhost:9200</span></span><br></pre></td></tr></table></figure><ul><li>编写实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName=&quot;product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@Field(analyzer=&quot;ik_smart&quot;,searchAnalyzer=&quot;ik_smart&quot;,type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Field(analyzer=&quot;ik_smart&quot;,searchAnalyzer=&quot;ik_smart&quot;,type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="meta">@Field(type=FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的index对应Es中的索引。</p><h3 id="测试实践"><a href="#测试实践" class="headerlink" title="测试实践"></a>测试实践</h3><p>这些简单的curd看看就行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product,String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IProductService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository repository;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        repository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        repository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        repository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">get</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findById(id).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterable&lt;Product&gt; all = repository.findAll();</span><br><span class="line">        List&lt;Product&gt;list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        all.forEach(list::add);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂查询以及高亮展示"><a href="#复杂查询以及高亮展示" class="headerlink" title="复杂查询以及高亮展示"></a>复杂查询以及高亮展示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchByEs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//定义query</span></span><br><span class="line">   <span class="comment">//定义query</span></span><br><span class="line">        MultiMatchQueryBuilder queryBuilder=QueryBuilders.multiMatchQuery(<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;title&quot;</span>, <span class="string">&quot;intro&quot;</span>);</span><br><span class="line">        queryBuilder.minimumShouldMatch(String.valueOf(<span class="number">1</span>));</span><br><span class="line">        HighlightBuilder highlightBuilder=<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">        highlightBuilder.field(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        highlightBuilder.requireFieldMatch(<span class="literal">false</span>);</span><br><span class="line">        highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);</span><br><span class="line">        highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">        highlightBuilder.fragmentSize(<span class="number">699999</span>);<span class="comment">// 最大高亮分片数</span></span><br><span class="line">        highlightBuilder.numOfFragments(<span class="number">0</span>);<span class="comment">// 从第一个分片获取高亮片段</span></span><br><span class="line">        Pageable pageable=PageRequest.of(<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//0为第一页，10为pageSize</span></span><br><span class="line">        NativeSearchQuery searchQuery=<span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>()</span><br><span class="line">                .withQuery(queryBuilder)</span><br><span class="line">                .withPageable(pageable)</span><br><span class="line">                .withHighlightBuilder(highlightBuilder)<span class="comment">// 设置高亮</span></span><br><span class="line">                .build();</span><br><span class="line">        SearchHits&lt;Product&gt; searchHits= template.search(searchQuery, Product.class);</span><br><span class="line">     List&lt;Product&gt;list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(searchHits.hasSearchHits())&#123;</span><br><span class="line">            List&lt;SearchHit&lt;Product&gt;&gt; searchHitList= searchHits.getSearchHits();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit&lt;Product&gt; hit : searchHitList) &#123;</span><br><span class="line">                Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                product.setId(hit.getId());</span><br><span class="line">                 <span class="comment">// 处理高亮</span></span><br><span class="line">                <span class="keyword">if</span>(hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> String.valueOf(hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">                    product.setTitle(title.substring(<span class="number">1</span>,title.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">if</span>(hit.getHighlightFields().get(<span class="string">&quot;intro&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    String intro=String.valueOf(hit.getHighlightFields().get(<span class="string">&quot;intro&quot;</span>));</span><br><span class="line">                    product.setIntro(intro.substring(<span class="number">1</span>,intro.length()-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> docker使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="/2024/04/20/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/20/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简单命令"><a href="#1-简单命令" class="headerlink" title="1.简单命令"></a>1.简单命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="1-1部署MySQL"><a href="#1-1部署MySQL" class="headerlink" title="1.1部署MySQL"></a>1.1部署MySQL</h4><p>首先，我们利用Docker来安装一个MySQL软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用CV大法）：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>在windows下测试连接，测试成功！</p><p>当我们执行命令后，Docker做的第一件事情，是去自动搜索并下载了MySQL，然后会自动运行MySQL，我们完全不用插手，非常方便。</p><p>而且，这种安装方式完全不用考虑运行的操作系统环境，它不仅仅在CentOS系统是这样，在Ubuntu系统、macOS系统、甚至是装了WSL的Windows下，都可以使用这条命令来安装MySQL。</p><p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p><p>而使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL。注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>说明：</p><ul><li>镜像：英文是<strong>image</strong></li><li>容器：英文是<strong>container</strong></li></ul><blockquote><p>因此，Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程。</p></blockquote><p>Docker会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p><p>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：</p><p><strong><a href="https://hub.docker.com/">https://hub.docker.com/</a></strong></p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p>像这种提供存储、管理Docker镜像的服务器，被称为DockerRegistry，可以翻译为镜像仓库。DockerHub网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库。</p><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。而企业内部的机密项目，往往会采用私有镜像仓库。</p><p>总之，镜像的来源有两种：</p><ul><li>基于官方基础镜像自己制作</li><li>直接去DockerRegistry下载</li></ul><blockquote><p><strong>总结一下：</strong></p><p><strong>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</strong></p></blockquote><p>用一幅图标示如下：</p><p><img src="C:\Users\末影\Downloads\whiteboard_exported_image.png" alt="whiteboard_exported_image"></p><h4 id="1-2命令解读"><a href="#1-2命令解读" class="headerlink" title="1.2命令解读"></a>1.2命令解读</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \ </span><br><span class="line">  --name mysql \   取名,唯一</span><br><span class="line">  -p 3306:3306 \   端口映射, (后面是容器端口,前面是宿主机端口)</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p><strong>解读：</strong></p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><h2 id="2-Docker基础"><a href="#2-Docker基础" class="headerlink" title="2.Docker基础"></a>2.Docker基础</h2><p>Docker官方文档：<strong><a href="https://docs.docker.com/">https://docs.docker.com/</a></strong></p><h3 id="2-1-场景命令"><a href="#2-1-场景命令" class="headerlink" title="2.1 场景命令"></a>2.1 场景命令</h3><p><a href="https://docs.docker.com/engine/reference/commandline/cli/">Use the Docker command line | Docker Docs</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run 创建并运行</span><br><span class="line"></span><br><span class="line">docker stop 停止</span><br><span class="line"></span><br><span class="line">docker start 启动</span><br><span class="line"></span><br><span class="line">docker ps 查看容器运行情况</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> 删除容器      docker rmi 删除镜像</span><br><span class="line">docker images 查看镜像</span><br></pre></td></tr></table></figure><h4 id="2-1-1-命令介绍"><a href="#2-1-1-命令介绍" class="headerlink" title="2.1.1.命令介绍"></a>2.1.1.命令介绍</h4><p>其中，比较常见的命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一副图来表示这些命令的关系：</p><p>![whiteboard_exported_image (1)](C:\Users\末影\Downloads\whiteboard_exported_image (1).png)</p><p>补充：</p><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h4 id="2-1-2-演示"><a href="#2-1-2-演示" class="headerlink" title="2.1.2.演示"></a>2.1.2.演示</h4><p>教学环节说明：我们以Nginx为例给大家演示上述命令。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line">mysql        latest    <span class="number">3218</span>b38490ce   <span class="number">17</span> months ago   <span class="number">516</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h4 id="2-1-3-命令别名"><a href="#2-1-3-命令别名" class="headerlink" title="2.1.3.命令别名"></a>2.1.3.命令别名</h4><p>给常用Docker命令起别名，方便我们访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><blockquote><p>也可以别名用来调戏一起学Linux的哥们(bushi)</p></blockquote><h3 id="2-2-数据卷"><a href="#2-2-数据卷" class="headerlink" title="2.2.数据卷"></a>2.2.数据卷</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><h4 id="2-2-1-什么是数据卷"><a href="#2-2-1-什么是数据卷" class="headerlink" title="2.2.1.什么是数据卷"></a>2.2.1.什么是数据卷</h4><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p>![whiteboard_exported_image (2)](C:\Users\末影\Downloads\whiteboard_exported_image (2).png)</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><blockquote><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p></blockquote><blockquote><p><strong>为什么不让容器目录直接指向宿主机目录呢</strong>？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li></ul></blockquote><h4 id="2-2-2-数据卷命令"><a href="#2-2-2-数据卷命令" class="headerlink" title="2.2.2.数据卷命令"></a>2.2.2.数据卷命令</h4><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><blockquote><p><strong>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。</strong></p></blockquote><p>删除原有的nginx然后重新创建，并挂在到数据卷上（没有数据卷会自动创建）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume <span class="built_in">ls</span> 查看数据卷列表</span><br><span class="line"></span><br><span class="line">docker volume inspect html look details</span><br></pre></td></tr></table></figure><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240420191816721.png" alt="image-20240420191816721"></p><p>而mysql在创建时已经挂载了一个匿名卷</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现，其中有几个关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><h4 id="2-2-3-挂载本地目录或文件"><a href="#2-2-3-挂载本地目录或文件" class="headerlink" title="2.2.3.挂载本地目录或文件"></a>2.2.3.挂载本地目录或文件</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p></blockquote><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><h3 id="2-3-镜像"><a href="#2-3-镜像" class="headerlink" title="2.3.镜像"></a>2.3.镜像</h3><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p><h4 id="2-3-1-镜像结构"><a href="#2-3-1-镜像结构" class="headerlink" title="2.3.1.镜像结构"></a>2.3.1.镜像结构</h4><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p><img src="C:\Users\末影\Downloads\download_image.png" alt="download_image"></p><h4 id="2-3-2-Dockerfile"><a href="#2-3-2-Dockerfile" class="headerlink" title="2.3.2.Dockerfile"></a>2.3.2.Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>比如构建一个Java应用，其dockerfile可以这样写</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>simple demo:</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hm-service.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><p>首先，将黑马提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NjIxZDFjZWNmNGIwOGE3NjE0N2Y5YzlmYzhmZGQ5N2VfR2ZDMFFiNXNsV3huM1FSOW8yaHdOeEJMRVJueElIZm5fVG9rZW46RGFOeGJ3Tjg0bzdtRWx4N3A0OGNRU1NTbnJlXzE3MTM2MjY4OTM6MTcxMzYzMDQ5M19WNA" alt="img"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建并运行该容器</span><br><span class="line"></span><br><span class="line">![image-20240420215031073](C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240420215031073.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.4.网络</span><br><span class="line"></span><br><span class="line">首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span><br><span class="line">docker inspect mysql</span><br><span class="line"># 也可以使用format过滤结果</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mysql</span><br><span class="line"># 得到IP地址如下：</span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"># 2.然后通过命令进入dd容器</span><br><span class="line">docker exec -it dd bash</span><br><span class="line"></span><br><span class="line"># 3.在容器内，通过ping命令测试网络</span><br><span class="line">ping 172.17.0.2</span><br><span class="line"># 结果</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是个虚拟的IP，它的值并不固定或是与某个容器绑定，每次重启某个容器的时候都有可能发生变化，所以我们不能直接写死</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create moying //创建一个网络</span><br><span class="line"></span><br><span class="line">docker network <span class="built_in">ls</span> 查看网络</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   moying     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了moying以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将项目与网络连接起来</span></span><br><span class="line">docker network connect moying <span class="built_in">dd</span></span><br><span class="line">docker network connect moying mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了。</p><p>默认的网络不支持name连接</p><h2 id="3-项目部署"><a href="#3-项目部署" class="headerlink" title="3.项目部署"></a>3.项目部署</h2><p>首先使用黑马提供的项目文件</p><p>项目说明：</p><ul><li>hmall：商城的后端代码</li><li>hmall-portal：商城用户端的前端代码</li><li>hmall-admin：商城管理端的前端代码</li></ul><p>部署的容器及端口说明：</p><table><thead><tr><th align="left"><strong>项目</strong></th><th align="left"><strong>容器名</strong></th><th align="left"><strong>端口</strong></th><th align="left"><strong>备注</strong></th></tr></thead><tbody><tr><td align="left">hmall</td><td align="left">hmall</td><td align="left">8080</td><td align="left">黑马商城后端API入口</td></tr><tr><td align="left">hmall-portal</td><td align="left">nginx</td><td align="left">18080</td><td align="left">黑马商城用户端入口</td></tr><tr><td align="left">hmall-admin</td><td align="left">nginx</td><td align="left">18081</td><td align="left">黑马商城管理端入口</td></tr><tr><td align="left">mysql</td><td align="left">mysql</td><td align="left">3306</td><td align="left">数据库</td></tr></tbody></table><blockquote><p>部署之前，将之前的容器删除</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f nginx <span class="built_in">dd</span> hmall </span><br></pre></td></tr></table></figure><h3 id="3-1-部署Java项目"><a href="#3-1-部署Java项目" class="headerlink" title="3.1.部署Java项目"></a>3.1.部署Java项目</h3><p><code>hmall</code>项目是一个maven聚合项目，使用IDEA打开<code>hmall</code>项目，查看项目结构如图：</p><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240420233742237.png" alt="image-20240420233742237"></p><p>我们要部署的就是其中的<code>hm-service</code>，其中的配置文件采用了多环境的方式：</p><blockquote><p>application.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hm-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hmall?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">黑马商城接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;黑马商城接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.controller</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/hi</span></span><br><span class="line"><span class="comment"># keytool -genkeypair -alias hmall -keyalg RSA -keypass hmall123 -keystore hmall.jks -storepass hmall123</span></span><br></pre></td></tr></table></figure><blockquote><p>application-dev.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">pw:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><blockquote><p>application-local.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.87</span><span class="number">.132</span> <span class="comment"># 修改为你自己的虚拟机IP地址</span></span><br><span class="line">    <span class="attr">pw:</span> <span class="number">123</span> <span class="comment"># 修改为docker中的MySQL密码</span></span><br></pre></td></tr></table></figure><p>其中application.yaml，JDBC的地址并未写死，而且读取变量</p><p>因为开发环境以及部署的时候mysql的密码和ip地址一般都是不一致的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hm-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hmall?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br></pre></td></tr></table></figure><p>在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问。</p><p>然后将项目打包后得到hm-service.jar 并将Dockerfile一同复制到虚拟机</p><p>部署项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.构建项目镜像，不指定tag，则默认为latest</span></span><br><span class="line">docker build -t hmall .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行容器，并通过--network将其加入moying网络，这样才能通过容器名访问mysql</span></span><br><span class="line">docker run -d --name hmall --network moying -p 8080:8080 hmall</span><br></pre></td></tr></table></figure><h3 id="3-2-部署前端"><a href="#3-2-部署前端" class="headerlink" title="3.2.部署前端"></a>3.2.部署前端</h3><p><code>hmall-portal</code>和<code>hmall-admin</code>是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDhmN2Q1ZmQyMGUyNTU0YWZjZTc5ZmVmYmUyODAxNjVfa0FDOWM1anY4VE9CQnl6bDFEakhGTWZyN2REeGhDN25fVG9rZW46WFRuUGJ5T0RabzdDOER4TXI5Y2N3Qkdnbk9oXzE3MTM2Mjc4MDk6MTcxMzYzMTQwOV9WNA" alt="img"></p><p>其中：</p><ul><li><code>html</code>是静态资源目录，我们需要把<code>hmall-portal</code>以及<code>hmall-admin</code>都复制进去</li><li><code>nginx.conf</code>是nginx的配置文件，主要是完成对<code>html</code>下的两个静态资源目录做代理</li></ul><p>将nginx整个目录上传到虚拟机上</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE3NWQ4ZTY2NGMyNTVlMjMxNjM0NjNhZDcxMDlkOGJfWlhLWHR0ZFJwNDd1SUJHNnlzTWk3Nzd4ekxsZXlFMWhfVG9rZW46V0dMbmJQSWtKb0hOc2x4NnRuRGN0QXZLbnBmXzE3MTM2Mjc4NjM6MTcxMzYzMTQ2M19WNA" alt="img"></p><p>然后创建nginx容器并完成两个挂载：</p><ul><li>把<code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li><li>把<code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li></ul><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口：</p><ul><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d \</span></span><br><span class="line"><span class="language-bash">--name nginx \</span></span><br><span class="line"><span class="language-bash">-p 18080:18080 \</span></span><br><span class="line"><span class="language-bash">-p 18081:18081 \</span></span><br><span class="line"><span class="language-bash">-v /root/nginx/html:/usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">-v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span></span><br><span class="line"><span class="language-bash">--network moying \</span></span><br><span class="line"><span class="language-bash">nginx</span></span><br></pre></td></tr></table></figure><h3 id="3-3-DockerCompose"><a href="#3-3-DockerCompose" class="headerlink" title="3.3.DockerCompose"></a>3.3.DockerCompose</h3><p>这种手动添加容器且后续扩展的时候都需要去用ps去查看容器情况，然后进行添加或者删除，非常麻烦，而且后续项目不止前后端以及mysql，加入各种中间件后，就很麻烦，且不易统一管理</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h4 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h4><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">Compose file version 3 reference | Docker Docs</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network moying</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">moying</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>docker run 参数</strong></th><th align="center"><strong>docker compose 指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">–name</td><td align="center">container_name</td><td align="center">容器名称</td></tr><tr><td align="center">-p</td><td align="center">ports</td><td align="center">端口映射</td></tr><tr><td align="center">-e</td><td align="center">environment</td><td align="center">环境变量</td></tr><tr><td align="center">-v</td><td align="center">volumes</td><td align="center">数据卷配置</td></tr><tr><td align="center">–network</td><td align="center">networks</td><td align="center">网络</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left"></td><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left"></td><td align="left">down</td><td align="left">停止并移除所有容器、网络</td></tr><tr><td align="left"></td><td align="left">ps</td><td align="left">列出所有启动的容器</td></tr><tr><td align="left"></td><td align="left">logs</td><td align="left">查看指定容器的日志</td></tr><tr><td align="left"></td><td align="left">stop</td><td align="left">停止容器</td></tr><tr><td align="left"></td><td align="left">start</td><td align="left">启动容器</td></tr><tr><td align="left"></td><td align="left">restart</td><td align="left">重启容器</td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看运行进程</td></tr><tr><td align="left"></td><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> -f hm nginx </span><br><span class="line"></span><br><span class="line">docker rmi hmall</span><br><span class="line">启动所有, -d 参数是后台启动</span><br><span class="line">docker compose up -d </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 新东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚合搜索系统</title>
      <link href="/2024/03/30/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/30/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合搜索系统"><a href="#聚合搜索系统" class="headerlink" title="聚合搜索系统"></a>聚合搜索系统</h1><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240330204744024.png" alt="image-20240330204744024"></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>vue3</li><li>ant design vue</li><li></li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><h4 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h4><p>前端，后端初始化</p><p>前端页面开发，后端基本搜索接口</p><h4 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h4><p>数据抓取</p><p>聚合搜索接口开发</p><ul><li>适配器</li><li>门面模式</li></ul><p>elasticsearch 搭建</p><h4 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h4><p>elasticsearch使用 建表，读写数据，调用api，Java整合</p><p>数据同步（四种同步方式）</p><h4 id="第四期"><a href="#第四期" class="headerlink" title="第四期"></a>第四期</h4><p>保障接口稳定性</p><p>项目优化（关键词高亮，搜索建议，防抖节流）</p><p>先鸽一下。</p><hr><h2 id="第一期-1"><a href="#第一期-1" class="headerlink" title="第一期"></a>第一期</h2><p>前端初始化</p><p>后端初始化</p><p>前端页面开发，后端基本搜索接口</p><p>整合Axios</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//这里注意看官方开发文档，跟着走</span><br><span class="line">npm install -g @vue/cli </span><br><span class="line">//创建项目</span><br><span class="line">vue create antd-demo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用组件</span></span><br><span class="line">npm i --save ant-design-vue@4.x</span><br></pre></td></tr></table></figure><p>后端采用初始模板,根据需求更改sql</p><hr><p>前端瘦身，留下主页 indexPage</p><p>拆解页面</p><p>margin: 0 auto, </p><p>max-width: 1024px</p><p>用url记录页面搜索状态，当用户刷新页面时，能够还原之前的搜索状态</p><p>url &lt;&#x3D;&#x3D;&gt; 页面状态</p><p>核心技巧： 把同步状态改成单向，即只允许url来改变页面状态</p><ol><li>让用户操作时，改变url地址（点击搜索框时，进行填充,切换tab也要填充）</li><li>当url地址改变时，去改变页面状态(监听url的改变)</li></ol><p>首先设计动态路由  搜索和切换时参数记得别掉了</p><p>watchEffect 实现监听</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  searchValue.<span class="property">value</span> =&#123;</span><br><span class="line">    ...initSearchValue, <span class="comment">//兜底</span></span><br><span class="line">    <span class="attr">text</span>: route.<span class="property">query</span>.<span class="property">text</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="联调后端"><a href="#联调后端" class="headerlink" title="联调后端"></a>联调后端</h4><p>引入axios</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>构建实例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;http://localhost:9999/api&quot;</span>,<span class="comment">//添加前缀</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="comment">// &quot;Content-Type&quot;: &quot;application/json&quot;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);     <span class="comment">// 创建axios实例</span></span><br></pre></td></tr></table></figure><p>创建一个全局拦截器 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;http://localhost:9999/api&quot;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="comment">// &quot;Content-Type&quot;: &quot;application/json&quot;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);     <span class="comment">// 创建axios实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">const</span> data = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">code</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance; <span class="comment">// 导出实例</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入文章查询接口</p><p>:::后续补充父组件向子组件传入数据的知识</p><p>目前简单使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父亲组件调用子组件且传递数据过去 </span></span><br><span class="line">&lt;postList :post-list=<span class="string">&quot;postPageList&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">postList</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//   接收</span></span><br></pre></td></tr></table></figure><h2 id="第二期-1"><a href="#第二期-1" class="headerlink" title="第二期"></a>第二期</h2><ol><li>获取多种不同类型的数据源</li></ol><p>​  a. 文章（内部）</p><p>​  b. 用户（内部）</p><p>​  c. 图片 （外部,不是自己项目或者用户生成的数据）</p><p>​  d. 后面总结完加个视频（爬取）</p><ol start="2"><li>前后端搜索接口联调，跑通页面</li><li>分析现有问题 &#x3D; 》 优化， 聚合接口开发</li><li>安装es</li></ol><h4 id="获取数据源"><a href="#获取数据源" class="headerlink" title="获取数据源"></a>获取数据源</h4><h5 id="1、获取文章"><a href="#1、获取文章" class="headerlink" title="1、获取文章"></a>1、获取文章</h5><p>&#x3D;&#x3D;&#x3D;&gt; 爬虫 (悠着点)</p><p>抓取网站：xxxx.com</p><p>获取到文章后要入库（定时获取或者一次性）</p><p>感觉分情况而论，要是查的不严就可以先搜现爬</p><h5 id="数据抓取"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取</h5><ol><li>直接请求数据接口（最方便）✔</li><li>等网页渲染出明文内容后，从前端页面的内容抓取</li><li>动态请求，类似于谷歌校验人机&#x3D;&gt;无头浏览器: selenium, node.js puppeteer</li></ol><p>引入工具库 HttpClient, OKHttp ,RestTemplate, Hutool(推荐),</p><h5 id="数据抓取-✔"><a href="#数据抓取-✔" class="headerlink" title="数据抓取 ✔"></a>数据抓取 ✔</h5><p>1.分析数据源</p><p>2.拿到数据后，如何处理</p><p>3.存入数据库</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">crawlerJob</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PostService postService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PostEsDao postEsDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;current\&quot;:1,\&quot;pageSize\&quot;:8,\&quot;sortField\&quot;:\&quot;createTime\&quot;,\&quot;sortOrder\&quot;:\&quot;descend\&quot;,\&quot;category\&quot;:\&quot;文章\&quot;,\&quot;tags\&quot;:[],\&quot;reviewStatus\&quot;:1&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.code-nav.cn/api/post/search/page/vo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .body(json)</span><br><span class="line">                .execute().body();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        Map&lt;String,Object&gt; data= JSONUtil.toBean(result,Map.class);</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        List&lt;Post&gt;postList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data1</span> <span class="operator">=</span>(JSONObject) data.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">dataList</span> <span class="operator">=</span> data1.getJSONArray(<span class="string">&quot;records&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : dataList) &#123;</span><br><span class="line">            JSONObject record=(JSONObject) o;</span><br><span class="line">            <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Post</span>();</span><br><span class="line"></span><br><span class="line">            post.setTags(record.getJSONArray(<span class="string">&quot;tags&quot;</span>).toString());</span><br><span class="line">            post.setContent(record.getStr(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">            post.setTitle(record.getStr(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">            post.setUserId(<span class="number">1774104110152880131L</span>);</span><br><span class="line">            System.out.println(post);</span><br><span class="line">            postList.add(post);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> postService.saveBatch(postList);</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;数据爬取，且插入&#123;&#125;条&quot;</span>,postList.size());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;数据插入失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-用户获取"><a href="#2-用户获取" class="headerlink" title="2.用户获取"></a>2.用户获取</h5><p>额，自己的就够了，没必要的哥们</p><h5 id="3-图片获取-✔"><a href="#3-图片获取-✔" class="headerlink" title="3.图片获取 ✔"></a>3.图片获取 ✔</h5><p>实时抓取，我们网站不存这些数据，用户要搜的时候，直接从别人的网站抓取</p><p>获取到html文档，然后从中解析出需要的字段</p><p>jsoup库 —》自己看文档..</p><blockquote><p>抓取后，慢慢debug去拨开数据</p></blockquote><h4 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h4><p>搞一个pictureController ✔</p><p>— 感觉可以狠狠研究一下这个格式（后端工程）</p><ol><li>请求数量比较多，可能会收到浏览器的限制&#x3D;&#x3D;&gt;用一个接口完成</li><li>请求不同接口的参数不一致，增加前后端沟通成本</li><li>前端要写多个接口调用,重复代码</li></ol><h2 id="聚合接口"><a href="#聚合接口" class="headerlink" title="聚合接口"></a>聚合接口</h2><ol><li>请求数量比较多，可能会收到浏览器的限制&#x3D;&#x3D;&gt;用一个接口完成</li><li>请求不同接口的参数不一致，增加前后端沟通成本&#x3D;&gt; 用一个接口把请求参数统一，前端每次传固定的参数，后端去对参数进行转换</li><li>前端要写多个接口调用,重复代码&#x3D;&gt;用一个接口，通过不同参数去区分查询的数据源</li></ol><p>撸出一个SearchController ✔</p><h2 id="第三期-1"><a href="#第三期-1" class="headerlink" title="第三期"></a>第三期</h2><ol><li>聚合接口优化,支持前端更灵活的去取数据</li><li><strong>从0学习Elastic Stack (Elasticsearch)</strong></li><li>学习数据同步，怎么把一个数据库内的数据同步到其他数据库</li></ol><h3 id="聚合接口优化"><a href="#聚合接口优化" class="headerlink" title="聚合接口优化"></a>聚合接口优化</h3><p>新增 type or category ，通过不同参数去查询不同数据源</p><ol><li>如果category为空，那么搜索出所有数据</li><li>不为空<ul><li>合法则查询相应数据</li><li>否则报错</li></ul></li></ol><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>当调用你接口的客户端，觉得麻烦的时候，你就得考虑，是不是得找个门卫了</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ol><li>定制一个统一的规范（标准）什么数据源允许接入，需要满足哪些标准</li><li>假如说我们数据源已经支持搜索，但是原有的方法和参数和我们的规范不一致</li></ol><p>适配器的作用： 通过转换，让两个系统能够完成对接（转换器）</p><p>接入我们的系统，必须支持关键词搜索，分页搜索</p><p><strong>设计一个接口函数去统一规范，还可以减少后续的if else 的重复代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSource</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt;doSearch(String searchText,<span class="type">long</span> pageNum,<span class="type">long</span> pageSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注册器模式（本质也是单例）"><a href="#注册器模式（本质也是单例）" class="headerlink" title="注册器模式（本质也是单例）"></a>注册器模式（本质也是单例）</h4><ol><li><p>提前通过一个map或者其他容器存储好想要调用的对象</p></li><li><p>代码量少，可维护性高</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceRegister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PictureSource pictureSource;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PostSource postSource;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserSource userSource;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, DataSource&lt;?&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化类时加载</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String ,DataSource&lt;?&gt;&gt;() &#123;&#123;</span><br><span class="line">            put(SearchEnum.USER.getValue(), userSource);</span><br><span class="line">            put(SearchEnum.POST.getValue(), postSource);</span><br><span class="line">            put(SearchEnum.PICTURE.getValue(), pictureSource);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DataSource&lt;?&gt; getDataSourceByType(String type) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解的方法在整个Bean初始化中的执行顺序：</span></span><br><span class="line"></span><br><span class="line">Constructor(构造方法) -&gt; <span class="meta">@Autowired(依赖注入)</span> -&gt; <span class="meta">@PostConstruct(注释的初始化方法)</span></span><br></pre></td></tr></table></figure><h3 id="前端踩坑点！！！"><a href="#前端踩坑点！！！" class="headerlink" title="前端踩坑点！！！"></a>前端踩坑点！！！</h3><blockquote><p>首先加入category之后 不仅需要点击搜索进行发送请求，然后改变tab的时候也需要</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onChangeTab</span> = (<span class="params">category</span>) =&gt; &#123;</span><br><span class="line">  router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">`/<span class="subst">$&#123;category&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">query</span>: searchValue.<span class="property">value</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">LoadData</span>(searchValue.<span class="property">value</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;<span class="comment">//使用then，不然会是跳转前的tab。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  searchValue.<span class="property">value</span> = &#123;</span><br><span class="line">    ...initSearchValue, <span class="comment">//兜底</span></span><br><span class="line">    <span class="attr">text</span>: route.<span class="property">query</span>.<span class="property">text</span>,</span><br><span class="line">    <span class="attr">category</span>: route.<span class="property">params</span>.<span class="property">category</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后就是发现，额之前那个调用LoadAllData()会出问题，md</p><p>前端简直就是magic啊</p><blockquote><p>要是watch用的6的话，也可以用这个吧</p></blockquote><h3 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h3><p>搜索不够灵活</p><p>仅仅靠数据库的like的话</p><h2 id="Elastic-Stack-一套技术栈"><a href="#Elastic-Stack-一套技术栈" class="headerlink" title="Elastic Stack(一套技术栈)"></a>Elastic Stack(一套技术栈)</h2><p>官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><p>包含了数据的整合&#x3D;&gt;提取，存储&#x3D;&gt;使用，一整套</p><p>beats: 从各种不同类型的文件&#x2F;<strong>应用来采集数据</strong></p><p>Logstash: 从多个采集器或者数据源来抽取&#x2F;转换数据</p><p>Elasticsearch: 存储，查询数据  <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/zip-windows.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/zip-windows.html</a></p><p>kibana: 可视化es的数据 <a href="https://www.elastic.co/guide/en/kibana/7.17/windows.html">https://www.elastic.co/guide/en/kibana/7.17/windows.html</a></p><h4 id="安装-es-kibana"><a href="#安装-es-kibana" class="headerlink" title="安装 es kibana"></a>安装 es kibana</h4><p>记得版本一致： 7.17</p><h3 id="Elasticsearch概念"><a href="#Elasticsearch概念" class="headerlink" title="Elasticsearch概念"></a><strong>Elasticsearch概念</strong></h3><p>Index 索引 &#x3D; &gt; mySql 里面的table</p><p>建表 ，crud（查询重点）</p><p>用客户端取调用Elasticsearch(3种)</p><p>语法： SQL,代码的方法(4种语法（现在学）)</p><p>能够自动分词？能够高效，灵活的查询内容</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>正向索引：类似于书籍的目录，可以快速找到对应的内容（根据页码找到文章）</p><p>倒排索引：</p><p>切词，根据内容找到对应内容</p><h3 id="ES的调用方式"><a href="#ES的调用方式" class="headerlink" title="ES的调用方式"></a>ES的调用方式</h3><ol><li>restful api (http请求)      get &#x2F;</li></ol><p>localhost:9200 给外部用户的接口</p><p>localhost:9300 给es集群内部通信的，外部调用不了</p><ol start="2"><li><p>kibana    <strong>devTools</strong>(不建议生产环境使用)</p><p>自由地对es进行操作（本质也是resful api）</p></li><li><p>Java客户端</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/_getting_started.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/_getting_started.html</a></p></li></ol><p><strong>kibana：</strong></p><p><a href="http://localhost:5601/app/home#">http://localhost:5601/app/home#</a></p><h3 id="ES的语法"><a href="#ES的语法" class="headerlink" title="ES的语法:"></a>ES的语法:</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-filter-context.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-filter-context.html</a></p><p><strong>DSL</strong>      </p><p>建表，插入数据</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;localhost:9200/logs-my_app-default/_doc?pretty&quot;</span> -H &#x27;Content-Type<span class="punctuation">:</span> application/json&#x27; -d&#x27;</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2099-05-06T16:21:15.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.0.2.42 - - [06/May/2099:16:21:15 +0000] \&quot;GET /images/bg.jpg HTTP/1.0\&quot; 200 24736&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET logs-my_app-default/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE _data_stream/logs-my_app-default</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST mytest/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mytest&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dec&quot;</span><span class="punctuation">:</span> <span class="string">&quot;there is desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT mytest/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mytest&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dec&quot;</span><span class="punctuation">:</span> <span class="string">&quot;there is desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h5><p>建议使用介个（成本低嘛主要是）</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">POST /_sql?format=txt</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SELECT * FROM mytest&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Mapping-（数据库表结构）"><a href="#Mapping-（数据库表结构）" class="headerlink" title="Mapping （数据库表结构）"></a>Mapping （数据库表结构）</h3><h2 id="第四期-1"><a href="#第四期-1" class="headerlink" title="第四期"></a>第四期</h2><ol><li><p>继续ElasticStack</p></li><li><p>学习用Java来调用ElasticStack</p></li><li><p>使用es优化聚合搜索接口</p></li><li><p>已有的DB的数据和ES数据同步（增量，全量，实时，非实时）</p></li><li><p>jeter压力测试</p></li><li><p>保证接口稳定性</p></li><li><p>其他拓展思路</p></li></ol><p>ES索引(index) &#x3D;&gt; 表</p><p>ES field （字段） &#x3D;&gt; 列</p><p>倒排索引</p><p>构建倒排索引表：</p><table><thead><tr><th>词</th><th>内容 id</th></tr></thead><tbody><tr><td>你好</td><td>文章 A，B</td></tr><tr><td>我是</td><td>文章 A，B</td></tr><tr><td>rapper</td><td>文章 A</td></tr><tr><td>鱼皮</td><td>文章 B</td></tr><tr><td>coder</td><td>文章 B</td></tr></tbody></table><p>调用语法（DSL,EQL,SQL)</p><p>Mapping(表结构)</p><ul><li><p>自动生成mapping</p></li><li><h6 id="手动指定mapping"><a href="#手动指定mapping" class="headerlink" title="手动指定mapping"></a>手动指定mapping</h6></li></ul><h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><p>分词的一种规则</p><p>空格分词器： whitespace</p><p>标准分词</p><p>关键词分词器：不分词，将整句话作为专业术语</p><h4 id="IK-分词器-ES插件"><a href="#IK-分词器-ES插件" class="headerlink" title="IK 分词器 (ES插件)"></a>IK 分词器 (ES插件)</h4><p>中文友好</p><p>下载地址：</p><p>怎么样让ik按自己的想法分词？</p><p>自定义词典</p><p>ik_smart 和ik_max_word 区别？</p><p>贪心和滑动窗口（bushi）</p><h4 id="打分机制"><a href="#打分机制" class="headerlink" title="打分机制"></a>打分机制</h4><p>内容：</p><ol><li>鱼皮是狗</li><li>鱼皮是小黑子</li><li>我是小黑子</li></ol><p>用户搜索：</p><ol><li>鱼皮——-&gt;第一条分数最高，相当于  2&#x2F;4（匹配了，而且更短（匹配比例大）</li></ol><h4 id="es调用方式（Java"><a href="#es调用方式（Java" class="headerlink" title="es调用方式（Java"></a>es调用方式（Java</h4><p>1）ES 官方的 Java API<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/introduction.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/introduction.html</a><br>快速开始：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/connecting.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.17/connecting.html</a></p><p>2）ES 以前的官方 Java API，HighLevelRestClient（已废弃，不建议用）</p><p>3）Spring Data Elasticsearch（推荐）</p><p>spring-data 系列：spring 提供的操作数据的框架<br>spring-data-redis：操作 redis 的一套方法<br>spring-data-mongodb：操作 mongodb 的一套方法<br>spring-data-elasticsearch：操作 elasticsearch 的一套方法</p><p>官方文档：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/4.4.10/reference/html/">https://docs.spring.io/spring-data/elasticsearch/docs/4.4.10/reference/html/</a></p><p>自定义方法：用户可以指定接口的方法名称，框架帮你自动生成查询</p><p>用es实现搜索接口</p><p>1.建立索引（建表）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 新东西，后端项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx踩坑之旅</title>
      <link href="/2024/03/27/Linux/"/>
      <url>/2024/03/27/Linux/</url>
      
        <content type="html"><![CDATA[<p>description:  三行太多了，写不来</p><hr><hr><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="文件基本操作篇"><a href="#文件基本操作篇" class="headerlink" title="文件基本操作篇"></a>文件基本操作篇</h3><p>这里主要是描述文件的移动，复制，粘贴，额，后续学的多了自然有更多操作，俺现在不知道啊。。。</p><h4 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//创建新的文件。。。</span><br><span class="line">touch your_file </span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">mkdir your_directories</span><br><span class="line">//创建多级目录加入参数</span><br><span class="line">mkdir -p father/son/grandson</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line"><span class="meta prompt_">cp---&gt;</span><span class="language-bash">文件复制</span></span><br><span class="line">cp your_file father/son/grandson</span><br><span class="line"></span><br><span class="line">复制目录的话需要加入参数-r | -R</span><br><span class="line">cp -r father family</span><br><span class="line">--------------</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">rm---&gt;</span><span class="language-bash">删除文件,嗨嗨删库跑路 sudo <span class="built_in">rm</span> -rf /*</span></span><br><span class="line">-f是如果想忽略g提示，直接删除文件，可以使用 -f 参数强制删除： -r递归执行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mv---&gt;</span><span class="language-bash">移动文件，类似于Ctrl+x</span></span><br><span class="line">mv 源文件 目的目录</span><br><span class="line">mv test_file Documents </span><br><span class="line"></span><br><span class="line">--新玩法 重命名-----------&gt; mv 旧的文件名 新的文件名</span><br><span class="line">mv your_file new_your_file</span><br><span class="line"></span><br><span class="line">---批量重命名(rename)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先批量创建文件</span></span><br><span class="line">touch your_file&#123;1..5&#125;.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量改名--额，我的建议是去隔壁Java8看看正则表达式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不过这里还有涉及到sed命令，所以先写着，鸽子一下</span></span><br><span class="line">rename &#x27;s/\.txt/\.c/&#x27; *.txt</span><br></pre></td></tr></table></figure><h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><p><code>cat</code> —<code>tac</code> —<code>nl</code></p><p>如其名，tac是倒序显示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n passwd 加上-n显示行号</span><br><span class="line"></span><br><span class="line">nl 命令，添加行号并打印，这是个比 cat -n 更专业的行号打印命令。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-b : 指定添加行号的方式，主要有两种：</span><br><span class="line">    -b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)</span><br><span class="line">    -b t:只列出非空行的编号并列出（默认为这种方式）</span><br><span class="line">-n : 设置行号的样式，主要有三种：</span><br><span class="line">    -n ln:在行号字段最左端显示</span><br><span class="line">    -n rn:在行号字段最右边显示，且不加 0</span><br><span class="line">    -n rz:在行号字段最右边显示，且加 0</span><br><span class="line">-w : 行号字段占用的位数(默认为 6 位)</span><br></pre></td></tr></table></figure><p>额，more和less讲得没这么多，鸽掉！！相当于只显示一个屏幕的信息而不是像cat那样，信息太多了，会让你的屏幕向下移动</p><p><code>tail head</code></p><p>这俩就相当于一个显示倒数几行，一个正数几行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n 10 /etc/passwd</span>                </span><br></pre></td></tr></table></figure><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><p><code>file</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file your_file.xxx</span><br></pre></td></tr></table></figure><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p><code>whereis which find locate</code></p><p>挺多哈，find的话我感觉最重要。。目前我是用的多一些</p><hr><p><code>whereis</code> 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 <code>locate</code> 命令。</p><hr><p>locate则不是内置命令，需要去安装，而且每次查找之前偶尔还得更新一下数据库</p><p>直接cv过来算了</p><blockquote><p>使用 <code>locate</code> 命令查找文件也不会遍历硬盘，它通过查询 <code>/var/lib/mlocate/mlocate.db</code> 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 <code>updatedb</code> 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 <code>updatedb</code> 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，例如在我们的环境中就需要手动安装，然后执行更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;$ sudo apt-get update</span><br><span class="line">&gt;$ sudo apt-get install locate</span><br><span class="line">&gt;$ sudo updatedb</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>它可以用来查找指定目录下的不同文件类型，如查找 &#x2F;etc 下所有以 sh 开头的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locate /etc/sh</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>这个需要记得的还有，使用通配符的时候记得加上转义符号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate /usr/share/\*.jpg</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;which鸽掉，俺也还没用过</p><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>这个我觉得确实得单独拎出来,因为他这个-exec看着就很吊</p><blockquote><p>find [path][option] [action] </p></blockquote><p>先来讲讲参数吧</p><ul><li><p>-name  文件名匹配</p></li><li><p>-mtime 最后修改文件属性的时间 </p><ul><li><code>-mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li><li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li><li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li><li><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li></ul></li><li><p>-size  文件大小    +表示大于，-表示小于 默认单位b </p></li><li><p>-exec 对搜索到的文件进行命令, such 重命名，删除，移动</p><ul><li><pre><code class="shell">find ~ -size +1 -exec mv &#123;&#125; /temp \;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - \;表示结束符号</span><br><span class="line">  </span><br><span class="line">- &#123;&#125;表示占位符，表示搜索到的文件</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 文件打包，压缩篇</span><br><span class="line"></span><br><span class="line">这里描述的是关于zip，tar，gzip相关知识。</span><br><span class="line"></span><br><span class="line">#### tar相关</span><br><span class="line"></span><br><span class="line">- `-x`: 提取（解压）文件</span><br><span class="line">- `-z`: 使用gzip压缩格式</span><br><span class="line">- `-v`: 显示详细的输出信息</span><br><span class="line">- `-f`: 指定要操作的文件</span><br><span class="line">- `--wildcards`: 启用通配符模式</span><br><span class="line">- `&#x27;*example*&#x27;`: 匹配所有文件名中包含&quot;example&quot;的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 休闲娱乐</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">xeyes</span><br><span class="line"></span><br><span class="line">nohup xeyes &amp;//h</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="在Linux中使用帮助、"><a href="#在Linux中使用帮助、" class="headerlink" title="在Linux中使用帮助、"></a>在Linux中使用帮助、</h3><p>这个玩意难受哟，help，man，这些。。。感觉目前不太适合咱</p><h3 id="开发分割线——————————————"><a href="#开发分割线——————————————" class="headerlink" title="开发分割线——————————————-"></a>开发分割线——————————————-</h3><hr><h2 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h2><h3 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新东西 </tag>
            
            <tag> centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8基础知识</title>
      <link href="/2024/03/22/Java%E5%9F%BA%E7%A1%80/Java8/"/>
      <url>/2024/03/22/Java%E5%9F%BA%E7%A1%80/Java8/</url>
      
        <content type="html"><![CDATA[<p>daisiki，在此见证Java8的预习，啊不，学习记录。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习</title>
      <link href="/2024/03/22/Java%E5%9F%BA%E7%A1%80/SpringCloud/"/>
      <url>/2024/03/22/Java%E5%9F%BA%E7%A1%80/SpringCloud/</url>
      
        <content type="html"><![CDATA[<p>首先的话还是感谢黑马提供的快速入门课程。当然，仅仅是快速入门。</p><blockquote><p>视频如下：</p></blockquote><p><a href="https://www.bilibili.com/video/BV1kH4y1S7wz/?share_source=copy_web&vd_source=3362e6914fb759983690e6e0f1072453">https://www.bilibili.com/video/BV1kH4y1S7wz/?share_source=copy_web&amp;vd_source=3362e6914fb759983690e6e0f1072453</a></p><p>在课前资料中给大家提供了黑马商城项目的资料，先导入这个单体项目。不过需要注意的是，你必须做好一些准备：</p><ul><li>Centos7的环境及一个好用的SSH客户端</li><li>安装好Docker</li><li>会使用Docker</li></ul><p>如果你没有这样的Linux环境，或者不是Centos7的话，那么这里有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc">Linux环境搭建</a></li></ul><p>建议按照上面的文档来搭建虚拟机环境，使用其它版本会出现一些环境问题，比较痛苦。</p><p>如果已经有Linux环境，但是没有安装Docker的话，那么这里还有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">安装Docker</a></li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>例如，黑马商城项目，我们就可以把商品、用户、购物车、交易等模块拆分，交给不同的团队去开发，并独立部署：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTczOGY5ODE1ZjBjZGMzMTY1M2Q1MzQzNTkwMDFlMTNfbUN4UFJmYmdkb2xvclZsNGFwbEhIbzk1a0tsSW9qYVJfVG9rZW46WjR1YmJRaG01b1hxQ1V4MGhvYWNDazg4blFnXzE3MTQ4MDkxNDI6MTcxNDgxMjc0Ml9WNA" alt="img"></p><p>那么，单体架构存在的问题有没有解决呢？</p><ul><li>团队协作成本高？<ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li></ul></li><li>系统发布效率低？<ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li>系统可用性差？<ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务。</li></ul></li></ul><p>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正式分布式架构的一种最佳实践的方案。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>其中我们将会学到Nacos，OpenFeign,Gateway,Sentinel的使用</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZmYzJmNGNmNGQ2NjM2OWM0YTQ4ODg1Nzc3ZTQ2M2ZfRjlodjBaMW5zRmxRYTdDSUdITjVDbHNVVU50UFhRZ0ZfVG9rZW46VjZJTGI5aW1Vb2U5Y1p4NmxsNWNtMG15bnpjXzE3MTQ4MDkyMDg6MTcxNDgxMjgwOF9WNA" alt="img"></p><p>而且SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择了！</p><h3 id="单体项目拆分为微服务"><a href="#单体项目拆分为微服务" class="headerlink" title="单体项目拆分为微服务"></a>单体项目拆分为微服务</h3><p>将每个板块单独拆分出来，变成一个个微服务。比如，购物车、商品、支付、用户这些都能够提取为单独的一个模块。</p><h4 id="怎么拆"><a href="#怎么拆" class="headerlink" title="怎么拆"></a>怎么拆</h4><p>之前我们说过，微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析：</p><ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li><li><strong>低耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li></ul><p><strong>高内聚</strong>首先是<strong>单一职责，</strong>但不能说一个微服务就一个接口，而是要保证微服务内部业务的完整性为前提。目标是当我们要修改某个业务时，最好就只修改当前微服务，这样变更的成本更低。</p><p>一旦微服务做到了高内聚，那么服务之间的<strong>耦合度</strong>自然就降低了。</p><p>当然，微服务之间不可避免的会有或多或少的业务交互，比如下单时需要<strong>查询商品数据</strong>。这个时候我们不能在订单服务直接查询商品数据库，否则就导致了数据耦合。而应该由<strong>商品服务对应暴露接口</strong>，并且一定要保证微服务对外<strong>接口的稳定性</strong>（即：尽量保证接口外观不变）。虽然出现了服务间调用，但此时无论你如何在商品服务做内部修改，都不会影响到订单微服务，服务间的耦合度就降低了。</p><p>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：</p><ul><li><strong>纵向</strong>拆分</li><li><strong>横向</strong>拆分</li></ul><p>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</p><p>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</p><p>一般微服务项目有两种不同的工程结构：</p><ul><li>完全解耦：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li>Maven聚合：整个项目为一个Project，然后每个微服务是其中的一个Module<ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><p>我们这里使用纵向拆分的形式，以及Maven聚合。</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZmNjliMjY3ZTQ2NjI3MmUyMWNkODI1OGM3Mzg1ZjBfMkpBSlNhcXNlSkdqalVTVklDZ0dXU0dnZFd6a3BjS0NfVG9rZW46VllxV2JOT1dYb1l6Z3h4eDVZYmNBaG9vbmpjXzE3MTQ4MDk2Mjc6MTcxNDgxMzIyN19WNA" alt="img"></p><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240504160115662.png" alt="image-20240504160115662"></p><p>拆分的时候，可以优先把controller拆过去，如果合理的话，一般名字就已经对应好了。然后根据引入的类再进行迁移。</p><p>拆分环境就不多说了，这里变化很多，最好根据实际情况灵活变通。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>拆分后不可避免的出现很多的问题。由于项目之间完全没有耦合，也就意味着，两个微服务之间无法进行相互调用，显然是不行的，就像购物车不可能不调用商品服务。而且大多数服务也都需要获取用户信息啊。</p><p>因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（<strong>RPC</strong>，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>因此，现在查询购物车列表的流程变成了这样：</p><p><img src="https://img2.imgtp.com/2024/05/04/xpPZmPhQ.png" alt="img"></p><p>代码中需要变化的就是这一步：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZiZmI4MjA2NWJhNTlmZjcyNWEzMWUzYjU5NDQzYWNfNDdDVTVSajJ6TnVnbmc0M2ZsU3dvR2JmNmJ0UnNNVmZfVG9rZW46QWFHVmJBc0s3bzY2Ukd4anJKM2N6VWs5bk9oXzE3MTQ4MTAyMzM6MTcxNDgxMzgzM19WNA" alt="img"></p><p>类似思路的话，就跟我们前端获取数据，或者使用爬虫的时候很类似。通过使用http请求去调用。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><blockquote><p>Spring给我们提供了RestTemplate的APi，可以方便实现发送Http请求（也可用来搞爬虫）</p></blockquote><p>先将RestTemplate注册为一个Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; exchange = restTemplate.exchange(</span><br><span class="line">               <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>, <span class="comment">//请求路径</span></span><br><span class="line">                HttpMethod.GET,  <span class="comment">//请求方法</span></span><br><span class="line">                <span class="literal">null</span>,   <span class="comment">//请求实体</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<span class="comment">//返回值类型               </span></span><br><span class="line">               Map.of(<span class="string">&quot;ids&quot;</span> ,CollUtils.join(itemIds, <span class="string">&quot;,&quot;</span>)) <span class="comment">//传入参数</span></span><br><span class="line">       );</span><br><span class="line"><span class="comment">//解析响应</span></span><br><span class="line">    <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">        <span class="comment">// 查询失败，直接结束</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ItemDTO&gt; items = response.getBody();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>爬虫用起来也还好，其实主要是信息筛选老火</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(</span><br><span class="line">            <span class="string">&quot;https://www.bing.com/images/search?q=明日方舟德克萨斯&quot;</span>,</span><br><span class="line">            HttpMethod.GET,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;String&gt;() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> exchange.getBody();</span><br><span class="line">    System.out.println(<span class="string">&quot;body = &quot;</span> + body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>上述调用我们也发现了问题，就是必须知道调用的具体地址，但是实际开发我们都分成好几个小组了，总不能每次改端口都口口相传，那服务宕机了该怎么办？</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h4 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h4><p>其实就有点类似于学校管理一样，只不过这个更快。</p><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQwMzk1NjhhOTE3MmVmMjlhNWQ4MjcwMzQxNDU1NTRfRGxSMnVjU3BWOExZRTZRZTh6d09adG1sdDZtbnRJaGdfVG9rZW46STU4NWJ5bVVNb2FQU0J4bXpkVWNveGY2bmNmXzE3MTQ4MTE4MDI6MTcxNDgxNTQwMl9WNA" alt="img"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><blockquote><p>就跟老师找学生一样,不需要到处找,去教务系统查询你的相关信息然后去教室或者你家堵你就行了.(额,别杠,不然你对)</p></blockquote><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>使用Nacos前,需要使用数据库保存一些信息,所以先准备好MySQL数据库表.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- --------------------------------------------------------</span><br><span class="line">-- 主机:                           192.168.87.132</span><br><span class="line">-- 服务器版本:                        8.0.27 - MySQL Community Server - GPL</span><br><span class="line">-- 服务器操作系统:                      Linux</span><br><span class="line">-- HeidiSQL 版本:                  12.2.0.6576</span><br><span class="line">-- --------------------------------------------------------</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!50503 SET NAMES utf8mb4 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 导出 nacos 的数据库结构</span><br><span class="line">DROP DATABASE IF EXISTS `nacos`;</span><br><span class="line">CREATE DATABASE IF NOT EXISTS `nacos` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.config_info 结构</span><br><span class="line">DROP TABLE IF EXISTS `config_info`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `config_info` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  `c_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `c_use` varchar(64) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `effect` varchar(64) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `type` varchar(64) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `c_schema` text COLLATE utf8_bin,</span><br><span class="line">  `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `config_info`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.config_info_aggr 结构</span><br><span class="line">DROP TABLE IF EXISTS `config_info_aggr`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `config_info_aggr` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `datum_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;datum_id&#x27;,</span><br><span class="line">  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;内容&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `config_info_aggr`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.config_info_beta 结构</span><br><span class="line">DROP TABLE IF EXISTS `config_info_beta`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `config_info_beta` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `beta_ips` varchar(1024) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;betaIps&#x27;,</span><br><span class="line">  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `config_info_beta`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.config_info_tag 结构</span><br><span class="line">DROP TABLE IF EXISTS `config_info_tag`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `config_info_tag` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tag_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `config_info_tag`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.config_tags_relation 结构</span><br><span class="line">DROP TABLE IF EXISTS `config_tags_relation`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `config_tags_relation` (</span><br><span class="line">  `id` bigint NOT NULL COMMENT &#x27;id&#x27;,</span><br><span class="line">  `tag_name` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_name&#x27;,</span><br><span class="line">  `tag_type` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tag_type&#x27;,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `nid` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `config_tags_relation`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.group_capacity 结构</span><br><span class="line">DROP TABLE IF EXISTS `group_capacity`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `group_capacity` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,</span><br><span class="line">  `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `group_capacity`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.his_config_info 结构</span><br><span class="line">DROP TABLE IF EXISTS `his_config_info`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `his_config_info` (</span><br><span class="line">  `id` bigint unsigned NOT NULL,</span><br><span class="line">  `nid` bigint unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `data_id` varchar(255) COLLATE utf8_bin NOT NULL,</span><br><span class="line">  `group_id` varchar(128) COLLATE utf8_bin NOT NULL,</span><br><span class="line">  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext COLLATE utf8_bin NOT NULL,</span><br><span class="line">  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `src_user` text COLLATE utf8_bin,</span><br><span class="line">  `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `op_type` char(10) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `his_config_info`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.permissions 结构</span><br><span class="line">DROP TABLE IF EXISTS `permissions`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `permissions` (</span><br><span class="line">  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  `resource` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  `action` varchar(8) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `permissions`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.roles 结构</span><br><span class="line">DROP TABLE IF EXISTS `roles`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `roles` (</span><br><span class="line">  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span><br><span class="line">DELETE FROM `roles`;</span><br><span class="line">INSERT INTO `roles` (`username`, `role`) VALUES</span><br><span class="line">(&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.tenant_capacity 结构</span><br><span class="line">DROP TABLE IF EXISTS `tenant_capacity`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `tenant_capacity` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,</span><br><span class="line">  `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,</span><br><span class="line">  `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `tenant_capacity`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.tenant_info 结构</span><br><span class="line">DROP TABLE IF EXISTS `tenant_info`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `tenant_info` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `kp` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;kp&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tenant_name` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,</span><br><span class="line">  `tenant_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,</span><br><span class="line">  `create_source` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;create_source&#x27;,</span><br><span class="line">  `gmt_create` bigint NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` bigint NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span><br><span class="line">DELETE FROM `tenant_info`;</span><br><span class="line"></span><br><span class="line">-- 导出  表 nacos.users 结构</span><br><span class="line">DROP TABLE IF EXISTS `users`;</span><br><span class="line">CREATE TABLE IF NOT EXISTS `users` (</span><br><span class="line">  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  `password` varchar(500) COLLATE utf8mb4_general_ci NOT NULL,</span><br><span class="line">  `enabled` tinyint(1) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`username`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span><br><span class="line">DELETE FROM `users`;</span><br><span class="line">INSERT INTO `users` (`username`, `password`, `enabled`) VALUES</span><br><span class="line">(&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, 1);</span><br><span class="line"></span><br><span class="line">/*!40103 SET TIME_ZONE=IFNULL(@OLD_TIME_ZONE, &#x27;system&#x27;) */;</span><br><span class="line">/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, &#x27;&#x27;) */;</span><br><span class="line">/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中的<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PREFER_HOST_MODE</span>=<span class="string">hostname</span></span><br><span class="line"><span class="attr">MODE</span>=<span class="string">standalone</span></span><br><span class="line"><span class="attr">SPRING_DATASOURCE_PLATFORM</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_HOST</span>=<span class="string">192.168.87.132</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_DB_NAME</span>=<span class="string">nacos</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_PORT</span>=<span class="string">3306</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_USER</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_PASSWORD</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">MYSQL_SERVICE_DB_PARAM</span>=<span class="string">characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure><p>使用docker进行部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nacos \</span><br><span class="line">--env-file ./nacos/custom.env \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--restart=always \</span><br><span class="line">nacos/nacos-server:v2.1.0-slim</span><br></pre></td></tr></table></figure><p>Java项目中添加下列依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.78</span><span class="number">.132</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>启动项目后就可以看到nacos控制台中,服务列表有对应内容.</p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><p><strong>提供者和消费者都需要在nacos中进行注册</strong></p><p>服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRkOGM5MzZmNGI0ZWY1N2FjMzg4MjQzNTVkMWIyNzlfYTlOQW1ZV2lEUTY1d2dhTEp6c3BlSUQ0cVBzdUtTR2NfVG9rZW46TVhydGJIWHNEb1JEU0p4cXdRQ2NsNDlVbm1lXzE3MTQ4MTI0NTk6MTcxNDgxNjA1OV9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据服务名称从注册中心拉取实例</span></span><br><span class="line">     List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//随机选择一个实例</span></span><br><span class="line">     <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line">     <span class="comment">//获取实例的端口地址</span></span><br><span class="line">     <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> instance.getUri();</span><br><span class="line">    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; exchange = restTemplate.exchange(</span><br><span class="line">             uri+<span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">             HttpMethod.GET,</span><br><span class="line">             <span class="literal">null</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">             &#125;,</span><br><span class="line">            Map.of(<span class="string">&quot;ids&quot;</span> ,CollUtils.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p>这里主要就是能实现动态化.有新服务的时候可以得知,服务死了也能得知并更换.且无需重启项目!(这里的原理我觉得有必要了解一下)</p><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>使用RestTemplate加上Nacos后虽然灵活,但是感觉挺麻烦的,而且由于灵活的话,包装为一个函数感觉更不太容易了.</p><p>所以可以使用接口的形式进行统一.</p><p>我感觉更重要的是,微服务调用更偏向于本地调用,用Rest Template调用浏览器那些更舒服.</p><p>远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p><code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类上添加注解，启动OpenFeign功能：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiOGEyYTVjOGRmZjQ1ZTYwMmFkYzQ3MjY1M2I0YzBfTktmNUdWMXZ6VW1TVlBsS05UdDN1dHY0ejFZOEZteDNfVG9rZW46SnNnbGJTNG5Ebzl4RnV4S2JQQmNMYkRubjFmXzE3MTQ4MTI5OTQ6MTcxNDgxNjU5NF9WNA" alt="img"></p><h4 id="OpenFeign客户端"><a href="#OpenFeign客户端" class="headerlink" title="OpenFeign客户端"></a>OpenFeign客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, // 服务名称,在Application.yaml中有配置</span></span><br><span class="line"><span class="meta">        configuration = DefaultConfig.class,  </span></span><br><span class="line"><span class="meta">        fallbackFactory = ItemClientFallback.class)</span> <span class="comment">//后话了,回调函数.服务熔断会使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span>  <span class="comment">//请求路径</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt;items)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到,跟mvc的使用很类似.</p><p>其他服务调用时只需要依赖注入ItemClient,然后就能直接进行使用</p><h4 id="连接池-了解"><a href="#连接池-了解" class="headerlink" title="连接池(了解?)"></a>连接池(了解?)</h4><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h3 id="抽取客户端"><a href="#抽取客户端" class="headerlink" title="抽取客户端"></a>抽取客户端</h3><p>刚刚的实践中不难发现,由于服务之间已经隔离,采用http远程调用就能获取数据了,但是的话就算使用Openfegin后代码仍会很冗余,毕竟远程调用的地方很多,那代码重复也会很多,我们需要在每个微服务都建立很多个客户端?</p><p>避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p>如图：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTBlNjgyMzAzMzIxZmYwMTVlYjFkYTk3OTMxZDM2ZDZfR05zaHN3amRIbERKWGpQdHFkM2h5Vk9SM1dZOEhlMnBfVG9rZW46T2w3N2JNOEZib1pmN2R4aDR5dmNOWVRBblFoXzE3MTQ4MTM1ODI6MTcxNDgxNzE4Ml9WNA" alt="img"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>第一种的话我是比较喜欢的,虽然会引入其他用不着的客户端.第二种感觉pom文件会很不得了.</p><p>(其实吧,是快速入门用第一种,两种还是根据实际情况分析)</p><p>第一种也有点冗余的,毕竟你得把dto也搞到api模块里面,所以第二种感觉适合大型项目</p><p><strong>使用时,在service的启动类上添加声明即可，两种方式：</strong></p><ul><li>方式1：声明扫描包：</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I3ZWU5NmU2MGYxY2NlMzVhYzExMGUyNDcwMmU4MmVfQ1Jkek5kTnZhMlh3MEgwY1Q2ajRSMjdQSElNMTY1MWZfVG9rZW46SEhHdGJseFVhb3JvdGF4bzNwNGNMa0ZzbkVjXzE3MTQ4MTM5NDc6MTcxNDgxNzU0N19WNA" alt="img"></p><ul><li>方式2：声明要用的FeignClient</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MDRkMzQ1YTgyNzA2ZmNiYTVlYWRkNWJlNGI3OGRlMmJfSzVOT2xURG11M1BmWWEzWFNncENIREVMY1JqbEJCTmpfVG9rZW46TmU0OWJWU3VobzlKY3Z4MkNOeWNPd0kybnlnXzE3MTQ4MTM5NDc6MTcxNDgxNzU0N19WNA" alt="img"></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>在微服务中,用户登录后得到的jwt令牌怎么传递是个问题.当然使用redis存储是个办法(我个人想到的是这种方法)</p><h3 id="认识网关"><a href="#认识网关" class="headerlink" title="认识网关"></a>认识网关</h3><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p><ul><li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li><li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=M2YyMDQwYjViMjYxYzM3NjI3OTc0ZTdjOTRkYTU3ZGVfdDFBTVJabGJmcGE0QU9CendCam1qZ1NlTzlNUW5ndzNfVG9rZW46TU9tZWJQTjhob1RDVmh4TjF0VGNicVVobmdoXzE3MTQ4MTQxOTU6MTcxNDgxNzc5NV9WNA" alt="img"></p><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YzljYjRjM2Y0ZDhjMjgxNDU3YjM3MTkwYjYzYTdiN2FfN3hxOGczQ3BiVXpiTks4bWJNV096WjVQVVhtMWJCeVVfVG9rZW46WFdmaWJuMUpKb0loM0x4V21SdGNneHVsbm9lXzE3MTQ4MTQxOTU6MTcxNDgxNzc5NV9WNA" alt="img"></p><p>感觉有点类似于设计模式的门卫模式?</p><p>O(∩_∩)O</p><p>我们这里采用SpringcloudGateway实现网关功能</p><ul><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>官方网站：</p><p><a href="https://spring.io/projects/spring-cloud-gateway#learn">https://spring.io/projects/spring-cloud-gateway#learn</a></p><p><strong>大概步骤如下：</strong></p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><p>额,可以发现,又用到了nacos.毕竟守门老大爷也需要知道名册表查询啊.</p><p>gateway模块引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span>  <span class="string">//正好前端请求的是8080端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="路由过滤"><a href="#路由过滤" class="headerlink" title="路由过滤"></a>路由过滤</h3><p>这里的话就耗子尾汁吧.感觉没怎么用上这里.</p><p>感觉后面可以做很多文章.这种加请求头,和过滤啊什么的</p><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h2 id="鉴权思路分析"><a href="#鉴权思路分析" class="headerlink" title="鉴权思路分析"></a>鉴权思路分析</h2><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>此时，登录校验的流程如图：</p><p><img src="https://img2.imgtp.com/2024/05/04/fy1GYbNn.png" alt="img"></p><p>不过这里存在问题:</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？</li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><h4 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h4><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="https://img2.imgtp.com/2024/05/04/R3khRwWh.png" alt="img"></p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到</strong><code>NettyRoutingFilter</code>之前，这就符合我们的需求了！</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li></ul><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。最简单的方式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行了&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！</p><p>然后在yaml配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>动态参数配置这里就不说了,我也没怎么用到,还不大懂应用</p><h3 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h3><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h3><p>登录校验的过滤器感觉跟拦截器的写法也挺类似的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTool jwtTool; jwt工具</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> AuthProperties authProperties;   <span class="comment">//路径配置,在yaml读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>(); <span class="comment">//路径匹配的一个工具</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//获取request</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"><span class="comment">//        判断路径是否需要拦截</span></span><br><span class="line">        <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath();</span><br><span class="line">        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();</span><br><span class="line">        <span class="keyword">if</span> (isExclude(path.toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);<span class="comment">//放行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取请求头</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        List&lt;String&gt; authorization = headers.get(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String token=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!CollUtils.isEmpty(authorization))&#123;</span><br><span class="line">           token= authorization.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        log.error(token);</span></span><br><span class="line">        <span class="comment">//解析请求头获取用户信息</span></span><br><span class="line">        Long userId=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信息传递</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span>userId.toString();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;userId = &quot; + userId);</span></span><br><span class="line">        <span class="type">ServerWebExchange</span> <span class="variable">swe</span> <span class="operator">=</span> exchange.mutate().request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userInfo))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(swe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExclude</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();</span><br><span class="line">        <span class="keyword">for</span> (String excludePath : excludePaths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(excludePath, path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="微服务获取用户信息"><a href="#微服务获取用户信息" class="headerlink" title="微服务获取用户信息"></a>微服务获取用户信息</h2><p>网关拦截方面实现了,但是微服务内部之间需要互相传递信息啊</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><p>据图流程图如下：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=M2MwZWFlY2FiZDFmZjFkMGRlNTkzNDQ1ZmQ4ZWY5NzFfRE01bkEzc0hIWXNkYXU5OHA3VG5iNmZ3VzM0emhuQVNfVG9rZW46S2h4RWI2cmpCb05yVkN4c2VoTGNGUExFblNkXzE3MTQ4MTgyOTA6MTcxNDgyMTg5MF9WNA" alt="img"></p><p>因此，接下来我们要做的事情有：</p><ul><li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务(上面的代码已经携带了)</li><li>编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行</li></ul><p>在common模块中编写登录拦截器.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span><span class="comment">//自动装配条件,指定mvc</span></span><br><span class="line"><span class="comment">///DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-Info&quot;</span>);</span><br><span class="line">        <span class="comment">//是否获取用户，存入threadLocal</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(userInfo))&#123;</span><br><span class="line">            UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>需要注意的是，这个配置类默认是不会生效的，因为它所在的包是<code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。</strong></p><p>基于SpringBoot的自动装配原理，我们要将其添加到<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NGJmMjVlM2JjNGE4NTc4NTkzMmFlZjY3ZTY4YjJkYWZfREJyZVc0djR3ZWtxcVJTeHZEMmFEck1FTXVhT2lvdUlfVG9rZW46RlNyeWJtS1Jqb04xdWV4QUtCRGNFY3o2blZkXzE3MTQ4MTg1OTM6MTcxNDgyMjE5M19WNA" alt="img"></p><p>内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MyBatisConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MvcConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.JsonConfig</span></span><br></pre></td></tr></table></figure><h3 id="Openfegin传递用户"><a href="#Openfegin传递用户" class="headerlink" title="Openfegin传递用户"></a>Openfegin传递用户</h3><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTMxZmJjNTRmOTI0MDA0ODhmZWE4MDIyM2M3MDExNWFfbkxwNXlvczloUUlJRXBlWGJndmFVV2pmangxeTJSbWhfVG9rZW46WXA1WGI2ZWFQbzVWYlN4dFFzUGNCa0piblhsXzE3MTQ4MTg5NTM6MTcxNDgyMjU1M19WNA" alt="img"></p><p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda简化(可读性感觉不太好,)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultConfig</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> requestTemplate -&gt; &#123;</span><br><span class="line">           <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">           <span class="keyword">if</span>(userId!=<span class="literal">null</span>)&#123;</span><br><span class="line">               requestTemplate.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;,</span></span><br><span class="line"><span class="meta">        configuration = DefaultConfig.class)</span> <span class="comment">//配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt;items)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>我们已经解决微服务中几个问题了,小项目基本就ok了</p><ul><li>微服务之间的远程调用</li><li>微服务的注册和发现(nacos)</li><li>微服务请求路由和负载均衡</li><li>微服务之间用户信息传递</li></ul><p>现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YzI1YTA1N2FkODI3ZjNlNTVlODcwNjY5NWQ3OTIyNDhfcUxvTm9OT3R2OE5UcUREQXRLaEF4elo4c2VyeE9kak9fVG9rZW46RTZhSGI0MGdZb0RNMTF4TVVOS2M0YzZabnhmXzE3MTQ4MTk0NTU6MTcxNDgyMzA1NV9WNA" alt="img"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><p>感觉有点小牛批哈这个nacos,但是它是怎么做到的,俺很好奇.</p><h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h3 id="添加共享配置"><a href="#添加共享配置" class="headerlink" title="添加共享配置"></a>添加共享配置</h3><p>以cart-service为例，我们看看有哪些配置是重复的，可以抽取的：</p><p>首先是jdbc相关配置：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YTc2MDI0ODIxNjBhOWE2Zjk1MDgyNjk2YmNiOWE0NGNfajFoOFlGSHBxdDNkVkFQVnA3RXhKeXc0ZkxlWTJPOHNfVG9rZW46U0d6TGJjOU9ob21YckJ4THd5ZmNqT1I4blRiXzE3MTQ4MTk5NTg6MTcxNDgyMzU1OF9WNA" alt="img"></p><p>然后是日志配置：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MzJmZDM5NGNkZGVlZGUyYTJjNjIzOWViMGZjYTE4ZDRfalpYN3hHcjZQQVBiaTJkVFcwenJjWENLeWxNRWJMSFZfVG9rZW46SER6WGJNb09ob3V6Wk54YjBzZGN0YzJNbnFnXzE3MTQ4MTk5NTg6MTcxNDgyMzU1OF9WNA" alt="img"></p><p>然后是swagger以及OpenFeign的配置：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU0YzdlODYxYTZiYTQwZmNkOGU5M2QwYTVlNzM5ZTBfblp5bjZYSWkzR2tTR3pPMTk3Qk1pbEowNlpTVDN5UTlfVG9rZW46UkhrT2J0bG1jb2dHdTF4WFRsVWNlR2lsbm9iXzE3MTQ4MTk5NTg6MTcxNDgyMzU1OF9WNA" alt="img"></p><p>在nacos中添加相应的配置.</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFjODBiZjhlYTUwMmJhMDhhNTY5OTQ3NWNkMjBhMTVfNVI2SlZ5Q05yMWQ3eUoyTEFRVk5OMXpCSHROSjVaaHRfVG9rZW46RU52YmJNMkNmb1dhVFh4MkJkUGNEanlzbkVjXzE3MTQ4MTk5ODE6MTcxNDgyMzU4MV9WNA" alt="img"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host:192.168.87.132&#125;:$&#123;hm.db.port:3306&#125;/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.db.un:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw:123&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><p>改为hm.db.host:192.168.87.132,即默认为虚拟机ip地址,但是有值的话就用配置的值</p><h3 id="拉取共享配置"><a href="#拉取共享配置" class="headerlink" title="拉取共享配置"></a>拉取共享配置</h3><p>接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了。</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQ2NjQxNmU3MmFjMTJhMTMxYmQ2NTYxOGU0OTBjYTZfZWJZd2RZaGRoTUVuTVJCcVQwWHhIR2Z3VjNYNHpoTnlfVG9rZW46TGlkdWJianlob0Y0c0t4RmR3S2NaWGNubldmXzE3MTQ4MjAxMDU6MTcxNDgyMzcwNV9WNA" alt="img"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.87</span><span class="number">.132</span><span class="string">:8848</span>   <span class="comment">#nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span>    <span class="comment"># 读取配置文件格式</span></span><br><span class="line">        <span class="attr">shared-configs:</span>      </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-log.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-jdbc.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-knife4j.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-seata.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-feign.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到此application.yaml就可以简化为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10，对应代码如下：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNhOGU5ZWNlZWE0ZDhjOTBhNTI4OTkxYmIwYjZlNzlfdGRwREVjWnkzZXFLamU0ek9UZno1NnRJOUJRV0FZdVVfVG9rZW46R1FpOWJuNGF0b3M4bWZ4SHJPRGM1QXdIbkpmXzE3MTQ4MjAzMDE6MTcxNDgyMzkwMV9WNA" alt="img"></p><p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p><p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h3 id="添加配置到Nacos"><a href="#添加配置到Nacos" class="headerlink" title="添加配置到Nacos"></a>添加配置到Nacos</h3><p>首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE2Mzg0YzljYzdhMGFhZjA5MzZlNGZmZmVkYWZkM2ZfR1dBdWx2ZUdwSEtsWURtVmViVnpCOTN3QWkycXVyUzJfVG9rZW46TnZicmJxSU1Yb1NPdDV4NGNxd2M0a21tbnJnXzE3MTQ4MjAzMjA6MTcxNDgyMzkyMF9WNA" alt="img"></p><p>注意文件的dataId格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure><p>不写spring acvite profile的话默认所有环境都共享</p><p>文件名称由三部分组成：</p><ul><li>**<code>服务名</code>**：我们是购物车服务，所以是<code>cart-service</code></li><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li>**<code>后缀名</code>**：例如yaml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxItems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就可以写一个类动态读取数据了</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：</p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="更新路由"><a href="#更新路由" class="headerlink" title="更新路由"></a>更新路由</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.gateway.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上JSON配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><h4 id="实现动态路由"><a href="#实现动态路由" class="headerlink" title="实现动态路由"></a>实现动态路由</h4><p>首先， 我们在网关gateway引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRoute</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RouteDefinitionWriter routeDefinitionWriter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> NacosConfigManager nacosConfigManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span>  <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">//保存更新后的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">//1.注册并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateRouteConfig(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//2.首次启动时加载配置</span></span><br><span class="line">        updateRouteConfig(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateRouteConfig</span><span class="params">(String configInfo)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更: &#123;&#125;&quot;</span>,configInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitionList = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.更新前先删除旧的路由表</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            <span class="comment">//记得写上订阅</span></span><br><span class="line">            routeDefinitionWriter.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">//更新路由表</span></span><br><span class="line">       <span class="comment">//没有变动直接跳过</span></span><br><span class="line">        <span class="keyword">if</span>(CollUtil.isEmpty(routeDefinitionList))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        routeDefinitionList.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">//更新路由</span></span><br><span class="line">            routeDefinitionWriter.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">//记录路由id，方便后续更新时删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们直接在Nacos控制台添加路由，路由文件名为<code>gateway-routes.json</code>，类型为<code>json</code>：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFlODRlZTQ4ODViZGQxZWNjNGZmNzMwNjA2NWM3NTZfbmF4TVNRNmJzVDlNRVdhUEdJa0IzV2FaNzRJYmF1TXlfVG9rZW46R0ZGTWJyS0Yxb3UyTHB4c2dPeGNUYmZPbmJkXzE3MTQ4MjMxMDU6MTcxNDgyNjcwNV9WNA" alt="img"></p><p>配置内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/carts/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://cart-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/users/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/addresses/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://user-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://order-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pay&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/pay-orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://pay-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>(sentinel,seata)感觉用组件一点感觉都没有…</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新东西 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/19/%E7%AE%97%E6%B3%95/hello-world/"/>
      <url>/2024/03/19/%E7%AE%97%E6%B3%95/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> newTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的学习之路</title>
      <link href="/2024/03/19/%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/19/%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p> (｡･∀･)ﾉﾞ，这还有啥why，混口饭吃，有个能创建网站的前置能力，已经很足够了</p><p><code>vue</code></p><h1 id="初始工程"><a href="#初始工程" class="headerlink" title="初始工程"></a>初始工程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建命令</span><br><span class="line">npm create vue@latest</span><br><span class="line"></span><br><span class="line">cd your_demo</span><br><span class="line">npm install</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_moudles 组件库</span><br><span class="line">public </span><br><span class="line">src 主要编写文件</span><br><span class="line">index.html 入口文件</span><br><span class="line">pack-lock.json package.json 配置依赖等</span><br><span class="line">vite.config..js 配置文件</span><br></pre></td></tr></table></figure><p><img src="C:\Users\末影\AppData\Roaming\Typora\typora-user-images\image-20240322173222513.png" alt="image-20240322173222513"></p><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>作用： 根据已有数据计算新数据</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        姓: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        全名: <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;  fullName &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeFullname&quot;</span>&gt;</span>全名改为：xxx<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;zhang&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;san&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 计算属性——只读取，不修改</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* let fullName = computed(()=&gt;&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    return firstName.value + &#x27;-&#x27; + lastName.value</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">  &#125;) */</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> firstName.<span class="property">value</span> +<span class="string">&quot;-&quot;</span>+lastName.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//修改</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;有人修改乐fullName&quot;</span>,val)</span></span><br><span class="line"><span class="language-javascript">        firstName.<span class="property">value</span>=val.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">        lastName.<span class="property">value</span>=val.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">changeFullname</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    fullName.<span class="property">value</span>=<span class="string">&quot;li-si&quot;</span></span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="！路由"><a href="#！路由" class="headerlink" title="！路由"></a>！路由</h1><p>害。。。速成嘛，就先重点路由吧</p><blockquote><p>导航区，展示区</p></blockquote><blockquote><p>指定路由的具体规则</p></blockquote><blockquote><p>形成一个个的xxx.vue</p></blockquote><p>需要提前想好路由工作模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个路由器并且暴露出去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">&#x27;@/views/person.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/News.vue&#x27;</span></span><br><span class="line"><span class="comment">//创建路由器(rnm，这里不要用&#123;&#125;把Home他们包起来)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">// 路由器的工作模式</span></span><br><span class="line">    <span class="comment">//配置路由</span></span><br><span class="line">    <span class="attr">routes</span>:[ <span class="comment">//一个个路由规则</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/person&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: person</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router </span><br></pre></td></tr></table></figure><h2 id="【编程式导航】"><a href="#【编程式导航】" class="headerlink" title="【编程式导航】"></a>【编程式导航】</h2><p>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>() <span class="comment">//解构传入的数据</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>() <span class="comment">//路由器，进行跳转</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">parmas</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">push</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">replace</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//news.vue</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;news in newsList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;news.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">            path: &#x27;/news/detail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">            query: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">                id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">                name: news.name,</span></span></span><br><span class="line"><span class="string"><span class="tag">                context: news.context,</span></span></span><br><span class="line"><span class="string"><span class="tag">                // News: news//不行</span></span></span><br><span class="line"><span class="string"><span class="tag">                car: car</span></span></span><br><span class="line"><span class="string"><span class="tag">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#125;&quot;</span>&gt;</span>&#123;&#123; news.name &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; context &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; car&#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; query.id &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; query.name &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; query.context &#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;&#123; query.car&#125;&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useRoute,useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;useDetailStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/details&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//接受props</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;context&#x27;</span>,<span class="string">&#x27;car&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript">    ------</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> route=<span class="title function_">useRoute</span>() <span class="comment">//hook</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> router=<span class="title function_">useRouter</span>() <span class="comment">//路由器</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> &#123;query&#125;= <span class="title function_">toRefs</span>(route) <span class="comment">//解构</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h2><p>有点类似与Java的ThreadLocal？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install pinia</span><br><span class="line"></span><br><span class="line"><span class="comment">//js中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia=<span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router).<span class="title function_">use</span>(pinia)</span><br><span class="line">.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先是在js文件中去定义数据以及方法，还有暴露出来</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#123; defineStore &#125; from &quot;pinia&quot;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export const useDetailStore=defineStore(&#x27;details&#x27;,&#123;</span></span><br><span class="line"><span class="comment">//     state()&#123;</span></span><br><span class="line"><span class="comment">//         return &#123;</span></span><br><span class="line"><span class="comment">//             toy:&quot;atm&quot;,</span></span><br><span class="line"><span class="comment">//             sum: 666,</span></span><br><span class="line"><span class="comment">//             todayNews:[</span></span><br><span class="line"><span class="comment">//                 &#123;id:&#x27;yuysada01&#x27;,content:&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;&#125;,</span></span><br><span class="line"><span class="comment">//                 &#123;id:&#x27;yuysada02&#x27;,content:&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;&#125;,</span></span><br><span class="line"><span class="comment">//                    &#123;id:&#x27;yuysada03&#x27;,content:&#x27;心里给你留了一块地，我的死心塌地&#x27;&#125;</span></span><br><span class="line"><span class="comment">//             ]</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     //计算</span></span><br><span class="line"><span class="comment">//     getters:&#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//组合式写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useDetailStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;detials&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;atm&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> todayNews = <span class="title function_">ref</span>([</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;yuysada01&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;yuysada02&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;yuysada03&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="title function_">ref</span>(<span class="number">399</span>)</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">change</span>=(<span class="params">newToy</span>)=&gt;&#123;</span><br><span class="line">    toy.<span class="property">value</span>=newToy</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;toy,todayNews,sum,change&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而接收的话也是有好几种的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useDetailStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/details&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="comment">//先定义出来</span></span><br><span class="line"><span class="keyword">const</span> detailStore=<span class="title function_">useDetailStore</span>()</span><br><span class="line"><span class="comment">//第一，直接解构出来</span></span><br><span class="line"><span class="keyword">const</span> &#123;toy,sum,todayNews&#125; = <span class="title function_">storeToRefs</span>(detailStore)</span><br><span class="line"><span class="comment">//第二,不再是响应式</span></span><br><span class="line"><span class="comment">// let toy=detailStore.toy</span></span><br><span class="line"><span class="comment">// let sum=detailStore.sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//感觉有点迷糊</span></span><br><span class="line"><span class="comment">// let toy=ref(detailStore.toy)</span></span><br><span class="line"><span class="comment">// let sum=ref(detailStore.sum)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//details.js中</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">change</span>=(<span class="params">newToy</span>)=&gt;&#123;</span><br><span class="line">    toy.<span class="property">value</span>=newToy</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeStore</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// detailStore.$patch(&#123;</span></span><br><span class="line">  <span class="comment">//   toy: &quot;wlgq&quot;,</span></span><br><span class="line">  <span class="comment">//   sum: 555</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  toy.<span class="property">value</span>=<span class="string">&quot;aiodsjfodis&quot;</span></span><br><span class="line">  detailStore.<span class="title function_">change</span>(toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新东西 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
