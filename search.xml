<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码随想录：回溯算法</title>
      <link href="/2025/01/25/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2025/01/25/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote><p>本质还是暴力搜索，但是可以利用剪枝进行优化</p></blockquote><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.cn/problems/combinations/">77. Combinations</a></h2><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">Explanation: There are 4 choose 2 = 6 total combinations.</span><br><span class="line">Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, k = 1</span><br><span class="line">Output: [[1]]</span><br><span class="line">Explanation: There is 1 choose 1 = 1 total combination.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="正常回溯"><a href="#正常回溯" class="headerlink" title="正常回溯"></a>正常回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       backtracing(n,k,<span class="number">1</span>,resultList,queue);</span><br><span class="line">      <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,Deque&lt;Integer&gt; queue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()==k)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(queue));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur;i&lt;=n;i++)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            backtracing(n,k,i+<span class="number">1</span>,resultList,queue);</span><br><span class="line">            queue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       backtracing(n,k,<span class="number">1</span>,resultList,queue);</span><br><span class="line">      <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,Deque&lt;Integer&gt; queue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()==k)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(queue));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur;i&lt;=(n-(k-queue.size())+<span class="number">1</span>);i++)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            backtracing(n,k,i+<span class="number">1</span>,resultList,queue);</span><br><span class="line">            queue.removeLast();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. Combination Sum III</a></h2><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p><ul><li>Only numbers <code>1</code> through <code>9</code> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6],[1,3,5],[2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 4, n = 1</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations.</span><br><span class="line">Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><h3 id="正常递归"><a href="#正常递归" class="headerlink" title="正常递归"></a>正常递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        backtracing(k,n,<span class="number">1</span>,resultList,list);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k&amp;&amp;getSum(list)==n) &#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracing(k,n,i+<span class="number">1</span>,resultList,list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getSum</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            sum += list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        backtracing(<span class="number">0</span>,k,n,<span class="number">1</span>,resultList,list);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> cur,List&lt;List&lt;Integer&gt;&gt; resultList,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>cur;i&lt;=<span class="number">9</span>-(k-list.size())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracing(sum,k,n,i+<span class="number">1</span>,resultList,list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] letterMap = &#123; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, </span><br><span class="line">    <span class="string">&quot;def&quot;</span>, </span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, </span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, </span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, </span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, </span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, &#125;;</span><br><span class="line">        List&lt;String&gt; resultList =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracing(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracing</span><span class="params">(String digits,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==digits.length())&#123;</span><br><span class="line">            resultList.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">digit</span> <span class="operator">=</span> letterMap[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;digit.length();i++)&#123;</span><br><span class="line">            temp.append(digit.charAt(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;回溯前:&quot;</span>+temp.toString());</span><br><span class="line">            backtracing(digits,index + <span class="number">1</span>);</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;回溯后:&quot;</span>+temp.toString());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a></h2><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the </p><p>frequency</p><p> of at least one of the chosen numbers is different.</p><p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.</span><br><span class="line">7 is a candidate, and 7 = 7.</span><br><span class="line">These are the only two combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8</span><br><span class="line">Output: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2], target = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li><li><code>1 &lt;= target &lt;= 40</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[]candidates,<span class="type">int</span> sum,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;sum)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempList.add(candidates[i]);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            backtracking(candidates,sum,i);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：二叉树</title>
      <link href="/2024/12/28/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/12/28/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>[TOC]</p><h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree</a></h2><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p><blockquote><p>Yes !  I can</p></blockquote><h3 id="recursively"><a href="#recursively" class="headerlink" title="recursively"></a>recursively</h3><blockquote><p>比较是否对称可以细化为，比较根节点的左右孩子，以及比较左孩子的左孩子跟右孩子的右孩子和左孩子的右孩子跟右孩子的左孩子</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">return</span> compareTree(root.left,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareTree</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left.val!=right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compareTree(left.left,right.right);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compareTree(left.right,right.left);</span><br><span class="line">            <span class="keyword">return</span> outside&amp;&amp;inside;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteratively"><a href="#iteratively" class="headerlink" title="iteratively"></a>iteratively</h3><blockquote><p>使用迭代法。队列以及栈都可以使用，我们只需要成对进行push以及pop然后比较即可</p></blockquote><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           queue.offer(root.left);</span><br><span class="line">           queue.offer(root.right);</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>&amp;&amp;rightNode==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>||rightNode==<span class="literal">null</span>||leftNode.val!=rightNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               queue.offer(leftNode.left);</span><br><span class="line">               queue.offer(rightNode.right);</span><br><span class="line">               queue.offer(leftNode.right);</span><br><span class="line">               queue.offer(rightNode.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           stack.push(root.left);</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>&amp;&amp;rightNode==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span>(leftNode==<span class="literal">null</span>||rightNode==<span class="literal">null</span>||leftNode.val!=rightNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               stack.push(leftNode.left);</span><br><span class="line">               stack.push(rightNode.right);</span><br><span class="line">               stack.push(leftNode.right);</span><br><span class="line">               stack.push(rightNode.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deeply</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               TreeNode curr= queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;<span class="comment">//剪掉一个根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            depth++;<span class="comment">//走完一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><p>Given a n-ary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The total number of nodes is in the range <code>[0, 104]</code>.</li><li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li></ul><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">                max = Math.max(max,maxDepth(child));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">                depth++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span>queue.size();</span><br><span class="line">                <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">for</span> (Node child : poll.children) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(child!=<span class="literal">null</span>)&#123;</span><br><span class="line">                            queue.offer(child);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><p>已解答</p><p>简单</p><p>相关标签</p><p>相关企业</p><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 105]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">   * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">   *     int val;</span></span><br><span class="line"><span class="comment">   *     TreeNode left;</span></span><br><span class="line"><span class="comment">   *     TreeNode right;</span></span><br><span class="line"><span class="comment">   *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">   *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">   *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">   *         this.val = val;</span></span><br><span class="line"><span class="comment">   *         this.left = left;</span></span><br><span class="line"><span class="comment">   *         this.right = right;</span></span><br><span class="line"><span class="comment">   *     &#125;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          LinkedList&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          queue.offer(root);</span><br><span class="line">          <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">              min++;</span><br><span class="line">              <span class="type">int</span> size=queue.size();</span><br><span class="line">              <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                  <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                      queue.offer(p.left);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                      queue.offer(p.right);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(p.right==<span class="literal">null</span>&amp;&amp;p.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                      <span class="keyword">return</span> min;</span><br><span class="line">                  &#125;</span><br><span class="line">                  size--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> min;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h3><blockquote><p>只有左右孩子都为空时才算深度</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.min(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p><p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p><p>Design an algorithm that runs in less than <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 5 * 104]</code>.</li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>The tree is guaranteed to be <strong>complete</strong>.</li></ul><h3 id="SimpleTree-way"><a href="#SimpleTree-way" class="headerlink" title="SimpleTree way"></a>SimpleTree way</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ant</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                ant++;</span><br><span class="line">                <span class="keyword">if</span>(poll.left!=<span class="literal">null</span>) queue.offer(poll.left);</span><br><span class="line">                <span class="keyword">if</span>(poll.right!=<span class="literal">null</span>) queue.offer(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompleteTree-way"><a href="#CompleteTree-way" class="headerlink" title="CompleteTree way"></a>CompleteTree way</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">       <span class="keyword">while</span>(leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        leftDepth++;</span><br><span class="line">        leftNode = leftNode.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        rightDepth++;</span><br><span class="line">        rightNode = rightNode.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftDepth==rightDepth)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftDepth)-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><p>Given a binary tree, determine if it is </p><p><strong>height-balanced</strong></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="recursively-1"><a href="#recursively-1" class="headerlink" title="recursively"></a>recursively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root,<span class="number">0</span>)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftDepth==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightDepth==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftDepth-rightDepth)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midleDepth</span> <span class="operator">=</span> Math.max(leftDepth,rightDepth)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> midleDepth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           List&lt;Integer&gt; pathList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           List&lt;String&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">           getPathToChild(root,pathList,resultList);</span><br><span class="line">           <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPathToChild</span><span class="params">(TreeNode root,List&lt;Integer&gt; pathList,List&lt;String&gt; resultList)</span>&#123;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pathList.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                 temp.append(pathList.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                temp.append(pathList.get(pathList.size()-<span class="number">1</span>));</span><br><span class="line">                resultList.add(temp.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">                getPathToChild(root.left,pathList,resultList);</span><br><span class="line">                pathList.remove(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                getPathToChild(root.right,pathList,resultList);</span><br><span class="line">                pathList.remove(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p><p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="recursively-2"><a href="#recursively-2" class="headerlink" title="recursively"></a>recursively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.left==<span class="literal">null</span>&amp;&amp;root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            left =  root.left.val;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left + right;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteratively-1"><a href="#iteratively-1" class="headerlink" title="iteratively"></a>iteratively</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>&amp;&amp;top.left.left==<span class="literal">null</span>&amp;&amp;top.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                sum += top.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.right!=<span class="literal">null</span>) stack.push(top.right);</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>) stack.push(top.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="Queue-BFS"><a href="#Queue-BFS" class="headerlink" title="Queue (BFS)"></a>Queue (BFS)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.getFirst();</span><br><span class="line">            left = leftNode.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">                size--;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iteravely"><a href="#iteravely" class="headerlink" title="iteravely"></a>iteravely</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iteravely(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iteravely</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth&gt;maxDepth)&#123;</span><br><span class="line">                result =root.val;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            iteravely(root.left,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            iteravely(root.right,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.cn/problems/path-sum/">112. Path Sum</a></h2><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are two root-to-leaf paths in the tree:</span><br><span class="line">(1 --&gt; 2): The sum is 3.</span><br><span class="line">(1 --&gt; 3): The sum is 4.</span><br><span class="line">There is no root-to-leaf path with sum = 5.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [], targetSum = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since the tree is empty, there are no root-to-leaf paths.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; sumStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        sumStack.push(root.val);</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sumStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum&amp;&amp;top.right==<span class="literal">null</span>&amp;&amp;top.left==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(top.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">                sumStack.push(sum+top.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">                sumStack.push(sum+top.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.cn/problems/path-sum-ii/"><strong>113. Path Sum II</strong></a></h2><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br><span class="line">Explanation: There are two paths whose sum equals targetSum:</span><br><span class="line">5 + 4 + 11 + 2 = 22</span><br><span class="line">5 + 8 + 4 + 5 = 22</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2], targetSum = 0</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h3 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; pathList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">            resultList.clear();</span><br><span class="line">            pathList.clear();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            traversal(root,targetSum - root.val);</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> ant)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;ant==<span class="number">0</span>)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(pathList)); <span class="comment">// !!</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pathList.add(root.left.val);</span><br><span class="line">                ant -= root.left.val;</span><br><span class="line">                traversal(root.left, ant);</span><br><span class="line">                ant += root.left.val;</span><br><span class="line">                pathList.remove(pathList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pathList.add(root.right.val);</span><br><span class="line">                ant -= root.right.val;</span><br><span class="line">                traversal(root.right, ant);</span><br><span class="line">                ant += root.right.val;</span><br><span class="line">                pathList.remove(pathList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-好好品"><a href="#2-好好品" class="headerlink" title="(2) 好好品"></a>(2) 好好品</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList ;</span><br><span class="line">        List&lt;Integer&gt; pathList ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">            resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pathList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> resultList;</span><br><span class="line">            traversal(root,targetSum);</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> ant)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            pathList.add(root.val);</span><br><span class="line">            ant -= root.val;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;ant==<span class="number">0</span>)&#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(pathList));</span><br><span class="line">            &#125;</span><br><span class="line">            traversal(root.left, ant);</span><br><span class="line">            traversal(root.right, ant);</span><br><span class="line">            pathList.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：栈和队列</title>
      <link href="/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><blockquote><p>一开始小登自己认为，栈和队列不就是特殊一点的数组嘛，就是闭合了一端的数组。还不能通过下标索引进行检索（这个时候完全没想到，栈和队列里面的元素存储并不是连续的内存）</p></blockquote><h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyStack</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the top of the stack.</li><li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li><li><code>int top()</code> Returns the element on the top of the stack.</li><li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li><li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // return 2</span><br><span class="line">myStack.pop(); // return 2</span><br><span class="line">myStack.empty(); // return False</span><br></pre></td></tr></table></figure><h3 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_225</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; secQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            queue.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                secQueue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">top</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">while</span>(!secQueue.isEmpty())&#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> secQueue.poll();</span><br><span class="line">                queue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                secQueue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">peek</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">while</span>(!secQueue.isEmpty())&#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> secQueue.poll();</span><br><span class="line">                queue.offer(poll);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(peek);</span><br><span class="line">            <span class="keyword">return</span> peek;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(myStack.top());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一个队列实现栈-使用逻辑长度"><a href="#一个队列实现栈-使用逻辑长度" class="headerlink" title="一个队列实现栈(使用逻辑长度)"></a>一个队列实现栈(使用逻辑长度)</h3><blockquote><p>其实完全不需要 使用额外一个队列进行备份。</p><p>完全可以弹出后再加入到队尾就行</p><p>使用<strong>size</strong>实现逻辑长度为1时弹出的就是栈顶</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           queue.offer(x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">           <span class="keyword">while</span>(size!=<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               queue.offer(poll);</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="keyword">return</span> pop;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span>  <span class="built_in">this</span>.pop();</span><br><span class="line">       queue.offer(top);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. Valid Parentheses</a></h2><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s &#x3D; “()”</p><p><strong>Output:</strong> true</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> s &#x3D; “()[]{}”</p><p><strong>Output:</strong> true</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s &#x3D; “(]”</p><p><strong>Output:</strong> false</p><p><strong>Example 4:</strong></p><p><strong>Input:</strong> s &#x3D; “([])”</p><p><strong>Output:</strong> true</p><h3 id="显而易见版"><a href="#显而易见版" class="headerlink" title="显而易见版"></a>显而易见版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">            LinkedList&lt;Character&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;&#123;&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    list.add(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Character</span> <span class="variable">top</span> <span class="operator">=</span> list.getLast();</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(top==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>显而易见版明显看着很多，代码感觉也很冗余。尤其是是要判断右括号的添加</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">            LinkedList&lt;Character&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    list.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list.isEmpty()||list.pop()!=c)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><p>You are given a string <code>s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</p><p>We repeatedly make <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p><p>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abbaca&quot;</span><br><span class="line">Output: &quot;ca&quot;</span><br><span class="line">Explanation: </span><br><span class="line">For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;azxxzy&quot;</span><br><span class="line">Output: &quot;ay&quot;</span><br></pre></td></tr></table></figure><h3 id="难受版（列表转字符串）"><a href="#难受版（列表转字符串）" class="headerlink" title="难受版（列表转字符串）"></a>难受版（列表转字符串）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           LinkedList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(list.getLast()==c)&#123;</span><br><span class="line">                       list.removeLast();</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       list.addLast(c);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   list.addLast(c);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span> (Character character : list) &#123;</span><br><span class="line">               sb.append(character);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用StringBuilder作为栈"><a href="#使用StringBuilder作为栈" class="headerlink" title="使用StringBuilder作为栈"></a>使用StringBuilder作为栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!sb.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(sb.charAt(sb.length()-<span class="number">1</span>)==c)&#123;</span><br><span class="line">                       sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       sb.append(c);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   sb.append(c);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p><p><strong>Note</strong> that:</p><ul><li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li><li>Each operand may be an integer or another expression.</li><li>The division between two integers always <strong>truncates toward zero</strong>.</li><li>There will not be any division by zero.</li><li>The input represents a valid arithmetic expression in a reverse polish notation.</li><li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">             <span class="keyword">if</span> (token.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(stack.pop() + stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(-stack.pop() + stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    stack.push(stack.pop() * stack.pop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(num2 / num1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(Integer.parseInt(token));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return <em>the max sliding window</em>.</p><blockquote><p>首先滑动窗口就完全可以看作是一种队列。我们这个题要做到的就是，每次移动的时候都要弹出元素、放入元素、报告最大元素。</p><p>那我们可以维护一个队列用于存储最大值以及候选值。当很小的值弹出时这个队列不需要进行操作，只有当最大元素弹出或加入较大的元素时需要维护（通过比较放入到最大值&#x2F;候选值）</p></blockquote><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       LinkedList&lt;Integer&gt; queue =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> nums;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">               push(nums[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           list.add(getFront());</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; len; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(getFront()==nums[i-k])&#123;</span><br><span class="line">                   pop();;</span><br><span class="line">               &#125;</span><br><span class="line">               push(nums[i]);</span><br><span class="line">               list.add(getFront());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">           queue.removeFirst();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;queue.getLast()&lt;x)&#123;</span><br><span class="line">               queue.removeLast();</span><br><span class="line">           &#125;</span><br><span class="line">           queue.add(x);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><p><strong>Follow up:</strong> Your algorithm’s time complexity must be better than <code>O(n log n)</code>, where n is the array’s size.</p><h3 id="使用哈希表"><a href="#使用哈希表" class="headerlink" title="使用哈希表"></a>使用哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">           HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">              map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> map.entrySet().stream().sorted((m1, m2) -&gt; m2.getValue() - m1.getValue())</span><br><span class="line">                   .limit(k).mapToInt(Map.Entry::getKey).toArray();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用小顶堆"><a href="#使用小顶堆" class="headerlink" title="使用小顶堆"></a>使用小顶堆</h3><blockquote><p>优化点就是，我们不需要将全部元素都进行排序，只需要维护一个k大小的堆就行了。</p><p>使用小顶堆是因为我们每次淘汰的都是频率最小的元素。</p></blockquote><p><strong>有兴趣的可以了解一下堆的加入和去除元素（虽然一般数据结构课肯定会讲解的）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">          HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">             map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 使用小顶堆 (频率比较大小)</span></span><br><span class="line">          PriorityQueue&lt;<span class="type">int</span>[]&gt; queue =<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((prior1,prior2)-&gt;prior1[<span class="number">1</span>]-prior2[<span class="number">1</span>]); </span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">              <span class="keyword">if</span>(queue.size()&lt;k)&#123;</span><br><span class="line">                  queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(queue.peek()[<span class="number">1</span>]&lt;entry.getValue())&#123;</span><br><span class="line">                      queue.poll();</span><br><span class="line">                      queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">              result[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.cn/problems/simplify-path/">71. Simplify Path</a></h2><p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p><p>The <em>rules</em> of a Unix-style file system are as follows:</p><ul><li>A single period <code>&#39;.&#39;</code> represents the current directory.</li><li>A double period <code>&#39;..&#39;</code> represents the previous&#x2F;parent directory.</li><li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li><li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file</strong> <strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li></ul><p>The simplified canonical path should follow these <em>rules</em>:</p><ul><li>The path must start with a single slash <code>&#39;/&#39;</code>.</li><li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li><li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li><li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li></ul><p>Return the <strong>simplified canonical path</strong>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">          String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">          <span class="comment">// 去除空字符串 和 空格得到新的数组</span></span><br><span class="line">          String[] newSplit = Arrays.stream(split).map(String::trim).filter(s -&gt; !s.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !s.equals(<span class="string">&quot; &quot;</span>)).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">          LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (String s : newSplit) &#123;</span><br><span class="line">              <span class="keyword">if</span>(s.equals(<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                  <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                      stack.removeLast();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s.equals(<span class="string">&quot;.&quot;</span>))&#123;</span><br><span class="line">                  stack.add(s);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          <span class="keyword">for</span> (String s : stack) &#123;</span><br><span class="line">              sb.append(<span class="string">&quot;/&quot;</span>).append(s);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">&quot;/&quot;</span>:sb.toString();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/12/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/21/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/12/21/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>��ࡱ�&gt;��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<br><br>��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Root Entry�������� &#x2F;���R�@Data<br>����������������0Table����.WordDocument������������3<br><br>���� !”#$%&amp;’()*+,-.&#x2F;0123456789:;&lt;&#x3D;&gt;?@ABCDEFGHIJKLMNOPQRSTU����WXYZ[d]^_<code>abc���������������������������������������������������������������������������������������������������������������������F</code>��Fck�ea$$1$CJPJKHmHsHnHtH$A<code>���$؞���k=�W[SO8 </code>�8u��a$$G$<br>�9r CJ�<code>�u�wcd�a$$G$@&amp;$dN��%dO��&amp;dP��&#39;dQ�� �9r CJOJQJG��z ��Times New Roman-���(�[SO1����R&lt;(�_o�Ŗў5��Symbol3$��*�Cx��@��Arial-�����|�8ўSO?4��*�Cx��@��Courier New;��Wingdings5��.�[</code>�)� ( Tahoma�� ���Qh^2g��G!Z&amp;!),.:;?]}����    &amp; 6”000000<br>00000���������&#x3D;�@�\�]�^���([{�  0<br>000000��;�[���������)��?����������������������’<em>2������F�S�����������s���&gt;����0�(�<br>��0<br>�C��  �?�@����P�KSKS�3�������hhAht��,$�h�</em>�U�<br>�mHsH�1��. ��A!�#��”�$��%��S��2P1�8���������Oh��+’��0&#96;�����&lt;����SummaryInformation(����V�DocumentSummaryInformation8������������\����������������������������4T�WPS Office NNHrmoying����՜.��+,��D��՜.��+,��\��������������<br>��(\�dlKSOProductBuildVer�2052-9.1.0.3914�0<br>�@p���R��  �?�@</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2024/12/21/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2024/12/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. Assign Cookies</a></h2><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2,3], s = [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2], s = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> len1=g.length;</span><br><span class="line">        <span class="type">int</span> len2=s.length;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i]&lt;=s[j]++)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.cn/problems/candy/">135. Candy</a></h2><p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ratings = [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ratings = [1,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.</span><br><span class="line">The third child gets 1 candy because it satisfies the above two conditions.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[]candies = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        Arrays.fill(candies,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                candies[i] = candies[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i-<span class="number">1</span>]&gt;ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(candies[i-<span class="number">1</span>]&lt;=candies[i])&#123;</span><br><span class="line">                candies[i-<span class="number">1</span>] = candies[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candies.length; i++) &#123;</span><br><span class="line">            sum+=candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. Non-overlapping Intervals</a></h2><p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p><p><strong>Note</strong> that intervals which only touch at a point are <strong>non-overlapping</strong>. For example, <code>[1, 2]</code> and <code>[2, 3]</code> are non-overlapping.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You don&#x27;t need to remove any of the intervals since they&#x27;re already non-overlapping.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end&gt;intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                end=Math.min(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="605-Can-Place-Flowers-Defensive-Programming"><a href="#605-Can-Place-Flowers-Defensive-Programming" class="headerlink" title="605. Can Place Flowers(Defensive Programming)"></a><a href="https://leetcode.cn/problems/can-place-flowers/">605. Can Place Flowers(Defensive Programming)</a></h2><p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <strong>adjacent</strong> plots.</p><p>Given an integer array <code>flowerbed</code> containing <code>0</code>‘s and <code>1</code>‘s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>new flowers can be planted in the</em> <code>flowerbed</code> <em>without violating the no-adjacent-flowers rule and</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="first-idea"><a href="#first-idea" class="headerlink" title="first idea"></a>first idea</h3><blockquote><p>Firstly, if we want to be Greedy, it is great way that planting the </p><p>flower when left and right is zero.</p><p>Off course, we can find a problem when we  coding it, we must notice the start and end of array.</p><p>Clearly, we can use a way named Defensive Programming</p><p>we can expand original array two capacity to get a new array </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> flowerbed.length;</span><br><span class="line">        <span class="type">int</span>[] newPlots = <span class="keyword">new</span> <span class="title class_">int</span>[length+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> newPlots.length;</span><br><span class="line">        newPlots[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        newPlots[len-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(flowerbed,<span class="number">0</span>,newPlots,<span class="number">1</span>,length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newPlots[i]!=<span class="number">1</span>&amp;&amp;newPlots[i-<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;newPlots[i+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                newPlots[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="second-idea"><a href="#second-idea" class="headerlink" title="second idea"></a>second idea</h3><blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [<span class="number">452.</span> Minimum Number of Arrows to Burst Balloons](https:<span class="comment">//leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a <span class="number">2D</span> integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You <span class="keyword">do</span> not know the exact y-coordinates of the balloons.</span><br><span class="line"></span><br><span class="line">Arrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` <span class="keyword">if</span> `xstart &lt;= x &lt;= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</span><br><span class="line"></span><br><span class="line">Given the array `points`, <span class="keyword">return</span> *the **minimum** number of arrows that must be shot to burst all balloons*.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**Example <span class="number">1</span>:**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Input: points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br>Output: 2<br>Explanation: The balloons can be burst by 2 arrows:</p><ul><li>Shoot an arrow at x &#x3D; 6, bursting the balloons [2,8] and [1,6].</li><li>Shoot an arrow at x &#x3D; 11, bursting the balloons [10,16] and [7,12].<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**Example 2:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>Input: points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br>Output: 4<br>Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**Example 3:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>Input: points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br>Output: 2<br>Explanation: The balloons can be burst by 2 arrows:</li><li>Shoot an arrow at x &#x3D; 2, bursting the balloons [1,2] and [2,3].</li><li>Shoot an arrow at x &#x3D; 4, bursting the balloons [3,4] and [4,5].</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### WTF</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinArrowShots(int[][] points) &#123;</span><br><span class="line">        int length = points.length;</span><br><span class="line">        if(length==0||length==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));</span><br><span class="line">        int end = points[0][1];</span><br><span class="line">        for (int i = 1; i &lt; points.length; i++) &#123;</span><br><span class="line">            if(points[i][0]&gt;end)&#123;</span><br><span class="line">                ans ++;</span><br><span class="line">                end = points[i][1];</span><br><span class="line">            &#125;else if(points[i][0]&lt;end)&#123;</span><br><span class="line">                end = Math.min(end,points[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a><a href="https://leetcode.cn/problems/partition-labels/">763. Partition Labels</a></h2><p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p><p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p><p>Return <em>a list of integers representing the size of these parts</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;eccbbbbdec&quot;</span><br><span class="line">Output: [10]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> []arrays  = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            arrays[c-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一直走，谁最后落点最大就走到哪</span></span><br><span class="line">            end = Math.max(end,arrays[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(end==i)&#123;</span><br><span class="line">                result.add(end-start+<span class="number">1</span>);</span><br><span class="line">                start = end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Total profit is 4 + 3 = 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                max += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h2><p>You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [hi, ki]</code> represents the <code>ith</code> person of height <code>hi</code> with <strong>exactly</strong> <code>ki</code> other people in front who have a height greater than or equal to <code>hi</code>.</p><p>Reconstruct and return <em>the queue that is represented by the input array</em> <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [hj, kj]</code> is the attributes of the <code>jth</code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">Explanation:</span><br><span class="line">Person 0 has height 5 with no other people taller or the same height in front.</span><br><span class="line">Person 1 has height 7 with no other people taller or the same height in front.</span><br><span class="line">Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.</span><br><span class="line">Person 3 has height 6 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.</span><br><span class="line">Person 5 has height 7 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span></span><br><span class="line">        <span class="comment">// 按照第一个元素降序排序得到(同时保证相同时，第二个元素升序)  [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span></span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;b[<span class="number">0</span>] != a[<span class="number">0</span>] ? b[<span class="number">0</span>]-a[<span class="number">0</span>] : a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 现在每个元素前面都是大于等于自己的元素</span></span><br><span class="line">        <span class="comment">// 7.0</span></span><br><span class="line">        <span class="comment">// 7,0 7,1</span></span><br><span class="line">        <span class="comment">// 7,0 6,1 7,1</span></span><br><span class="line">        <span class="comment">// 5,0 7,0 6,1 7,1</span></span><br><span class="line">        <span class="comment">// 5,0 7,0 5,2 6,1 7,1</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; list =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="665-Non-decreasing-Array"><a href="#665-Non-decreasing-Array" class="headerlink" title="665. Non-decreasing Array"></a><a href="https://leetcode.cn/problems/non-decreasing-array/">665. Non-decreasing Array</a></h2><p>Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most one element</strong>.</p><p>We define an array is non-decreasing if <code>nums[i] &lt;= nums[i + 1]</code> holds for every <code>i</code> (<strong>0-based</strong>) such that (<code>0 &lt;= i &lt;= n - 2</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,2,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,2,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You cannot get a non-decreasing array by modifying at most one element.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPossibility</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// flag 表示还能否进行交换</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> nums[<span class="number">0</span>] &lt;= nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="comment">//                    [3,4,2,3]</span></span><br><span class="line">                    <span class="comment">// 1 4 2</span></span><br><span class="line">                    <span class="comment">// 要么变大 i+1 要么 变小i</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&lt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        nums[i] = nums[i+<span class="number">1</span>]; <span class="comment">// 变小</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums[i+<span class="number">1</span>] = nums[i]; <span class="comment">// 变大</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ learn</title>
      <link href="/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
      <url>/2024/11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ相关介绍"><a href="#RabbitMQ相关介绍" class="headerlink" title="RabbitMQ相关介绍"></a>RabbitMQ相关介绍</h1><p>最好的学习文档： <a href="https://www.rabbitmq.com/tutorials/tutorial-one-java">RabbitMQ 教程 - “Hello World！” |RabbitMQ 函数 — RabbitMQ tutorial - “Hello World!” | RabbitMQ</a></p><h2 id="什么是消息队列-为什么使用？"><a href="#什么是消息队列-为什么使用？" class="headerlink" title="什么是消息队列 &amp; 为什么使用？"></a>什么是消息队列 &amp; 为什么使用？</h2><blockquote><p>Message Queue</p></blockquote><p>顾名思义，存储消息的队列。</p><p>先来说说一个场景，以前送外卖的话或者送快递之类的，都是点到点，也就是快递小哥会直接送到你家，要是敲门发现不在，给你打个电话，此时你好像不得不回去？</p><p>其实先不说菜鸟驿站或者外卖柜。你们家家门口那块地就勉强算得上消息队列了，只不过不能保证安全，<del>其他人也可以消费</del>（bushi）</p><p>快递小哥只需要把快递放到你家门口，然后通过软件或者发短信，提醒你，就可以去干自己的事情了。而且你也不用马上去处理这个快递而打断当下做的事情。</p><blockquote><p><strong>什么是消息队列</strong><br>MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p></blockquote><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p><h3 id="各种知名消息队列优劣"><a href="#各种知名消息队列优劣" class="headerlink" title="各种知名消息队列优劣"></a>各种知名消息队列优劣</h3><h3 id="RabbitMQ-工作原理"><a href="#RabbitMQ-工作原理" class="headerlink" title="RabbitMQ 工作原理"></a>RabbitMQ 工作原理</h3> <img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121122826180.png" class title="image-20241121122826180"><ul><li>Broker: 消息队列服务进程</li><li>Exchange: 交换机，通过管道接受生产者信息，再通过一定规则将信息转发给某个队列（过滤消息）</li><li>Queue：消息队列，存储信息的队列，消息到达队列则会转发给指定的消费者</li><li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送</li><li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li></ul><h1 id="RabbitMQ-快速入门"><a href="#RabbitMQ-快速入门" class="headerlink" title="RabbitMQ 快速入门"></a>RabbitMQ 快速入门</h1><h2 id="六种消息模型"><a href="#六种消息模型" class="headerlink" title="六种消息模型"></a>六种消息模型</h2><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>简单队列： 简单的点对点服务</p><img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121123402772.png" class title="image-20241121123402772"><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数1：队列名称   参数2：是否持久化  参数3：是否独占  参数4：是否自动删除  参数5：其他参数 比如 TTL 等</span></span><br><span class="line"><span class="comment">             * 创建队列</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> channel != <span class="literal">null</span>;</span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建会话通道，生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 实现消费方法</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 当接收到消息后此方法将被调用</span></span><br><span class="line">            <span class="comment">// 参数1：消费者标签 参数2：消息队列信息 参数3：消息属性 参数4：消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟异常</span></span><br><span class="line">    <span class="comment">//                int i = 1/0;</span></span><br><span class="line">                <span class="comment">// 交换机</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> envelope.getExchange();</span><br><span class="line">                <span class="comment">// 消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">// body 消息内容</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + msg + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动ack</span></span><br><span class="line">                <span class="comment">// 参数1：消息id，参数2：是否批量确认</span></span><br><span class="line"><span class="comment">//                multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数为是否自动确认，true表示自动确认 callback为回调函数</span></span><br><span class="line"><span class="comment">//        channel.basicConsume(QUEUE_NAME, true, consumer);</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><p>工作队列：一对多，分工合作消费</p><blockquote><p>The main idea behind Work Queues (aka: <em>Task Queues</em>) is to avoid doing a resource-intensive task immediately and having to wait for it to complete. Instead we schedule the task to be done later. We encapsulate a <em>task</em> as a message and send it to a queue. A worker process running in the background will pop the tasks and eventually execute the job. When you run many workers the tasks will be shared between them.</p></blockquote><img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121124223926.png" class title="image-20241121124223926"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkSend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span>  <span class="operator">=</span> <span class="string">&quot;task....&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            Thread.sleep(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moying.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.moying.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkRecv1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception  &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 只接收一条未确认的消息</span></span><br><span class="line">      <span class="comment">//  channel.basicQos(1);</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, com.rabbitmq.client.Envelope envelope, com.rabbitmq.client.AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [Consumer 1] Received &#x27;&quot;</span> + msg + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line"><span class="comment">//        channel.basicConsume(QUEUE_NAME, true, consumer);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121125620346.png" class title="image-20241121125620346"><img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121125628037.png" class title="image-20241121125628037"><p>默认情况下这里会是C1和C2均摊消息进行消费，比如P发送50条，C1和C2各处理25条，但显然不太行（没有考虑C1和C2之间的设备性能差距等等）</p><p>所以可以通过设置</p><img src="11/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/image-20241121124455468.png" class title="image-20241121124455468"><p>让消费者处理完一条消息之后再去接收消息进行消费而不是囤积</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><blockquote><p> Note about queue size</p><p>If all the workers are busy, your queue can fill up. You will want to keep an eye on that, and maybe add more workers, or have some other strategy.</p></blockquote><h4 id="ACK-机制"><a href="#ACK-机制" class="headerlink" title="ACK 机制"></a>ACK 机制</h4><p>消息一旦被消费者接收，队列中的消息就被删除了。RabbitMQ是通过何种机制呢？</p><p>如果有了解TCP的话，应该就会恍然大悟（并且本身Producer，Broker，Consumer也是通过TCP连接的）</p><p>当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p><ul><li>自动ACK：消息一旦被接收，消费者自动发送ACK</li><li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li></ul><p>这里需要考虑场景去判断选择哪种更好</p><ul><li>如果是牵扯到钱之类的，肯定是得手动消费，得等到相关业务完成之后再去发送ACK，不然中途要是崩了，数据库方面进行回滚，但是你自动Ack后这条消息就没了啊。</li><li>如果是不太重要的消息，无脑自动吧（额，阅历不够，不清楚那些算不重要）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">       channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动进行ACK</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                *  void basicAck(long deliveryTag, boolean multiple) throws IOException;</span></span><br><span class="line"><span class="comment">                *  deliveryTag:用来标识消息的id</span></span><br><span class="line"><span class="comment">                *  multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里的multiple 不就跟TCP 的S-ACK很像嘛，我觉得底层应该就是这个</p></blockquote><h2 id="Publish-SubScirbe"><a href="#Publish-SubScirbe" class="headerlink" title="Publish&#x2F;SubScirbe"></a>Publish&#x2F;SubScirbe</h2><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h3 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h3><blockquote><p>routingkey ,routing pattern</p></blockquote><p>Fanout: 广播，</p><p>Direct： 定向，</p><p>Topic： 通配符，</p><p>Header： （<a href="https://blog.csdn.net/zhu_tianwei/article/details/40923131%EF%BC%89">https://blog.csdn.net/zhu_tianwei/article/details/40923131）</a></p><h2 id="整合Springboot"><a href="#整合Springboot" class="headerlink" title="整合Springboot"></a>整合Springboot</h2><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>避免消息堆积？</p><p>1） 采用workqueue，多个消费者监听同一队列。</p><p>2）接收到消息以后，而是通过线程池，异步消费。</p><p>如何避免消息丢失？</p><p>1） 消费者的ACK机制。可以防止消费者丢失消息。</p><p>但是，如果在消费者消费之前，MQ就宕机了，消息就没了？</p><p>2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：哈希表</title>
      <link href="/2024/07/18/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/07/18/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录-哈希表篇"><a href="#代码随想录-哈希表篇" class="headerlink" title="代码随想录-哈希表篇"></a>代码随想录-哈希表篇</h1><p>在大学或者其他时候学习数据结构课程时。不难发现，算法发展都是由于对时间或者空间有较高的需求，从而一步步优化。在查询优化时，到二分法(  log(N)  )时，开始出现了瓶颈， 如何降到O(1)或者退而求其次追求O(2),O(3)呢？</p><p>在顺序查找和二分查找时，我们都是索引+关键字存储,那能不能直接使用关键字充当索引，那不就能直接O（1）了吗？</p><p>哈希表就是怎么个思想（个人这样想的）</p><p>要深入学习的话，可以考虑由这些方面入手：空间开辟大小、哈希函数（存储）、解决哈希冲突、底层原理等。</p><p>嘛，这里主要是入门一下，通过做题感受一下</p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><blockquote><p>这个题目给出的都是小写字母，所以在用go写的方法里面就更简单一些。额也因为Java写的不太好</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">           HashMap&lt;Character,Integer&gt;map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">               Character temp=s.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(temp))&#123;</span><br><span class="line">                   map.put(temp,<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   map.put(temp, map.get(temp)+<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++) &#123;</span><br><span class="line">               Character temp=t.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(!map.containsKey(temp))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   map.put(temp, map.get(temp)-<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span>(value!=<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    arrays :=[<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,val :=<span class="keyword">range</span> s &#123;</span><br><span class="line">        arrays[val-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,val :=<span class="keyword">range</span> t &#123;</span><br><span class="line">        arrays[val-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrays==[<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their</em> </p><p><em>intersection</em></p><p> Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">         <span class="keyword">if</span>(nums1.length==<span class="number">0</span>||nums1==<span class="literal">null</span>||nums2==<span class="literal">null</span>||nums2.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">        HashSet&lt;Integer&gt;set1=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt;set2=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">             set1.add(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">             <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                 set2.add(i);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> set2.stream().mapToInt(x-&gt;x).toArray();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums1) == <span class="number">0</span> || nums1 == <span class="literal">nil</span> || <span class="built_in">len</span>(nums2) == <span class="number">0</span> || nums2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line"><span class="keyword">if</span> _,ok := set[v];!ok&#123;</span><br><span class="line">set[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set[v]; ok &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, v)</span><br><span class="line"><span class="built_in">delete</span>(set, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.cn/problems/happy-number/">202. Happy Number</a></h2><p>Write an algorithm to determine if a number <code>n</code> is happy.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> n!=<span class="number">1</span> &amp;&amp; !set[n] &#123;</span><br><span class="line">        n,set[n] =getSum(n),<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n != <span class="number">0</span> &#123;</span><br><span class="line">sum+=(n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">n=n/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,4], target = 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,3], target = 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> preIndex, ok := set[target-val]; ok &#123;</span><br><span class="line">                <span class="comment">// 第一轮主要是去重，防止覆盖</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;preIndex, index&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 数组值为map的key，下标为map的值</span></span><br><span class="line">set[val] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 4Sum II</a></h2><p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>, nums3 []<span class="type">int</span>, nums4 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">hashmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">n := <span class="built_in">len</span>(nums1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="comment">// key放和，val放出现次数</span></span><br><span class="line">hashmap[nums1[i]+nums2[j]]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">count += hashmap[<span class="number">0</span>-(nums3[i]+nums4[j])]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.cn/problems/ransom-note/">383. Ransom Note</a></h2><p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> <em>if</em> <code>ransomNote</code> <em>can be constructed by using the letters from</em> <code>magazine</code> <em>and</em> <code>false</code> <em>otherwise</em>.</p><p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="type">string</span>, magazine <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">strMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">strMap[<span class="type">int</span>(magazine[i])]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line"><span class="keyword">if</span> strMap[<span class="type">int</span>(ransomNote[i])]==<span class="number">0</span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        strMap[<span class="type">int</span>(ransomNote[i])]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：链表</title>
      <link href="/2024/06/29/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/06/29/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="代码随想录—链表"><a href="#代码随想录—链表" class="headerlink" title="代码随想录—链表"></a>代码随想录—链表</h1><p>嗨嗨，越是到了期末周，越是想开摆。复习什么的，60分万岁吧。有些东西真不感兴趣了。</p><hr><p>这次是来到了链表篇（毕竟链表和数组在数据结构中很是重要）</p><p>这里我基本都是使用的迭代法（递归法得慢慢修炼修炼再考虑了）</p><p><strong>（从大一c语言学习的时候，就觉得大多数情况下都能约定好使用的是虚拟头结点就好了）</strong></p><p>所以推荐使用链表时都使用一个虚拟头结点（力扣人好像喜欢叫哑结点）</p><p>偶尔的话可以使用哨兵结点，用于减少判断条件或者越界</p><p>先大概概括一下基本题型吧</p><ul><li>链表的建立以及增删查改<ul><li>虚拟头结点的使用，temp临时指针等</li><li>边界条件判断（什么时候使用current !&#x3D;null 什么时候使用current.Next !&#x3D;null)</li><li>拓展： 双向链表，循环链表（记得试试约瑟夫环这个经典问题）</li></ul></li><li>反转链表<ul><li>原地反转（注意使用指针保存下一个结点）</li><li>新建头结点然后使用头插</li></ul></li><li>删除链表倒数第N个结点<ul><li>直接暴力，第一次先算链表长度，第二次遍历删除该结点</li><li>使用前后指针，先让快指针走N步，然后慢指针开始出发。</li></ul></li><li>判断是否有环<ul><li>让你判断是否有环<ul><li>快慢指针</li><li>哈希表</li></ul></li><li>寻找环的入口<ul><li>快慢指针</li><li>哈希表</li></ul></li></ul></li></ul><h2 id="链表基础-创建以及增删查改"><a href="#链表基础-创建以及增删查改" class="headerlink" title="链表基础(创建以及增删查改)"></a>链表基础(创建以及增删查改)</h2><p>力扣相关题目（也可以看看数据结构相关书籍，那边基础功能更多更全）</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">设计链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line">            <span class="built_in">this</span>.val =val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head =<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size|| index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode current=head;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=index)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">       addAtIndex(<span class="number">0</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">       addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         index = Math.max(<span class="number">0</span>, index);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        size++;</span><br><span class="line">        ListNode newNode=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        ListNode current=head;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">           i++;</span><br><span class="line">            current=current.next;</span><br><span class="line">       &#125;</span><br><span class="line">       newNode.next=current.next;</span><br><span class="line">       current.next=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size|| index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode current= head;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            current=current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next=current.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="type">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">head *ListNode</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line"><span class="keyword">return</span> MyLinkedList&#123;&amp;ListNode&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= l.size&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">current := l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=index;i++&#123;</span><br><span class="line">current = current.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> current.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtHead(val <span class="type">int</span>)&#123;</span><br><span class="line">l.AddAtIndex(<span class="number">0</span>,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtTail(val <span class="type">int</span>)&#123;</span><br><span class="line">l.AddAtIndex(l.size,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span>AddAtIndex(index, val <span class="type">int</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> index &gt; l.size&#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">index =max(index,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//if index &lt; 0 &#123;</span></span><br><span class="line"><span class="comment">//index = 0</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">current :=l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;index;i++&#123;</span><br><span class="line">current = current.Next</span><br><span class="line">&#125;</span><br><span class="line">l.size++</span><br><span class="line"> toAdd := &amp;ListNode&#123;val, current.Next&#125;</span><br><span class="line"><span class="comment">//toAdd.Next=current.Next</span></span><br><span class="line">current.Next=toAdd</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l*MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> index &gt;=l.size || index &lt;<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">current :=l.head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;index;i++&#123;</span><br><span class="line">current=current.Next</span><br><span class="line">&#125;</span><br><span class="line">l.size--</span><br><span class="line">current.Next=current.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &gt; a &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表的反转"><a href="#链表的反转" class="headerlink" title="链表的反转"></a>链表的反转</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last=reverseList(head.next);</span><br><span class="line">        head.next.next=head;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span>head.next;</span><br><span class="line"></span><br><span class="line">   head.next=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   ListNode q;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">       q=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">       q.val=p.val;</span><br><span class="line"></span><br><span class="line">       q.next=head;</span><br><span class="line"></span><br><span class="line">       head=q;</span><br><span class="line"></span><br><span class="line">       p=p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> current !=<span class="literal">nil</span> &#123;</span><br><span class="line">        temp := current.Next</span><br><span class="line">        current.Next=pre</span><br><span class="line">        pre=current</span><br><span class="line">        current = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表倒数第N个结点"><a href="#删除链表倒数第N个结点" class="headerlink" title="删除链表倒数第N个结点"></a>删除链表倒数第N个结点</h2><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> * <span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> *     Val <span class="type">int</span></span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    demmyHead := &amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line">    fast,slow := demmyHead,demmyHead</span><br><span class="line">    f :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> f &lt; n &#123;</span><br><span class="line">        f++</span><br><span class="line">        fast=fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next!=<span class="literal">nil</span> &#123;</span><br><span class="line">        fast=fast.Next</span><br><span class="line">        slow=slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next=slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> demmyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表有环判断环入口问题"><a href="#链表有环判断环入口问题" class="headerlink" title="链表有环判断环入口问题"></a>链表有环判断环入口问题</h2><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    fast,slow := head ,head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next!=<span class="literal">nil</span> &amp;&amp; fast.Next.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            fast = head </span><br><span class="line">            <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">                    fast = fast.Next</span><br><span class="line">                    slow = slow.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span>  head;</span><br><span class="line">        Set&lt;ListNode&gt;hashSet =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(current))&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(current);</span><br><span class="line">            &#125;</span><br><span class="line">            current=current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    hashMap := <span class="keyword">map</span>[*ListNode]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    current := head </span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok :=hashMap[current]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap[current]=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="141-链表中环的检测"><a href="#141-链表中环的检测" class="headerlink" title="141.链表中环的检测"></a>141.链表中环的检测</h3><h3 id="21-两个有序链表的合并"><a href="#21-两个有序链表的合并" class="headerlink" title="21.两个有序链表的合并"></a>21.两个有序链表的合并</h3><h3 id="18-删除链表"><a href="#18-删除链表" class="headerlink" title="18.删除链表"></a>18.删除链表</h3><h3 id="876-求链表的中间结点"><a href="#876-求链表的中间结点" class="headerlink" title="876.求链表的中间结点"></a>876.求链表的中间结点</h3>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> java </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录：数组篇</title>
      <link href="/2024/06/24/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
      <url>/2024/06/24/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数组篇总结"><a href="#数组篇总结" class="headerlink" title="数组篇总结"></a>数组篇总结</h1><p>首先跟着代码随想录刷了一刷，大概接触到题型有二分法、移除元素&#x2F;排序、滑动窗口、模拟行为</p><ul><li><p>二分法</p><ul><li>确定好左右边界，以及mid的变化就好</li></ul></li><li><p>移除元素</p><ul><li>for循环暴力！</li><li>快慢指针： 快指针去探索找寻符合条件的宝藏，然后交给慢指针</li><li>使用堆栈或者队列</li></ul></li><li><p>排序</p><ul><li>首尾双指针</li></ul></li><li><p>滑动窗口</p><ul><li>双层for循环暴力！ 其实这种也是滑动窗口，只是完全是无脑滑动（以边界条件为条件）</li><li>双指针滑动，两个for循环（上面是n*n，这个是2n），且移动条件为场景需求条件（使用hashmap进行维护）</li></ul></li><li><p>模拟行为</p><ul><li>害。。听天由命，画图吧。</li></ul></li></ul><p>可能这里更多的是用go去实现吧，因为go语言我也是刚学，然后语法都不太稳固那种，更别说使用什么api了，所以感觉就是算法和go都拿。有思路但是go很卡壳的话就先用Java写一下然后查go的语法然后用go写</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;本题目有着月份的跨越，所以java版本思路和go差别还是有的。Java是二分找到一次后左右依次扩张（顺序遍历），而go版本是继续使用二分去左右扩张</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>&amp;&amp;nums[left]==nums[right]&amp;&amp;nums[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="type">int</span> l=mid;</span><br><span class="line">                <span class="type">int</span> r=mid;</span><br><span class="line">                <span class="keyword">while</span>(l&gt;=left&amp;&amp;nums[l]==target)&#123;</span><br><span class="line">                    l--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(r&lt;=right&amp;&amp;nums[r]==target)&#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++l,--r&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid]) &#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">     left := searchLeft(nums,target)</span><br><span class="line">     <span class="keyword">if</span> left==<span class="built_in">len</span>(nums)||nums[left]!=target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    right := searchRight(nums,target)</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left,right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchLeft</span><span class="params">(nums[]<span class="type">int</span>,target <span class="type">int</span>)</span></span><span class="type">int</span> &#123;</span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right&#123;</span><br><span class="line">        mid:=(left+right)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target&#123;</span><br><span class="line">            right=mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target &#123;</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRight</span><span class="params">(nums[]<span class="type">int</span>,target <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">     left,right:=<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right&#123;</span><br><span class="line">        mid:=(left+right)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target&#123;</span><br><span class="line">            left=mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    slow:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast:=<span class="number">0</span>;fast&lt;<span class="built_in">len</span>(nums);fast++&#123;</span><br><span class="line">        <span class="comment">// 由fast开路</span></span><br><span class="line">        <span class="keyword">if</span> nums[fast]!=<span class="number">0</span> &#123;</span><br><span class="line">            nums[slow],nums[fast] = nums[fast],nums[slow]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h3><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;ac&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a#c&quot;, t = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 200</code></li><li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> indexS=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> indexT=t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> skipS=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> skipT=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(indexS&gt;=<span class="number">0</span>||indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(indexS&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(indexS)==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipS++;</span><br><span class="line">                    indexS--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                    indexS--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(t.charAt(indexT)==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipT++;</span><br><span class="line">                    indexT--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipT&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    indexT--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(indexS&gt;=<span class="number">0</span>&amp;&amp;indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(indexS)!=t.charAt(indexT))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(indexS&gt;=<span class="number">0</span>||indexT&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indexS--;</span><br><span class="line">            indexT--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backspaceCompare</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    skipS,skipT := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    i,j := <span class="built_in">len</span>(s)<span class="number">-1</span>,<span class="built_in">len</span>(t)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i&gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">&#x27;#&#x27;</span>&#123;</span><br><span class="line">                skipS++</span><br><span class="line">                i--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> skipS&gt;<span class="number">0</span>&#123;</span><br><span class="line">                skipS--</span><br><span class="line">                i--</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j&gt;= <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> t[j]==<span class="string">&#x27;#&#x27;</span>&#123;</span><br><span class="line">                skipT++</span><br><span class="line">                j--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> skipT &gt; <span class="number">0</span>&#123;</span><br><span class="line">                skipT--</span><br><span class="line">                j--</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(temp)<span class="number">-1</span></span><br><span class="line">i := right</span><br><span class="line"><span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line"><span class="keyword">if</span> -nums[left] &gt; nums[right] &#123;</span><br><span class="line">temp[i] = nums[left] * nums[left]</span><br><span class="line">            left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[i] = nums[right] * nums[right]</span><br><span class="line">            right--</span><br><span class="line">&#125;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n :=<span class="built_in">len</span>(nums)</span><br><span class="line">length := n+<span class="number">1</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; right &lt; n; right++ &#123;</span><br><span class="line">sum += nums[right]</span><br><span class="line"><span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">sum -= nums[left]</span><br><span class="line"><span class="keyword">if</span> length &gt; right-left + <span class="number">1</span> &#123;</span><br><span class="line">                length = right-left +<span class="number">1</span></span><br><span class="line">            &#125; </span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; n&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">cnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">left := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right, value := <span class="keyword">range</span> fruits &#123;</span><br><span class="line">cnt[value]++</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cnt) &gt; <span class="number">2</span> &#123;</span><br><span class="line">d := fruits[left]</span><br><span class="line">left++</span><br><span class="line">cnt[d]--</span><br><span class="line"><span class="keyword">if</span> cnt[d] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(cnt, d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, right-left+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="坑爹的模拟行为"><a href="#坑爹的模拟行为" class="headerlink" title="坑爹的模拟行为"></a>坑爹的模拟行为</h2><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][]matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bottom=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>,pow =n*n;</span><br><span class="line">        <span class="keyword">while</span>(ans&lt;=pow)&#123;</span><br><span class="line">            <span class="comment">// 顶</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++) matrix[top][i]=ans++;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++) matrix[i][right]=ans++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 底</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)matrix[bottom][i]=ans++;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--) matrix[i][left]=ans++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">loop := <span class="number">1</span>   </span><br><span class="line">offset := <span class="number">1</span> </span><br><span class="line">startX, startY := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">ans := <span class="number">1</span> </span><br><span class="line">arrays := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> arrays &#123;</span><br><span class="line">arrays[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> loop &lt;= n/<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 顶部</span></span><br><span class="line"><span class="keyword">for</span> ; startY &lt; n-offset; startY++ &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边</span></span><br><span class="line"><span class="keyword">for</span> ; startX &lt; n-offset; startX++ &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底部</span></span><br><span class="line"><span class="keyword">for</span> ; startY &gt;= offset; startY-- &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">for</span> ; startX &gt;= offset; startX-- &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">startX++</span><br><span class="line">startY++</span><br><span class="line">loop++</span><br><span class="line">offset++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">arrays[startX][startY] = ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrays</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">lenX := <span class="built_in">len</span>(matrix)</span><br><span class="line"><span class="keyword">if</span> lenX == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">lenY := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> lenY == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top, right, bottom, left := <span class="number">0</span>, lenY<span class="number">-1</span>, lenX<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">total := lenX * lenY</span><br><span class="line">arrays := <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ans &lt; total &#123;</span><br><span class="line"><span class="comment">// 顶</span></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right &amp;&amp; ans &lt; total; i++ &#123;</span><br><span class="line">arrays[ans] = matrix[top][i]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">top++</span><br><span class="line"><span class="comment">// 右</span></span><br><span class="line"><span class="keyword">for</span> i := top; i &lt;= bottom &amp;&amp; ans &lt; total; i++ &#123;</span><br><span class="line">arrays[ans] = matrix[i][right]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line"><span class="comment">// 底</span></span><br><span class="line"><span class="keyword">for</span> i := right; i &gt;= left &amp;&amp; ans &lt; total; i-- &#123;</span><br><span class="line">arrays[ans] = matrix[bottom][i]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">bottom--</span><br><span class="line"><span class="keyword">for</span> i := bottom; i &gt;= top &amp;&amp; ans &lt; total; i-- &#123;</span><br><span class="line">arrays[ans] = matrix[i][left]</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrays</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arrays := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">5</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;</span><br><span class="line">order := spiralOrder(arrays)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="built_in">print</span>(order[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> java </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习</title>
      <link href="/2024/05/01/ElasticSearch/"/>
      <url>/2024/05/01/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<img src="05/01/ElasticSearch/output.png" class title="output"><h1 id="ES使用场景"><a href="#ES使用场景" class="headerlink" title="ES使用场景"></a>ES使用场景</h1><ol><li><p>全文搜索</p></li><li><p>日志检索，配合Kibana可视化</p></li><li><p>商品搜索</p></li><li><p>实时监控</p></li><li><p>个性化推荐，根据用户搜索历史、浏览行为找出相似内容</p></li><li><p>地理位置搜索（外卖系统）</p></li><li><p>智能提示&#x2F;提示词</p></li></ol><p>🔵 MySQL不能替代ES，因为：</p><ul><li><p>MySQL做全文检索很弱（like %xxx% 查询超级慢）</p></li><li><p>MySQL不擅长复杂聚合分析（特别是大数据量）</p></li><li><p>MySQL无法做到灵活的多字段模糊搜索、地理位置搜索、同义词处理</p></li></ul><p>🔵 ES不能替代MySQL，因为：</p><ul><li><p>ES写一致性弱，不支持多表事务（比如扣库存和扣余额一起回滚）</p></li><li><p>ES不保证强一致性（默认最终一致性，适合搜索，不适合资金类应用）</p></li><li><p>ES的数据模型松散，复杂关系建模很痛苦（比如订单拆分、子表操作）</p></li></ul><h1 id="什么是ElasticSearch？"><a href="#什么是ElasticSearch？" class="headerlink" title="什么是ElasticSearch？"></a>什么是ElasticSearch？</h1><p>简单来说，ES是一个分布式的、基于文档的 搜索引擎+数据库系统</p><ul><li><p>分布式： 天然支持分布式&#x2F;集群、扩展节点</p></li><li><p>文档存储： 数据并不是以行或者列进行存储，而是一份份JSON文档</p><ul><li>聚合分析（数值型字段）会单独存储到Doc values中，列式存储（加速聚合分析，且无冗余字段，比MySQL快太多了</li></ul></li><li><p>搜索引擎： 天然支持全文检索、模糊匹配、权重排行</p></li><li><p>近实时： 数据写进去后，需要等待几秒才能查询到</p></li></ul><h2 id="专业术语（import）"><a href="#专业术语（import）" class="headerlink" title="专业术语（import）"></a>专业术语（import）</h2><ol><li><p>集群： 一堆ES结点组成的整体</p></li><li><p>结点：单个ES实例</p></li><li><p>索引： 类似于MySQL的数据库表</p></li><li><p>文档： 存储的一条数据（JSON） 类似于MySQL的一行数据</p></li><li><p>字段（Field）： 文档里面的key ， 类似于MySQL的列字段</p></li><li><p>Mapping： 字段结构定义 ， 类似于MySQL的表结构</p></li><li><p>分片（shard）：把索引数据切片到不同结点上 （分库分表）</p></li><li><p>副本（Replica）：分片的备份</p></li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>ES的索引一旦建好，很多东西无法随意更改哦！</p><ul><li><p>settings中的参数能够动态修改（副本数）但是分片数无法修改</p></li><li><p>只能追加新字段，无法修改或者删除字段</p></li></ul><h3 id="为什么ES无法随便修改字段？"><a href="#为什么ES无法随便修改字段？" class="headerlink" title="为什么ES无法随便修改字段？"></a>为什么ES无法随便修改字段？</h3><ul><li><p>倒排索引，修改字段&#x3D; 破坏索引结构，代价极大</p></li><li><p>ES底层时不可变文件（Segment）</p><ul><li>类似于LSM树的SSTable</li><li>只写不改</li><li>旧的数据标记为无效，合并时清除</li></ul></li></ul><h3 id="Reindex"><a href="#Reindex" class="headerlink" title="Reindex"></a>Reindex</h3><ol><li><p>创建一个新索引（新的mapping）</p></li><li><p>将老数据reindex过去</p></li><li><p>删除老索引</p></li></ol><p>ES 中 就有这个API -&gt; reindex</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;old_index&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;new_index&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><ol><li>倒排索引</li></ol><p>极为核心的一点</p><p>不同于正排索引那样： 这个文档包含哪些字段</p><p>倒排索引描述： 这些字段 存储在哪些文档中</p><ol><li>文档存储</li></ol><p>ES中，文档时存储数据的基本单位，每个文档实际上就是一个JSON对象，包含一个唯一的ID</p><p>文档数据存储在 一个 名为  Segment 的数据结构中</p><ol><li>Segment（段）</li></ol><p>ES会把文档写入到磁盘中的Segment中</p><p>每个段是不可变的（存储了倒排索引、文档存储、元数据等内容）</p><p>和LSM树的SSTable极为相似</p><ol><li>倒排表</li></ol><p>倒排表是倒排索引的存储形式，用来快速检索词和文档之间的关系</p><style>table.feishu-table td:nth-child(1), table.feishu-table th:nth-child(1) {    width: 33.33%;}table.feishu-table td:nth-child(2), table.feishu-table th:nth-child(2) {    width: 33.33%;}table.feishu-table td:nth-child(3), table.feishu-table th:nth-child(3) {    width: 33.33%;}table.feishu-table tr.width-enforcer {    height: 0 !important;    line-height: 0 !important;    padding: 0 !important;    visibility: hidden !important;    border: none !important;}table.feishu-table tr.width-enforcer td {    height: 0 !important;    padding: 0 !important;    border: none !important;}table.feishu-table {    border-collapse: collapse;    width: 100%;    margin-bottom: 16px;    table-layout: fixed;}table.feishu-table, table.feishu-table th, table.feishu-table td {    border: 1px solid #ddd;}table.feishu-table th, table.feishu-table td {    padding: 8px;    text-align: left;    vertical-align: top;    word-wrap: break-word;}table.feishu-table th {    font-weight: bold;}table.feishu-table img {    max-width: 100%;    height: auto;    display: block;    margin: 0 auto;}</style><table class="feishu-table"><tr class="width-enforcer"><td style="width:33.33%;"></td><td style="width:33.33%;"></td><td style="width:33.33%;"></td></tr><tr><th>分词</th><th>文档id</th><th></th></tr><tr><td>az</td><td>1，2，3</td><td></td></tr><tr><td>阿巴阿巴</td><td>3</td><td></td></tr></table><ul><li><p>每个词都会有一个倒排表，用于存储哪些文档包含整个词，以及这个词在文档中的位置（postings</p></li><li><p>倒排表会结合Posting List 来存储具体的位置信息</p></li></ul><ol><li>FST（Finite State Transducer）</li></ol><p>FST是ES中用来优化倒排索引的一种数据结构，用来存储词典（Term Dictionary），提高查找效率</p><ul><li><p>Term Dictionary 存储所有的term（词条）FST通过有限状态机压缩这些词条</p></li><li><p>由于字典中的词条数量巨大，通过压缩减少存储空间</p></li></ul><ol><li>Posting List</li></ol><p>用于存储某个词出现的文档ID以及其他相关信息（词频、位置等）</p><ul><li><p>结构： Posting List 中每一项都包含了文档ID和该词在文档中的出现位置</p></li><li><p>索引： 每个都会有一个对应的Posting List</p></li></ul><h1 id="CRUD操作过程"><a href="#CRUD操作过程" class="headerlink" title="CRUD操作过程"></a>CRUD操作过程</h1><p>关于近实时问题：<a href="https://blog.csdn.net/hugo_lei/article/details/106519069">https://blog.csdn.net/hugo_lei/article/details/106519069</a></p><h2 id="Elasticsearch搜索引擎的索引构建过程？"><a href="#Elasticsearch搜索引擎的索引构建过程？" class="headerlink" title="Elasticsearch搜索引擎的索引构建过程？"></a>Elasticsearch搜索引擎的索引构建过程？</h2><ol><li><p>解析文档，通过分词器将文档中的字段进行分词，存储到term dictionary中</p></li><li><p>ES会遍历term dictionary，查看这个分词是否已经被记录过。</p></li><li><p>为每一个term（分词）创建一个Posting List，并将该文档id以及该词存储进去</p></li><li><p>如果已经为该 term 创建了一个PostingList，直接合并该文档id进去</p></li></ol><h3 id="输入一个单词去查询会发生什么？"><a href="#输入一个单词去查询会发生什么？" class="headerlink" title="输入一个单词去查询会发生什么？"></a>输入一个单词去查询会发生什么？</h3><ol><li><p>由一个协调节点分析 该索引 是存储在哪个 主分片上的</p></li><li><p>确定好后，将该单词进行分词</p></li><li><p>从目标分片的Segment中使用FST 进行前缀遍历 定位 分词在倒排索引表中的偏移量</p></li><li><p>通过偏移量查询到该 分词所在posting list位置，然后拿到文档id集合</p></li><li><p>将多个segment的id集合进行合并</p></li><li><p>通过相关算法计算相关性评分然后进行结果排序</p></li><li><p>根据from和size进行分页与截断</p></li><li><p>聚合分片结果（文档 ID 和评分，生成全局排序列表）获取原始文档</p></li><li><p>执行高亮&#x2F;聚合操作 返回 JSON格式搜索结果</p></li></ol><h2 id="如何通过文档id查询到对应索引下的文档？"><a href="#如何通过文档id查询到对应索引下的文档？" class="headerlink" title="如何通过文档id查询到对应索引下的文档？"></a>如何通过文档id查询到对应索引下的文档？</h2><ol><li><p>通过hash 计算_id 是存储在哪个分片下的</p></li><li><p>在分片内定位到Segment</p></li><li><p>Segment元信息：维护一个全局文档ID 到 Segment的映射表</p></li><li><p>使用跳表 快速定位文档所在Segment</p></li><li><p>在Segment内部查找文档</p></li><li><p>通过内部的 文档ID 到内部DocID的映射表</p></li><li><p>Lucene每个segment内部是按docID顺序存的，非常快</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">假设查询 GET /orders/_doc/123：</span><br><span class="line">分片路由​：</span><br><span class="line"><span class="built_in">hash</span>(123) % 3 → 分片1。</span><br><span class="line">分片内查找Segment​：</span><br><span class="line">检查分片1的 DocIDMap，发现 _id=123 在 SegmentA。</span><br><span class="line">若 SegmentA 被缓存，直接跳过磁盘IO。</span><br><span class="line">Segment内读取​：</span><br><span class="line">从 SegmentA 的 .doc 文件获取 DocID=5。</span><br><span class="line">从 .dvd（Doc Values）或 _source 中读取 DocID=5 的数据。</span><br><span class="line">返回结果​：</span><br><span class="line">组合字段内容，返回文档。</span><br></pre></td></tr></table></figure><h2 id="如何实现范围查询？"><a href="#如何实现范围查询？" class="headerlink" title="如何实现范围查询？"></a>如何实现范围查询？</h2><ol><li><p>数值&#x2F;日期范围：BKD树</p></li><li><p>字符串范围：字典序+倒排索引</p></li><li><p>日期范围转化为数值</p></li></ol><h3 id="写入一个新文档过程？"><a href="#写入一个新文档过程？" class="headerlink" title="写入一个新文档过程？"></a>写入一个新文档过程？</h3><p><a href="https://blog.csdn.net/hugo_lei/article/details/106519069">https://blog.csdn.net/hugo_lei/article/details/106519069</a></p><ol><li><p>新写入的文档会首先暂存到in-memory-buffer中（不可被搜索到）</p></li><li><p>同时写入事务日志（Translog）（实时fsync写入到磁盘中，顺序写</p></li><li><p>Refresh：默认每1秒，将内存缓冲区的数据生成新的segment并放入到文件系统缓存（可搜索）</p></li></ol><p>Page Cache中？ yep！</p><ol><li>Flush： 定期将文件系统中的段持久化到磁盘中</li></ol><p>接下来是困难版</p><ol><li><p>客户端发送写入请求</p></li><li><p>协调结点处理请求</p></li><li><p>解析索引名称，确定文档应该写入到哪个主分片</p></li><li><p>根据routing 计算目标分片位置（通过_id 进行hash计算）</p></li><li><p>转发请求到该分片所在主分片结点</p></li><li><p>主分片处理写入</p></li><li><p>文档先写入到in-memory-buffer中（不可被搜索、未持久化</p></li><li><p>写入事务日志（Translog</p></li><li><p>同步写入</p></li><li><p>顺序写入磁盘</p></li><li><p>返回客户端ACK</p></li><li><p>Refresh（数据可被搜索</p></li><li><p>Flush（30分钟&#x2F;translog写满</p></li><li><p>Segment Merge（段合并</p></li><li><p>后台自动执行</p></li><li><p>不影响搜索（旧segment在合并完成后才被替换</p></li><li><p>副本分片同步</p></li><li><p>执行主分片相同操作</p></li><li><p>wait_for_active_shards：可配置必须有多少分片可用才返回成功</p></li></ol><h3 id="删除一个文档过程"><a href="#删除一个文档过程" class="headerlink" title="删除一个文档过程"></a>删除一个文档过程</h3><ol><li><p>删除请求到达</p></li><li><p>不会物理删除，而是打上一个标记，同时写入到translog中（查询时会过滤</p></li><li><p>刷新（flush）和合并（merge）时真正删除</p></li></ol><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>本质时删除 + 新增</p><ol><li><p>先打上删除标记</p></li><li><p>将新文档内容写入到in-memory-buffer和translog中</p></li><li><p>更新之后，文档的_version字段会+1，通过乐观锁保证并发一致性</p></li><li><p>后续通过merge清理旧数据</p></li></ol><h3 id="什么时候进行Segment合并"><a href="#什么时候进行Segment合并" class="headerlink" title="什么时候进行Segment合并"></a>什么时候进行Segment合并</h3><ul><li><p>后台自动合并</p></li><li><p>Flush时触发</p></li><li><p>手动触发</p></li><li><p>基于segment数量和大小（数量&#x2F;存储大小达到阈值</p></li></ul><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="FST"><a href="#FST" class="headerlink" title="FST"></a>FST</h3><p><a href="https://juejin.cn/post/7226710109585424440">https://juejin.cn/post/7226710109585424440</a></p><p>FST（有限状态机）用于快速检索、前缀匹配、范围查询</p><p>ES中主要用于存储 词典</p><p>为什么要使用FST？</p><ul><li><p>倒排索引中词典十分庞大，需要通过关键字快速定位Posting List</p></li><li><p>兼顾 小空间占用 + 快速查询</p></li></ul><p>可以理解为压缩版的有向图（共享前缀和后缀）</p><p>核心元素</p><ul><li><p>节点：  一个状态，代表某个字符读到这里了</p></li><li><p>边： 从一个节点到另一个节点的跳转，携带一个字符&#x2F;字符范围</p></li><li><p>输出： 走到某个路径时累加的值</p><ul><li>所有以该前缀开头的词项的公共信息（如内存地址）-》前缀优化共享</li><li>权重（如概率、分数），通过累加得到路径总权重。</li><li>该词在倒排索引中的 文件偏移量（File Pointer）。</li></ul></li></ul><ol><li><p>前缀共享</p></li><li><p>后缀合并</p></li></ol><p>通过前缀遍历快速找到关键词，然后拿到Posting List然后拿到文档ID</p><p>思考： 前缀遍历？那 apple 构建状态机后， 使用 pl 如何搜索呢?</p><p>害，pl 和apple已经是两个单词了，且没有共用一个前缀，所以无法搜到，除非把apple五个字母都进行拆分</p><p>实在要搞的话，可以建立反向索引或者使用高级搜索，遍历Segment</p><p>比如使用appld 可以搜到apple</p><ul><li><p>开始遍历时，记录当前位置和当前误差次数。</p></li><li><p>遇到不同字符时，不是直接失败，而是：</p><ul><li>如果误差没超上限（比如1次），尝试走插入&#x2F;删除&#x2F;替换的可能路径！</li></ul></li><li><p>找到匹配路径后，返回最接近的词</p></li></ul><ol><li><p>Trie只能共享前缀，内存消耗较大，每个节点存储一个字符串</p></li><li><p>通过前缀遍历得到的 词组 + 输出值便能得到 该词在倒排索引表中的偏移量，无需是使用Hash定位（甚至不需要解决hash冲突）</p></li><li><p>查找效率更高，无需注意哈希函数计算以及冲突问题</p></li><li><p>Hash不关心顺序</p></li><li><p>设计不当时，Hash内存开销更大</p></li><li><p>通过前缀遍历进行匹配</p></li><li><p>若设置了模糊查询可以忍受一定程度的不同（比如app-》ape）</p></li><li><p>走完整个词（比如app 走到 p时，发现该边指向节点接受状态（此时累计的输出值就是posting list的起始位置</p></li></ol><p>积累值会变化</p><p>小demo体验一下创建过程</p><p><a href="http://examples.mikemccandless.com/fst.py?terms=mop/0%0D%0Adat/1%0D%0Adog/2%0D%0Ademory/3%0D%0Amax/4&cmd=Build+it!">http://examples.mikemccandless.com/fst.py?terms=mop%2F0%0D%0Adat%2F1%0D%0Adog%2F2%0D%0Ademory%2F3%0D%0Amax%2F4&amp;cmd=Build+it%21</a></p><p>番外？</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> FST结构（有序！）：</span><br><span class="line"></span><br><span class="line"> a --&gt; aa --&gt; apple</span><br><span class="line"> a --&gt; ab --&gt; about</span><br><span class="line"> b --&gt; ba --&gt; base</span><br><span class="line"> b --&gt; bb --&gt; boss</span><br><span class="line"> c --&gt; ca --&gt; car</span><br><span class="line"></span><br><span class="line">比如 range [&quot;ab&quot;, &quot;bb&quot;]:</span><br><span class="line">- 从&quot;ab&quot;找到起点</span><br><span class="line">- 收 about -&gt; base -&gt; boss</span><br><span class="line">- 到了&quot;car&quot;，跳出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Posting-List"><a href="#Posting-List" class="headerlink" title="Posting List"></a>Posting List</h3><p>用于记录每个分词 出现在哪些文档的id集合</p><h2 id="Segment（Import！）"><a href="#Segment（Import！）" class="headerlink" title="Segment（Import！）"></a>Segment（Import！）</h2><p>核心组成部分</p><ol><li>倒排索引（FST+Posting List）</li><li>词项字典 （存储所有的 词项 term ，使用 FST 压缩</li><li>倒排列表（记录 词项 对应的 文档ID 以及位置信息（词频、偏移量）</li><li>存储词项位置和负载（用于短语查询和高亮</li></ol><p>加速全文搜索</p><ol><li>正排索引（Doc Values）</li><li>存储字段的列式数据（numeric、keyword等）</li><li>存储元数据（最大值、最小值、压缩方式</li></ol><p>加速排序、聚合、脚本计算，按照 列式 存储字段</p><ol><li><p>文档存储<br>用于存储原始文档内容（_source）用于返回搜索结果</p></li><li><p>存储原始JSON文档</p></li><li><p>存储文档的元信息（偏移量、压缩方式</p></li><li><p>文档ID映射 (DocID -&gt; _id)<br>内部简历DocID 和用户 _id的映射关系</p></li><li><p>Segment的元信息，DocID 范围</p></li><li><p>Lucene内部通过 DocIDMap维护 _id 到DocID的关联</p></li></ol><h2 id="BKD树"><a href="#BKD树" class="headerlink" title="BKD树"></a>BKD树</h2><p>K-D 树 + B+树混合</p><style>.sjjqtdmanagd{max-width:100%;height:auto;display:block;margin:0 auto;}</style><img src="05/01/ElasticSearch/I1pab8FtIoAwXMx5v7ncaf9FnOe.png" class="sjjqtdmanagd" alt="image"> <!-- 图片未成功捕获 --><ul><li><p>适用场景：数值过滤、地理围栏、时间区间分析等</p></li><li><p>优势​：</p><ul><li>高效磁盘存储​：数据按块（Block）组织，减少随机 I&#x2F;O。</li><li>查询优化​：剪枝策略快速跳过不匹配的数据块。</li><li>压缩存储​：对数值类型（如整数、浮点数）采用增量编码压缩。</li></ul></li></ul><h2 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h2><p><a href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p><p><a href="https://zhuanlan.zhihu.com/p/415799237">https://zhuanlan.zhihu.com/p/415799237</a></p><h3 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h3><p>存储在内存中，用于保存最近更新的数据</p><p>通常使用红黑树&#x2F;跳表数据结构实现，按照Key有序地组织这些数据</p><p>写入的时候通常会追加一份WAL（Write Ahead log）预写日志，保证宕机恢复</p><p>当memtable达到一定大小时，会flush到磁盘中</p><h3 id="Immutable-memtable"><a href="#Immutable-memtable" class="headerlink" title="Immutable memtable"></a>Immutable memtable</h3><p>memtable到sstable的一个中间状态</p><ul><li><p>当memtable满了之后，不会直接删除，会变为一个只读的immutable memetable</p></li><li><p>同时创建一个新的memtable用来接收写请求</p></li><li><p>这个immutable memtable会通过后台线程刷盘，变为sstable</p></li></ul><p>为什么这么设计？</p><ol><li><p>写操作不中断</p></li><li><p>异步刷盘</p></li></ol><h2 id><a href="#" class="headerlink" title></a></h2><h3 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h3><ul><li><p>当Immutable memeTable刷盘到磁盘中，形成一个SSTable文件</p></li><li><p>由于是顺序写到磁盘，写性能极高</p></li><li><p>SSTable是不可变的，只能增加或者合并产生新的SSTable</p></li></ul><p>主要包含内容</p><ol><li><p>Key&#x2F;value数据（有序</p></li><li><p>稀疏索引（快速定位</p></li><li><p>布隆过滤器（快速判断key是否存在</p></li><li><p>元数据（校验数据，时间戳等–》因为可能存在重复key，更新时间最新的才是有效key</p></li></ol><h3 id="Compact策略"><a href="#Compact策略" class="headerlink" title="Compact策略"></a>Compact策略</h3><ul><li>Size-tiered 策略</li></ul><style>.uflogilmdspf{max-width:100%;height:auto;display:block;margin:0 auto;}</style><img src="05/01/ElasticSearch/QqBrbhfgnoBWQ3x1QQKcxNB4nn7.png" class="uflogilmdspf" alt="image"> <!-- 图片未成功捕获 --><ul><li>Leveled 策略</li></ul><style>.yyopnyofycgh{max-width:100%;height:auto;display:block;margin:0 auto;}</style><img src="05/01/ElasticSearch/Mf8Abb3Lvoii5exZCgpcZRMbnIf.png" class="yyopnyofycgh" alt="image"> <!-- 图片未成功捕获 --><p>关键点：</p><ol><li><p>读放大</p></li><li><p>写放大</p></li><li><p>空间放大</p></li></ol><hr><p>Level 0： 刚flush出来的小sstable文件，不要求有序，且key之间范围可以重叠</p><p>Leve 1 及以上： 每一层文件的key范围不重叠，数据量更大</p><h3 id="增删查改操作"><a href="#增删查改操作" class="headerlink" title="增删查改操作"></a>增删查改操作</h3><p>由于LSM树初衷就是应对写操作极为频繁的场景</p><p>插入操作只需要无脑写入memtable就行了</p><p>采用逻辑删除</p><p>写一条墓碑标记到 WAL 和 memtable中</p><p>真正删除该数据是在compaction时完成</p><p>也就是说物理数据在memtable中还是磁盘中，还是不存在，无需关系</p><p>compaction过程会进行删除</p><ol><li><p>先查memtable（因为是最新的操作）</p></li><li><p>再查immutable memtable</p></li><li><p>还没有找到则按照level 0 - n依次查找</p></li></ol><ul><li><p>查询时要处理墓碑标记（如果找到墓碑，就算有旧数据，也算被删除）</p></li><li><p>随着level越高，文件越少、范围越大（减少查找代价）</p></li></ul><ol><li><p>写入WAL</p></li><li><p>写入memtable</p></li><li><p>待修改数据在memtable中，直接覆盖</p></li><li><p>带修改数据在磁盘中 直接写在memtable中，后续合并时新数据覆盖旧</p></li><li><p>该数据不存在，update操作变为insert</p></li></ol><p>其实update和insert操作在这里貌似就是相同的</p><h3 id="有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？"><a href="#有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？" class="headerlink" title="有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？"></a>有墓碑标记的数据什么时候被清除呢？会不会永远无法清除？</h3><p>SSTable合并时删除带有墓碑标记的数据</p><p>由于LSM树的机制，不同层可能包含相同的key</p><p>直接删除可能会漏删老版本，或者删除代价极大</p><ul><li><p>定期强制压缩</p></li><li><p>设置墓碑最大存活时间</p><ul><li>创建一个新SSTable，然后进行拷贝</li></ul></li></ul><h1 id="ElasticSearch（Lucene）-与LSM的异同"><a href="#ElasticSearch（Lucene）-与LSM的异同" class="headerlink" title="ElasticSearch（Lucene） 与LSM的异同"></a>ElasticSearch（Lucene） 与LSM的异同</h1><style>table.feishu-table td:nth-child(1), table.feishu-table th:nth-child(1) {    width: 16.37%;}table.feishu-table td:nth-child(2), table.feishu-table th:nth-child(2) {    width: 39.72%;}table.feishu-table td:nth-child(3), table.feishu-table th:nth-child(3) {    width: 43.91%;}table.feishu-table tr.width-enforcer {    height: 0 !important;    line-height: 0 !important;    padding: 0 !important;    visibility: hidden !important;    border: none !important;}table.feishu-table tr.width-enforcer td {    height: 0 !important;    padding: 0 !important;    border: none !important;}table.feishu-table {    border-collapse: collapse;    width: 100%;    margin-bottom: 16px;    table-layout: fixed;}table.feishu-table, table.feishu-table th, table.feishu-table td {    border: 1px solid #ddd;}table.feishu-table th, table.feishu-table td {    padding: 8px;    text-align: left;    vertical-align: top;    word-wrap: break-word;}table.feishu-table th {    font-weight: bold;}table.feishu-table img {    max-width: 100%;    height: auto;    display: block;    margin: 0 auto;}</style><table class="feishu-table"><tr class="width-enforcer"><td style="width:16.37%;"></td><td style="width:39.72%;"></td><td style="width:43.91%;"></td></tr><tr><th></th><th>LSM树</th><th>Lucene（ES）</th></tr><tr><td>写入</td><td>先写WAL文件再写入MemTable</td><td>先写Translog，再写入in-memroy-buffer</td></tr><tr><td>刷盘</td><td>MemTable满了刷入immutable 然后刷入sstable</td><td>in-mm-buffer满了（或1秒后）刷入Page Cache然后刷入磁盘</td></tr><tr><td>查询</td><td>先mt，再imt，再sst（读放大严重）</td><td>先内存中的segment、再磁盘中的segment加入Caching优化机制，优先读最新段</td></tr><tr><td>删除</td><td>墓碑、懒回收、合并清除</td><td>墓碑，懒回收，合并清除</td></tr><tr><td>合并</td><td>Compaction</td><td>Segment Merge</td></tr><tr><td>数据</td><td>LSM<ol><li><p>Key&#x2F;value数据（有序</p></li><li><p>稀疏索引（快速定位</p></li><li><p>布隆过滤器（快速判断key是否存在</p></li><li><p>元数据（校验数据，时间戳等–》因为可能存在重复key，更新时间最新的才是有效key</p></li></ol></td><td>倒排索引（FST + Posting List)<p>文档存储（JSON）<br>元数据</p></td></tr><tr><td>查询优化</td><td>布隆过滤器、二分查找</td><td>FST词典、跳表、缓存</td></tr><tr><td>数据不可修改</td><td>是</td><td>是</td></tr><tr><td>空间回收</td><td>合并时清理墓碑、去重</td><td>合并时清理已删除文档</td></tr><tr><td>关注点</td><td>写多读少（SSTable有序）</td><td>写少读多</td></tr></table><h2 id="核心相似点"><a href="#核心相似点" class="headerlink" title="核心相似点"></a>核心相似点</h2><ol><li>追加写入</li></ol><ul><li><p>两者都是先将数据写入到内存中，然后刷盘不可变的文件中</p></li><li><p>通过顺序写入减少随机IO</p></li></ul><ol><li>分层合并</li></ol><ul><li><p>LSM树通过后台合并，将多个SSTable合并为更大更有序的SSTable，更新文件，删除冗余数据（重复key）</p></li><li><p>Lucene通过后台合并，将多个小segment合并为一个大Segment，优化查询性能，并回收空间</p></li></ul><ol><li>不可变性</li></ol><ul><li><p>SSTable和Segment写入磁盘后无法更改，删除&#x2F;更新操作通过追加 + 合并进行实现</p></li><li><p>简化并发控制，避免锁竞争</p></li></ul><h2 id="关键差异"><a href="#关键差异" class="headerlink" title="关键差异"></a>关键差异</h2><ol><li><p>设计目标</p></li><li><p>数据结构</p></li><li><p>合并策略</p></li><li><p>删除处理</p></li></ol><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h1 id="从集群来看ES"><a href="#从集群来看ES" class="headerlink" title="从集群来看ES"></a>从集群来看ES</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Cluster&#x3D; 一群Node + 一个Master Node（协调）+ 数据分散存储</p><h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><ul><li><p>Mater Node：复杂管理Cluster状态（建索引、删除、分片分片等）</p></li><li><p>Data Node： 负责存储数据、处理读写请求</p></li><li><p>Coordinating Node： 负责接收请求、拆分请求、分发到各个结点，最后聚合结果</p></li><li><p>Ingest Node： 做预处理</p></li></ul><p>一个结点可以有多个身份</p><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><p>Index相当于数据库中的表，逻辑上的数据集合</p><ul><li><p>每个Index物理上会被分成多个 Shard（分片，存储到不同结点上</p></li><li><p>索引创建时就需要指定主分片数+副本分片数</p></li></ul><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><ul><li><p>主分片（Primary Shard）：真正存储数据的分片。</p></li><li><p>副本分片（Replica Shard）：主分片的拷贝，用于容灾、高可用，同时也能分担查询负载。</p></li><li><p>每个分片其实内部就是一个 Lucene 引擎实例（独立维护倒排索引、Segment、Document等）。</p></li></ul><h1 id="🔥-举个例子"><a href="#🔥-举个例子" class="headerlink" title="🔥 举个例子"></a>🔥 举个例子</h1><p>假设：</p><ul><li><p>我创建了一个 products 索引</p></li><li><p>设置为 3个主分片，每个主分片 1个副本</p></li></ul><p>那就是一共：</p><ul><li><p>3 个 Primary Shard（主）</p></li><li><p>3 个 Replica Shard（副本）</p></li><li><p>总计 6 个 Shard</p></li></ul><p>如果你的集群有 3 个 Node，那么可能的分配：</p><p>⚡ 注意：Elasticsearch 调度器会尽量让 主副本和副副本不在同一台机器上，以提高容错性！</p><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p><a href="https://tech.meituan.com/2022/11/17/elasicsearch-optimization-practice-based-on-run-length-encoding.html">https://tech.meituan.com/2022/11/17/elasicsearch-optimization-practice-based-on-run-length-encoding.html</a></p><h3 id="用-geo-shape-类型（而不是-geo-point）"><a href="#用-geo-shape-类型（而不是-geo-point）" class="headerlink" title=". 用 geo_shape 类型（而不是 geo_point）"></a>. 用 geo_shape 类型（而不是 geo_point）</h3><ul><li><p>geo_point：经纬度，单个点（只能做简单的附近搜索）</p></li><li><p>geo_shape：支持复杂的几何图形，比如：Polygon（多边形）、MultiPolygon（多个多边形）、Line、Envelope 等等。</p></li></ul><p>示例：建索引 Mapping：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /stores</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;delivery_area&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;geo_shape&quot;</span> &#125;  // 这里是 geo_shape</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>存储门店配送范围（多边形Polygon）</li></ol><p>每家店上传一个或多个 Polygon：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /stores/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;王记烧烤&quot;</span>,</span><br><span class="line">  <span class="string">&quot;delivery_area&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coordinates&quot;</span>: [</span><br><span class="line">      [</span><br><span class="line">        [121.4737, 31.2304],</span><br><span class="line">        [121.4750, 31.2300],</span><br><span class="line">        [121.4760, 31.2310],</span><br><span class="line">        [121.4740, 31.2320],</span><br><span class="line">        [121.4737, 31.2304]  // 注意闭合：起点和终点一样</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里的 coordinates 是经纬度数组（WGS84坐标系）。</p></li><li><p>每个 Polygon 一定要首尾闭合。</p></li></ul><hr><ol><li>检索用户位置是否在配送区内</li></ol><p>使用 geo_shape 的 intersects 查询：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /stores/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;geo_shape&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;delivery_area&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;relation&quot;</span>: <span class="string">&quot;intersects&quot;</span>,  // 交集</span><br><span class="line">            <span class="string">&quot;shape&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;point&quot;</span>,</span><br><span class="line">              <span class="string">&quot;coordinates&quot;</span>: [121.4745, 31.2315]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>意思是：找到所有 配送区域覆盖这个点的门店。</p></li><li><p>当然也可以用 within、contains 等其他空间关系。</p></li></ul><h1 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h1><h1 id="外卖系统怎么用ES聚合附近商家的评分？"><a href="#外卖系统怎么用ES聚合附近商家的评分？" class="headerlink" title="外卖系统怎么用ES聚合附近商家的评分？"></a>外卖系统怎么用ES聚合附近商家的评分？</h1><p>比如，用户打开饿了么，美团，想找附近评价高的商家。</p><ol><li>商家文档结构（在ES里）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;shop_id&quot;</span>: 12345,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;川湘小馆&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 31.2304, <span class="string">&quot;lon&quot;</span>: 121.4737 &#125;,  // 经纬度</span><br><span class="line">  <span class="string">&quot;rating&quot;</span>: 4.8,       // 评分</span><br><span class="line">  <span class="string">&quot;monthly_sales&quot;</span>: 230, // 月销售量</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [<span class="string">&quot;川菜&quot;</span>, <span class="string">&quot;小吃&quot;</span>, <span class="string">&quot;快餐&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用户搜索流程</li></ol><ul><li><p>根据用户位置（比如上海市中心）用 geo_distance 查询，查出 3km 内的商家。</p></li><li><p>然后用 聚合（Aggregation）：</p><ul><li>按评分（rating）做 平均值、排序，挑评分最高的商家。</li><li>按销量（monthly_sales）做 销量榜单。</li></ul></li></ul><h3 id="具体的-ES-查询"><a href="#具体的-ES-查询" class="headerlink" title="具体的 ES 查询"></a>具体的 ES 查询</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;3km&quot;</span>,</span><br><span class="line">          <span class="string">&quot;location&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 31.2304, <span class="string">&quot;lon&quot;</span>: 121.4737 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;rating&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;monthly_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="🛒-电商系统怎么用ES算实时销售榜？"><a href="#🛒-电商系统怎么用ES算实时销售榜？" class="headerlink" title="🛒 电商系统怎么用ES算实时销售榜？"></a>🛒 电商系统怎么用ES算实时销售榜？</h1><p>比如淘宝、京东首页上，「实时热销榜」就是这么搞的！</p><ol><li>商品文档结构（在ES里）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sku_id&quot;</span>: <span class="string">&quot;sku_98765&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Apple iPhone 15 Pro&quot;</span>,</span><br><span class="line">  <span class="string">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: 7999,</span><br><span class="line">  <span class="string">&quot;sales_count&quot;</span>: 5023,  // 累积销量</span><br><span class="line">  <span class="string">&quot;last_30min_sales&quot;</span>: 120  // 近30分钟销量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询实时热销榜流程</li></ol><ul><li><p>用字段 last_30min_sales 按照销量做 降序排序。</p></li><li><p>只取 Top 100 热销商品。</p></li><li><p>如果按品类分类（比如”手机”、”家电”），再做个 terms aggregation 按 category 分组！</p></li></ul><h3 id="具体的-ES-查询-1"><a href="#具体的-ES-查询-1" class="headerlink" title="具体的 ES 查询"></a>具体的 ES 查询</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;last_30min_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要按分类出榜单，再加一个聚合：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;by_category&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;field&quot;</span>: <span class="string">&quot;category.keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;top_sales&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;top_hits&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">            &#123; <span class="string">&quot;last_30min_sales&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;size&quot;</span>: 5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 效果：比如“手机”品类下热销前5名，“家电”下热销前5名。</p><h2 id="对比Redis的Zset有什么优势？"><a href="#对比Redis的Zset有什么优势？" class="headerlink" title="对比Redis的Zset有什么优势？"></a>对比Redis的Zset有什么优势？</h2><ol><li><p>支持复杂筛选：比如「上海地区，手机品类，价格5000以内，近一周销量榜」。</p></li><li><p>支持复杂聚合分析：比如「按品牌分组统计销量」「统计每天销量走势」。</p></li><li><p>支持冷热数据分层：老数据转冷，不影响新数据查询。</p></li><li><p>适合超大规模数据：TB级，PB级也能撑住。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 后端 </tag>
            
            <tag> docker使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
